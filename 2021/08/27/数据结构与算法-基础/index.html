

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/Tan.png">
  <link rel="icon" href="/img/Tan.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="本文记录回顾数据结构与算法的学习笔记，代码实现为python；本文只记录基础的数据结构实现、算法实现，深入掌握数据结构与算法必不可少的环节是之后的大量刷题。">
  <meta name="author" content="Eric Tan">
  <meta name="keywords" content="">
  
  <title>数据结构与算法-基础 - Eric Tan</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 80vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Eric Tan</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/curry2.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="数据结构与算法-基础">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-08-27 10:20" pubdate>
        August 27, 2021 am
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      90
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="iconfont icon-arrowdown"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">数据结构与算法-基础</h1>
            
            <div class="markdown-body">
              <p>本文记录回顾数据结构与算法的学习笔记，代码实现为python；本文只记录基础的数据结构实现、算法实现，深入掌握数据结构与算法必不可少的环节是之后的大量刷题。</p>
<span id="more"></span>

<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>1.时间复杂度</p>
<img src="/images/image-20210817162422663.png" srcset="/img/loading.gif" lazyload alt="image-20210817162422663" style="zoom:80%;">

<p>快速判断时间复杂度的技巧：</p>
<img src="/images/image-20210817162603411.png" srcset="/img/loading.gif" lazyload alt="image-20210817162603411" style="zoom:67%;">

<p>2.空间复杂度</p>
<p>评估算法内存占用大小； “时间”比“空间”重要性更大！常用“空间换时间”</p>
<img src="/images/image-20210817162745159.png" srcset="/img/loading.gif" lazyload alt="image-20210817162745159" style="zoom:67%;">

<p>3.冷知识：计算机的运算能力：1s执行10^7次基本运算</p>
<p>​    结合算法的时间复杂度，可以大致估算程序的运行时间</p>
<p>经典递归问题：汉诺塔问题</p>
<p>关键：将<strong>上面n-1个盘子看成整体</strong>，<strong>最底下一个看成另一个整体</strong>；</p>
<p>​            每次先将上面n-1个盘子经由C移动到B，再移动最后一个盘子。</p>
<p>问题转化：n个盘子的移动问题 –&gt; n-1个盘子的移动问题；    不断递归下去，问题不断地化简</p>
<img src="/images/image-20210817163229613.png" srcset="/img/loading.gif" lazyload alt="image-20210817163229613" style="zoom:67%;">

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hanoi</span>(<span class="hljs-params">n, a, b, c</span>):</span>	<span class="hljs-comment"># a经c移动到b</span><br>    <span class="hljs-keyword">if</span> n&gt;<span class="hljs-number">0</span>:<br>        hanoi(n-<span class="hljs-number">1</span>, a, c, b)		<span class="hljs-comment"># 先将n-1个经b移动到c</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;moving from &#123;&#125; to &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a, c))<br>        hanoi(n-<span class="hljs-number">1</span>, b, a, c)		<span class="hljs-comment"># 再将n-1个经a移动到</span><br><br>hanoi(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>)<br></code></pre></td></tr></table></figure>



<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>1.顺序查找：O(n)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">linear_search</span>(<span class="hljs-params">data, val</span>):</span><br>    <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data):<br>        <span class="hljs-keyword">if</span> v == val:<br>            <span class="hljs-keyword">return</span> i<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> none<br></code></pre></td></tr></table></figure>

<p>2.二分查找：O(logn)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span>(<span class="hljs-params">data,val</span>):</span><br>    left = <span class="hljs-number">0</span><br>    right = <span class="hljs-built_in">len</span>(data)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left&lt;=right:<br>        mid = (left + right) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> data[mid] == val:<br>            <span class="hljs-keyword">return</span> mid<br>        <span class="hljs-keyword">elif</span> data[mid] &gt; val:<br>            right = mid-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            left = mid+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> none<br></code></pre></td></tr></table></figure>



<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><img src="/images/image-20210817165659847.png" srcset="/img/loading.gif" lazyload alt="image-20210817165659847" style="zoom:67%;">

<p>1.冒泡排序</p>
<p>列表中每两个相邻的数，如果前面比后面大，则交换两数；</p>
<p>一次排序完成后，无序区的最大数浮出来；</p>
<p>代码的关键点：趟数<code>n-1</code>、无序区的范围</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bubble_sort</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data)-<span class="hljs-number">1</span>):	<span class="hljs-comment"># n-1趟</span><br>        change = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data)-i-<span class="hljs-number">1</span>):	<span class="hljs-comment"># 无序区域</span><br>            <span class="hljs-keyword">if</span> data[j] &lt; data[j+<span class="hljs-number">1</span>]:	<span class="hljs-comment"># 升序排列</span><br>                data[j], data[j+<span class="hljs-number">1</span>] = data[j+<span class="hljs-number">1</span>], data[j]	<span class="hljs-comment"># 交换</span><br>                change = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> change:	<span class="hljs-comment"># 改良：一趟中五改变，提前停止</span><br>                <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>



<p>2.选择排序：</p>
<p>每次找无序区中最小的数，与第一个位置的元素交换位置；</p>
<p>趟数<code>n-1</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">select_sort</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data)-<span class="hljs-number">1</span>):<br>        min_loc = i		<span class="hljs-comment"># 记录无序区min</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(data)):		<span class="hljs-comment"># 找出无序区min</span><br>            <span class="hljs-keyword">if</span> data[j] &lt; data[min_loc]:<br>                min_loc = j<br>        <span class="hljs-keyword">if</span> min_loc != i:<br>            data[i], data[min_loc] = data[min_loc], data[i]		<span class="hljs-comment"># 无序区第1个值 与 无序区min交换</span><br></code></pre></td></tr></table></figure>

<p>技巧：由于<strong>range的“前包后不包”</strong>特点 + <strong>数组的“从0开始”</strong>特点，数组第4位，index=3，我需要range到4；所以要取到数组第 i 位，就要range到 i 。</p>
<p>3.插入排序</p>
<p>每次从无序区取出一个数，插入有序区中正确的位置；</p>
<p>趟数<code>n-1</code>，直接把第一个数作为初始有序区，所以循环为<code>range(1, n)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_sort</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(data)):	<span class="hljs-comment"># i 表示取出数的index</span><br>        tmp = data[i]<br>        j = i-<span class="hljs-number">1</span> 	<span class="hljs-comment"># j 表示有序区最右边元素的index</span><br>        <span class="hljs-keyword">while</span> data[j] &gt; tmp <span class="hljs-keyword">and</span> j &gt;=<span class="hljs-number">0</span>:	<span class="hljs-comment"># 比tmp大</span><br>            data[j+<span class="hljs-number">1</span>] = data[j]		<span class="hljs-comment"># 右移</span><br>            j -= <span class="hljs-number">1</span><br>        data[j+<span class="hljs-number">1</span>] = tmp		<span class="hljs-comment"># 比tmp小，找到了合适的插入位置</span><br></code></pre></td></tr></table></figure>



<p>4.快速排序</p>
<p>思路较为复杂，速度明显快</p>
<img src="/images/image-20210817173517068.png" srcset="/img/loading.gif" lazyload alt="image-20210817173517068" style="zoom: 50%;">

<p>递归：p的左边、右边分别执行上述操作，再次一级的左边、右边分别执行上述操作；</p>
<p>实现：只需要实现归位的算法，后面递归调用即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort</span>(<span class="hljs-params">data, left, right</span>):</span>	<span class="hljs-comment"># 区域左端，区域右端</span><br>    <span class="hljs-keyword">if</span> left &lt; right:	<span class="hljs-comment"># 递归停止条件：left = right， 即该区域只有1个元素</span><br>        mid = partition(data, left, right)<br>        quick_sort(data, left, mid-<span class="hljs-number">1</span>)	<span class="hljs-comment"># 左分区递归</span><br>        quick_sort(data, mid+<span class="hljs-number">1</span>, right)	<span class="hljs-comment"># 右分区递归</span><br></code></pre></td></tr></table></figure>

<p>关键在于<code>partition</code>函数的实现，即如何让元素归位，使得左边都是小于它的，右边都是大于它的；</p>
<p>过程较为复杂，左右交替进行，忘了就看这个：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uA411N7c5?p=16">清华大学博士讲解Python数据结构与算法（完整版）全套100节_哔哩哔哩_bilibili</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partition</span>(<span class="hljs-params">data,left,right</span>):</span><br>    tmp = data[left]	<span class="hljs-comment"># 每次从左边取值寻找分区</span><br>    <span class="hljs-keyword">while</span> left &lt; right:<br>        <span class="hljs-keyword">while</span> data[right] &gt;= tmp <span class="hljs-keyword">and</span> left &lt; right: 	<span class="hljs-comment"># 从右边找比tmp小的数； </span><br>            									<span class="hljs-comment"># 同时警惕可能都比tmp大，所以要判断left &lt; right，一旦指针重合，也退出</span><br>        	right -= <span class="hljs-number">1</span><br>        data[left] = data[right]	<span class="hljs-comment"># 找到比tmp小的数，把这个数写到left的位置上</span><br>        <br>        <span class="hljs-keyword">while</span> data[left] &lt;=tmp <span class="hljs-keyword">and</span> left &lt; right:	<span class="hljs-comment"># 从左边找比tmp大的数</span><br>            left += <span class="hljs-number">1</span><br>        data[right] = data[left]<br>    data[left] = tmp<br>    <span class="hljs-keyword">return</span> left  <span class="hljs-comment"># return right也行 ，最后已经碰头了</span><br></code></pre></td></tr></table></figure>

<p>复杂度不严谨推导：</p>
<p>左右分区依次减半，所以logn；分区内的partition操作复杂度是n；所以整体是O(nlogn)</p>
<img src="/images/image-20210818100300341.png" srcset="/img/loading.gif" lazyload alt="image-20210818100300341" style="zoom:67%;">

<p>快速排序的最坏情况：列表原本呈倒序排列，则每次分区只能减少一个元素，复杂度变为 n方</p>
<p>拓展：随机化的快速排序：原始的快排每次都取最左侧元素寻找分区，进一步可以随机选择元素寻找分区</p>
<p>5.堆排序</p>
<p>基于：树与二叉树；简单了解概念</p>
<p>满二叉树、完全二叉树</p>
<img src="/images/image-20210818114926199.png" srcset="/img/loading.gif" lazyload alt="image-20210818114926199" style="zoom:80%;">

<p>二叉树的存储方式：链式存储、顺序存储 (列表存储)</p>
<img src="/images/image-20210818115921246.png" srcset="/img/loading.gif" lazyload alt="image-20210818115921246" style="zoom: 50%;">

<p>堆：一种特殊的完全二叉树；父节点大于孩子节点 / 小于</p>
<img src="/images/image-20210818120053585.png" srcset="/img/loading.gif" lazyload alt="image-20210818120053585" style="zoom: 67%;">

<p><strong>堆的向下调整：</strong>简单理解，就是不符合堆结构的，经过不断调整直至符合堆结构</p>
<p>以大根堆为例，</p>
<img src="/images/image-20210818120438134.png" srcset="/img/loading.gif" lazyload alt="image-20210818120438134" style="zoom:67%;">

<p>2比子节点小，必须更换，<strong>将子节点中更大的9换上去</strong>；继续比较，直至整棵树变为大根堆。</p>
<p>综上，总结堆排序过程：建立堆 –&gt; 挨个出数</p>
<p><img src="/images/image-20210818120711448.png" srcset="/img/loading.gif" lazyload alt="image-20210818120711448"></p>
<p><strong>建立堆</strong>的过程：从末尾的小堆开始逐个调整。涉及知识点：由孩子节点找父节点： <code>(j-1) // 2</code></p>
<p>挨个出数过程：每次取出堆顶后，固定让堆最后一个元素放到堆顶（交换堆顶与堆尾），然后调整堆有序；重复直至堆空，至此降序排列完成。</p>
<p>代码实现：</p>
<p>挨个出数时，为了减少内存消耗，不另外创建列表存储出来的数，而是放到堆的最后面，并将“最后元素”的指针提前</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 堆的向下调整</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sift</span>(<span class="hljs-params">data, low, high</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    param data: 列表</span><br><span class="hljs-string">    param low: 堆的根节点位置</span><br><span class="hljs-string">    param high: 堆的最后一个元素的位置</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <br>    <span class="hljs-comment"># 需要两个“指针”来追踪 本节点和孩子节点</span><br>    i = low		<span class="hljs-comment"># 取堆顶</span><br>    j = <span class="hljs-number">2</span>*i +<span class="hljs-number">1</span> 	 <span class="hljs-comment"># 左孩子</span><br>    tmp = data[i]<br>    <span class="hljs-keyword">while</span> j &lt;= high：	<span class="hljs-comment"># 只要j没有越界</span><br>    	<span class="hljs-keyword">if</span> data[j+<span class="hljs-number">1</span>] &gt; data[j] <span class="hljs-keyword">and</span> j+<span class="hljs-number">1</span> &lt;=high:	<span class="hljs-comment"># 存在右孩子 且 右孩子&gt;左孩子</span><br>            j = j+<span class="hljs-number">1</span> 	<span class="hljs-comment"># 切换到右分支进行寻找</span><br>            <br>        <span class="hljs-keyword">if</span> data[j] &gt; tmp:	<span class="hljs-comment"># 较大的孩子 &gt; tmp</span><br>            data[i] = data[j]	<span class="hljs-comment"># 孩子换上去</span><br>            i = j<br>            j = <span class="hljs-number">2</span>*i + <span class="hljs-number">1</span>		<span class="hljs-comment"># 改变指针，往下追踪一层</span><br>        <span class="hljs-keyword">else</span>:	<span class="hljs-comment"># tmp更大，把tmp放到i的位置上，就结束了</span><br>            data[i] = tmp	<span class="hljs-comment"># i此时是某一级的领导位置</span><br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        data[i] = tmp	<span class="hljs-comment"># 如果i一直找到了叶节点，则上面的循环会跳出，tmp还未放置；所以此时tmp直接放在i上</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 堆排序</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">heap_sort</span>()</span><br><span class="hljs-function">	&quot;&quot;&quot;</span><br><span class="hljs-function">	建立堆 --&gt; 出数 + 向下调整</span><br><span class="hljs-function">	&quot;&quot;&quot;</span><br><span class="hljs-function">	# 1.建堆</span><br><span class="hljs-function">    n = <span class="hljs-built_in">len</span>(data)</span><br><span class="hljs-function">    <span class="hljs-keyword">for</span> i <span class="hljs-built_in">range</span>((n-2)//2, -1, -1):</span>	<span class="hljs-comment"># 从最后节点的父节点开始，倒序遍历到0</span><br>        <span class="hljs-comment"># i表示建堆时，调整的部分的根节点</span><br>        sift(data, i, n-<span class="hljs-number">1</span>)		<span class="hljs-comment"># 技巧：由于high仅用于判断孩子是否越界，所以此处不管在调整哪个子堆，都用整个堆的结尾元素作为high</span><br>        <br>    <span class="hljs-comment"># 2.出数</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># i表示当前堆的“最后位置”</span><br>        data[<span class="hljs-number">0</span>], data[i] = data[i], data[<span class="hljs-number">0</span>]		<span class="hljs-comment"># 交换堆顶与堆尾</span><br>        sift(data, <span class="hljs-number">0</span>, i-<span class="hljs-number">1</span>)	 <span class="hljs-comment"># 为节省内存，最后一个位置已经放置了取出的元素，所以i-1是新的堆尾</span><br></code></pre></td></tr></table></figure>

<p>大根堆出数后的结果：最后的堆是升序；如果每次都输出一个数，则降序</p>
<p>小根堆出数后的结果：最后的堆是降序；如果每次都输出一个数，则升序。</p>
<p>堆排序的时间复杂度：</p>
<p><code>sift()</code>函数：<code>logn</code>，结合<code>heap_sort()</code>函数，最终<strong>O(nlogn)</strong></p>
<p><strong>堆排序的python内置模块</strong>：<code>heapq</code></p>
<p>堆排序的应用——<code>topk</code>问题</p>
<img src="/images/image-20210819072808158.png" srcset="/img/loading.gif" lazyload alt="image-20210819072808158" style="zoom:67%;">

<p>取列表中前k个数建立小根堆，然后依次取剩余元素调整堆，最后堆中剩下的元素就是前k大的元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">topk</span>(<span class="hljs-params">data, k</span>):</span><br>    heap = data[:k]		<span class="hljs-comment"># 取前k个元素建堆</span><br>    <span class="hljs-comment"># 1.建堆</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((k-<span class="hljs-number">2</span>)//<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>        sift(heap, i, k-<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-comment"># 2.遍历</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k, <span class="hljs-built_in">len</span>(data)-<span class="hljs-number">1</span>):    <span class="hljs-comment"># 依次遍历剩余元素</span><br>        <span class="hljs-keyword">if</span> data[i] &gt; heap[<span class="hljs-number">0</span>]:	<span class="hljs-comment"># 大于堆顶，把堆顶挤掉并调整堆（注：只需要和堆顶比较,因堆顶就是最小数）</span><br>            heap[<span class="hljs-number">0</span>] = data[i]<br>            sift(heap, <span class="hljs-number">0</span>, k-<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-comment"># 3.出数</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        heap[<span class="hljs-number">0</span>], heap[i] = heap[i], heap[<span class="hljs-number">0</span>]<br>        sift(heap, <span class="hljs-number">0</span>, i-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> heap	 <span class="hljs-comment"># 小根堆，最后的堆是降序</span><br></code></pre></td></tr></table></figure>

<p>​    </p>
<p>6.归并排序</p>
<p>左右两个分区，假设分区有序，依次遍历两分区的指针，取出较小的数。</p>
<img src="/images/image-20210819080629122.png" srcset="/img/loading.gif" lazyload alt="image-20210819080629122" style="zoom:80%;">

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 一次归并</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span>(<span class="hljs-params">data, low, mid, high</span>):</span>	<span class="hljs-comment"># 左(low, mid)  右(mid+1, high)</span><br>    i = low		<span class="hljs-comment"># 左区指针</span><br>    j = mid + <span class="hljs-number">1</span> 	<span class="hljs-comment"># 右区指针</span><br>    ltmp = []<br>    <span class="hljs-keyword">while</span> i &lt;= mid <span class="hljs-keyword">and</span> j &lt;= high:	<span class="hljs-comment"># 只要两边都有数</span><br>        <span class="hljs-keyword">if</span> data[i] &lt; data[j]:<br>            ltmp.append(data[i])<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            ltmp.append(data[j])<br>            j += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-comment"># while执行完，一定有一部分没数了</span><br>    <span class="hljs-keyword">while</span> i &lt;= mid:		<span class="hljs-comment"># 左边还有，全部加进列表即可</span><br>        ltmp.append(data[i])<br>        i += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> j &lt;= high:<br>        ltmp.append(data[j])<br>        j += <span class="hljs-number">1</span><br>    data[low:high+<span class="hljs-number">1</span>] = ltmp		<span class="hljs-comment"># 临时列表中的值必须写回去；因后面有递归调用</span><br>    <br><span class="hljs-comment"># 归并递归</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_sort</span>(<span class="hljs-params">data, low, high</span>):</span><br>    <span class="hljs-keyword">if</span> low &lt; high:	<span class="hljs-comment"># 还有至少2个元素，没达到停止条件</span><br>        mid = (low + high) // <span class="hljs-number">2</span><br>        merge_sort(data, low, mid)	<span class="hljs-comment"># 1.左边排好序</span><br>        merge_sort(data, mid+<span class="hljs-number">1</span>, high)	<span class="hljs-comment"># 2.右边排好序</span><br>        <br>        merge(data, low, mid, high)	<span class="hljs-comment"># 3.左右归并</span><br></code></pre></td></tr></table></figure>

<p>递归在代码上非常简单，但在理解上比较难</p>
<p>复杂度：O(nlogn)   空间复杂度：O(n)</p>
<p><img src="/images/image-20210819084201604.png" srcset="/img/loading.gif" lazyload alt="image-20210819084201604"></p>
<p>稳定性：两元素值一样时，相对位置不变</p>
<p>python的内置排序<code>sort</code>是基于归并排序的，C++、Java的内置排序都是基于快速排序，但问题是快排不稳定。</p>
<p>7.希尔排序</p>
<p>每一趟都用插入排序</p>
<p>思想：每趟并不使某些元素有序，但会使整体数据越来越接近有序；最后一趟一定会使得所有数据有序。</p>
<p>代码：将插入排序的“1”全部改成分组大小“gap”即可实现每一趟的插入</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_sort_gap</span>(<span class="hljs-params">data, gap</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(gap, <span class="hljs-built_in">len</span>(data)):	<span class="hljs-comment"># i 表示取出数的index</span><br>        tmp = data[i]<br>        j = i-gap 	<span class="hljs-comment"># j 表示有序区最右边元素的index</span><br>        <span class="hljs-keyword">while</span> data[j] &gt; tmp <span class="hljs-keyword">and</span> j &gt;=<span class="hljs-number">0</span>:	<span class="hljs-comment"># 比tmp大</span><br>            data[j+gap] = data[j]		<span class="hljs-comment"># 右移</span><br>            j -= gap<br>        data[j+gap] = tmp		<span class="hljs-comment"># 比tmp小，找到了合适的插入位置</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shell_sort</span>(<span class="hljs-params">data</span>):</span><br>    d = <span class="hljs-built_in">len</span>(data) // <span class="hljs-number">2</span><br>    <span class="hljs-keyword">while</span> d &gt;= <span class="hljs-number">1</span>:<br>        insert_sort_gap(data, d)<br>        d //= <span class="hljs-number">2</span>		<span class="hljs-comment"># 每一趟分组数折半</span><br></code></pre></td></tr></table></figure>

<p>希尔排序的时间复杂度比较复杂，且和分组数gap的取法有关，不讨论。</p>
<p>8.计数排序</p>
<p>把所有数出现的次数统计出来，然后直接从小到大列出这些数即排序完成</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count_sort</span>(<span class="hljs-params">data, max_count=<span class="hljs-number">100</span></span>):</span><br>    count = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_count + <span class="hljs-number">1</span>)]<br>    <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> data:<br>        count[data] += <span class="hljs-number">1</span><br>    data.clear()	<span class="hljs-comment"># 原列表清空，</span><br>    <span class="hljs-keyword">for</span> idx, val <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(count):	<span class="hljs-comment"># 哪个数出现了几次？ index和value都要取</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(val):<br>            data.append(idx)<br></code></pre></td></tr></table></figure>

<p>计数排序非常快，时间复杂度使<code>O(n)</code></p>
<p>但使用计数排序有缺陷：</p>
<p>1）必须知道数据的范围，即max_count参数</p>
<p>2）如果数据的范围巨大（如10亿），则内存开销也巨大</p>
<p>9.桶排序</p>
<p>基于计数排序的改进</p>
<img src="/images/image-20210819091329243.png" srcset="/img/loading.gif" lazyload alt="image-20210819091329243" style="zoom:67%;">

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bucket_sort</span>(<span class="hljs-params">data, n, max_num</span>):</span>	<span class="hljs-comment"># n:桶个数  max_count：最大值</span><br>    buckets = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]	<span class="hljs-comment"># 创建n个桶（二维列表）</span><br>    <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> data:<br>        i = <span class="hljs-built_in">min</span>(var // (max_num // n), n-<span class="hljs-number">1</span>)	<span class="hljs-comment"># i表示放到几号桶里； 取min：将最大数、可能超过最大数的数，都放到最后一个桶里</span><br>        buckets[i].append(var)<br>        <br>        <span class="hljs-comment"># 每放入一个值，都要保持桶内有序（用冒泡的思想排序）</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(buckets[i])-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> buckets[i][j] &lt; buckets[i][j-<span class="hljs-number">1</span>]:<br>                buckets[i][j], buckets[i][j-<span class="hljs-number">1</span>] = buckets[i][j-<span class="hljs-number">1</span>], buckets[i][j]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>                <br>    <span class="hljs-comment"># 至此所有桶都有序了,将桶合并为列表</span><br>    sorted_data=[]<br>    <span class="hljs-keyword">for</span> buc <span class="hljs-keyword">in</span> buckets:<br>        sorted_data.extend(buc)<br>    <span class="hljs-keyword">return</span> sorted_data<br></code></pre></td></tr></table></figure>

<p>桶排序的复杂度取决于数据的分布</p>
<p>10.基数排序</p>
<p>其实就是逐一比较每一位；</p>
<p>先按个位分桶，然后依次输出，<strong>保证个位小的先输出</strong>；然后按十位分桶，再依次输出，<strong>保证十位小的先输出</strong>；以此类推，完成排序。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">radix_sort</span>(<span class="hljs-params">data</span>):</span><br>    max_num = <span class="hljs-built_in">max</span>(data)	<span class="hljs-comment"># 取最大值，确定比较位数</span><br>    ite = <span class="hljs-number">0</span>	 <span class="hljs-comment"># 迭代次数，决定了当前应取哪一位</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">10</span> ** ite &lt;= max_num:<br>        buckets = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]	<span class="hljs-comment"># 桶, 每一位都是10个数，所以buckets列表中有10个子列表</span><br>        <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> data:<br>            digit = (var // <span class="hljs-number">10</span> ** ite) % <span class="hljs-number">10</span>	<span class="hljs-comment"># 取出相应位 </span><br>        	buckets[digit].append(var)<br>    	<span class="hljs-comment"># 分桶完成，清空data来存放新的顺序</span><br>        data.clear()<br>        <span class="hljs-keyword">for</span> buc <span class="hljs-keyword">in</span> buckets:<br>            data.extend(buc)<br>        <br>        <span class="hljs-comment"># 继续取下一位</span><br>        ite += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>涉及一个知识点：取数字的某一位</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">%<span class="hljs-number">10</span>：取出一个数的最后一位<br>//<span class="hljs-number">10</span>：去掉一个数的最后一位	（//<span class="hljs-number">100</span>：去掉最后两位 ...）<br><br><span class="hljs-comment"># 例如987</span><br><span class="hljs-number">987</span> % <span class="hljs-number">10</span> = <span class="hljs-number">7</span><br><span class="hljs-number">987</span> // <span class="hljs-number">10</span> = <span class="hljs-number">98</span>   <span class="hljs-number">98</span> % <span class="hljs-number">10</span> = <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure>



<p>与桶排序的区别：桶排序在装入桶后要进行排序；但基数排序没有这个过程，装入桶之后直接输出。</p>
<p>复杂度：<code>O(kn)</code>;    </p>
<p>辨析：快速排序O(nlogn)  <strong>log= log(2, n)</strong></p>
<p>​            基数排序O(kn)    <strong>k = logn =log(10, n)</strong></p>
<p>所以基数排序平均比快速排序快一点。</p>
<p>刷题！！！</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>重点关注——逻辑结构</p>
<p>1.列表</p>
<p>C++数组与python列表很相似，但有2点不同：</p>
<p>1）数组元素类型必须相同；    2）数组长度固定</p>
<p>python列表怎么解决上述两个约束？ 其实列表中存储的是<strong>数据的地址</strong>！所以元素类型可不同。</p>
<p>python列表：</p>
<p>查找、添加元素：<code>O(1)</code></p>
<p>插入、删除元素：<code>O(n)</code>因为插入/删除后，还要依次移动其它元素</p>
<p>2.栈</p>
<p>用python列表实现栈结构</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">stack</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.stack = []<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, element</span>):</span>	<span class="hljs-comment"># 入栈</span><br>        self.stack.append(element)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>):</span>	<span class="hljs-comment"># 出栈</span><br>        <span class="hljs-keyword">return</span> self.stack.pop()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_top</span>(<span class="hljs-params">self</span>):</span>	<span class="hljs-comment"># 查看栈顶</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.stack) &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> self.stack[-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span>(<span class="hljs-params">self</span>):</span>		<span class="hljs-comment"># 判断栈空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.stack) == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>栈的应用——括号匹配问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">brace_match</span>(<span class="hljs-params">s</span>):</span>	<span class="hljs-comment"># s为string</span><br>    stack = Stack()	<span class="hljs-comment"># 创建栈</span><br>    match = &#123;<span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>:<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>:<span class="hljs-string">&#x27;&#123;&#x27;</span>&#125;	<span class="hljs-comment"># 匹配关系</span><br>    <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> s:<br>        <span class="hljs-keyword">if</span> ch <span class="hljs-keyword">in</span> &#123;<span class="hljs-string">&#x27;(&#x27;</span>,<span class="hljs-string">&#x27;[&#x27;</span>,<span class="hljs-string">&#x27;&#123;&#x27;</span>&#125;:<br>            stack.push(ch)		<span class="hljs-comment"># 若左括号，进栈</span><br>        <span class="hljs-keyword">else</span>:	<span class="hljs-comment"># 右括号，分三种情况</span><br>            <span class="hljs-keyword">if</span> stack.is_empty():	<span class="hljs-comment"># 1.栈空</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">elif</span> stack.get_top == match[ch]:	<span class="hljs-comment"># 2.和栈顶匹配成功</span><br>                stack.pop()<br>            <span class="hljs-keyword">else</span>:	<span class="hljs-comment"># 3.不匹配</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <br>    <span class="hljs-keyword">if</span> stack.is_empty():	<span class="hljs-comment"># 匹配完后栈空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:	<span class="hljs-comment"># 栈不空，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>



<p>3.队列</p>
<p>为了降低操作的复杂度，使用<code>环形队列</code></p>
<img src="/images/image-20210820102806738.png" srcset="/img/loading.gif" lazyload alt="image-20210820102806738" style="zoom: 50%;">

<p><code>rear</code>：队尾指针，进元素</p>
<p><code>front</code>：队首指针，出元素；跟着移动</p>
<p>问题：当<code>rear</code>循环一圈后，如何涉及计算方法，使11下一步跳到0。</p>
<p>（1）空队列：<code>rear == front</code></p>
<p>（2）队满：<code>(rear + 1) % n == front</code> ; 注意：队满时必须牺牲一个内存，否则rear和front重合无法和“队空”区分</p>
<p>（3）环形衔接处的跳跃：</p>
<p>​            进队时跳跃：<code>rear = (rear + 1) % n</code></p>
<p>​            出队时跳跃：<code>front = (front + 1) % n</code>         n为队列长度</p>
<p>实现环形队列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, size</span>):</span><br>        self.queue = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size)]	<span class="hljs-comment"># 环形队列须固定长度</span><br>        self.rear = <span class="hljs-number">0</span><br>        self.front = <span class="hljs-number">0</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, element</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.is_full():<br>    		self.rear = (self.rear + <span class="hljs-number">1</span>) % self.size<br>        	self.queue[self.rear] = element<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&quot;Queue is full.&quot;</span>)	<span class="hljs-comment"># 抛异常</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>)</span><br><span class="hljs-function">    	<span class="hljs-title">if</span> <span class="hljs-title">not</span> <span class="hljs-title">self</span>.<span class="hljs-title">is_empty</span>():</span><br>    		self.front = (self.front + <span class="hljs-number">1</span>) % self.size<br>        	<span class="hljs-keyword">return</span> self.queue[self.front]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&quot;Queue is empty.&quot;</span>)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.rear == self.front<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_full</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> (self.rear + <span class="hljs-number">1</span>) % self.size == self.front<br></code></pre></td></tr></table></figure>

<p>python内置模块已有队列的实现，不用再造轮子~</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque	<span class="hljs-comment"># 双向队列</span><br><br>q = deque()<br><span class="hljs-comment">#q = deque([1,2,3], 5)	最大长度5</span><br>q.append(<span class="hljs-number">1</span>)	<span class="hljs-comment"># 队尾进队</span><br>q.popleft()	<span class="hljs-comment"># 队首出队</span><br><br>q.appendleft(<span class="hljs-number">1</span>)	<span class="hljs-comment"># 队首进队</span><br>q.pop()	<span class="hljs-comment"># 队尾出队</span><br></code></pre></td></tr></table></figure>



<p>栈和队列的应用——<strong>迷宫问题</strong></p>
<p>栈——深度优先搜索 (回溯法)</p>
<p>队列——广度优先搜索</p>
<img src="/images/image-20210820111028241.png" srcset="/img/loading.gif" lazyload alt="image-20210820111028241" style="zoom:80%;">

<p>框起来的是队列中的元素，也即队列中存储的不是路径，而是当前可扩展的方向</p>
<p>由于最后要得到路径，所以需要额外的列表存储每次出队的元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br>maze=[[...]]    <span class="hljs-comment"># 迷宫矩阵；1表示墙，0表示路</span><br><br>dirs=[<br>    <span class="hljs-keyword">lambda</span> x,y:(x+<span class="hljs-number">1</span>,y),<br>    <span class="hljs-keyword">lambda</span> x,y:(x-<span class="hljs-number">1</span>,y),<br>    <span class="hljs-keyword">lambda</span> x,y:(x,y-<span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">lambda</span> x,y:(x,y+<span class="hljs-number">1</span>),<br>]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_r</span>(<span class="hljs-params">path</span>):</span><br>    curNode=path[-<span class="hljs-number">1</span>]    <span class="hljs-comment"># 终点</span><br>    realpath=[]  <span class="hljs-comment"># path列表中并不是真实路径，而是所有扩展的节点</span><br>                 <span class="hljs-comment"># 所以用realpath来存储真实路径</span><br><br>    <span class="hljs-keyword">while</span> curNode[<span class="hljs-number">2</span>] != -<span class="hljs-number">1</span>:  <span class="hljs-comment"># =-1时回到起点</span><br>        realpath.append(curNode[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>])<br>        curNode=path[curNode[<span class="hljs-number">2</span>]]    <span class="hljs-comment"># 找到上一个节点</span><br><br>    realpath.append(curNode[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>])<br>    realpath.reverse()  <span class="hljs-comment"># 倒序</span><br>    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> realpath:<br>        <span class="hljs-built_in">print</span>(node)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maze_path_queue</span>(<span class="hljs-params">x1,y1,x2,y2</span>):</span><br>    queue=deque()<br>    <span class="hljs-comment"># 起点进队；用三元组，第三个数表示上一步</span><br>    queue.append((x1,y1,-<span class="hljs-number">1</span>))<br>    path=[]     <span class="hljs-comment"># 存储路径</span><br><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue)&gt;<span class="hljs-number">0</span>:<br>         curNode=queue.pop()    <span class="hljs-comment"># 队首出队</span><br>         path.append(curNode)<br><br>         <span class="hljs-comment"># 判断是否已经到终点</span><br>         <span class="hljs-keyword">if</span> curNode[<span class="hljs-number">0</span>]==x2 <span class="hljs-keyword">and</span> curNode[<span class="hljs-number">1</span>]==y2:<br>             print_r(path)  <span class="hljs-comment"># 打印路径</span><br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>         <span class="hljs-comment"># 走下一步</span><br>         <span class="hljs-keyword">for</span> <span class="hljs-built_in">dir</span> <span class="hljs-keyword">in</span> dirs:   <span class="hljs-comment"># 遍历四个方向</span><br>             nextNode=<span class="hljs-built_in">dir</span>(curNode[<span class="hljs-number">0</span>],curNode[<span class="hljs-number">1</span>])<br>             <span class="hljs-keyword">if</span> maze[nextNode[<span class="hljs-number">0</span>]][nextNode[<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span>:    <span class="hljs-comment"># 能走</span><br>                 queue.append(nextNode[<span class="hljs-number">0</span>], nextNode[<span class="hljs-number">1</span>], <span class="hljs-built_in">len</span>(path)-<span class="hljs-number">1</span>)    <span class="hljs-comment"># 第三个值存储curNode在path列表中的位置;等于当前path长度-1</span><br>                 <span class="hljs-comment"># 标记已走过</span><br>                 maze[nextNode[<span class="hljs-number">0</span>]][nextNode[<span class="hljs-number">1</span>]] = <span class="hljs-number">2</span><br><br>    <span class="hljs-comment"># 队空还未到终点</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没有路径&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure>



<p>4.链表</p>
<p>创建链表：</p>
<p>（1）头插法    （2）尾插法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, item</span>):</span><br>        self.item = item<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_linklist_head</span>(<span class="hljs-params">data</span>):</span><br>    head = Node(data[<span class="hljs-number">0</span>])	<span class="hljs-comment"># 创建第一个节点，并指向head</span><br>    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> data[<span class="hljs-number">1</span>:]:<br>        node = Node(element)<br>        <span class="hljs-comment"># 在头部添加节点</span><br>        node.<span class="hljs-built_in">next</span> = head	<br>        head = node	<br>    <span class="hljs-keyword">return</span> head<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_linklist_tail</span>(<span class="hljs-params">data</span>):</span><br>    head = Node(data[<span class="hljs-number">0</span>])	<span class="hljs-comment"># 创建第一个节点，维护两个指针：head、tail都指向它</span><br>    tail = head<br>    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> data[<span class="hljs-number">1</span>:]:<br>        node = Node(element)<br>        <span class="hljs-comment"># 在尾部添加节点</span><br>        tail.<span class="hljs-built_in">next</span> = node<br>        tail = node<br></code></pre></td></tr></table></figure>

<p>链表遍历：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_linklist</span>(<span class="hljs-params">lk</span>):</span><br>    <span class="hljs-keyword">while</span> lk:	<span class="hljs-comment"># 循环，当链表不空</span><br>        <span class="hljs-built_in">print</span>(lk.item)<br>        lk = lk.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure>

<p>链表插入：</p>
<p>列表的插入，时间复杂度<code>O(n)</code></p>
<p>链表的插入，<code>O(1)</code></p>
<img src="/images/image-20210822153544767.png" srcset="/img/loading.gif" lazyload alt="image-20210822153544767" style="zoom:67%;">

<p>链表删除：</p>
<img src="/images/image-20210822153634040.png" srcset="/img/loading.gif" lazyload alt="image-20210822153634040" style="zoom:67%;">



<p>双链表</p>
<img src="/images/image-20210822153815283.png" srcset="/img/loading.gif" lazyload alt="image-20210822153815283" style="zoom:80%;">

<p>双链表的插入、删除等。</p>
<p>5.哈希表</p>
<p>python的字典是通过哈希表实现。</p>
<img src="/images/image-20210822154411207.png" srcset="/img/loading.gif" lazyload alt="image-20210822154411207" style="zoom:67%;">

<p>在了解哈希表之前，先理解直接寻址表：</p>
<p>开一个表，将地址与key一一对应，没有值的地方不填，有值的地方就填，这样可以通过key直接定位到地址</p>
<img src="/images/image-20210822154842577.png" srcset="/img/loading.gif" lazyload alt="image-20210822154842577" style="zoom:80%;">



<p>在直接寻址的基础上，用一个哈希函数，得到哈希表：</p>
<p><code>哈希表 = 直接寻址表 + 哈希函数</code></p>
<img src="/images/image-20210822155046514.png" srcset="/img/loading.gif" lazyload alt="image-20210822155046514" style="zoom: 50%;">

<p>哈希冲突：</p>
<img src="/images/image-20210822155416687.png" srcset="/img/loading.gif" lazyload alt="image-20210822155416687" style="zoom: 50%;">



<p>（1）解决哈希冲突——开放寻址法</p>
<img src="/images/image-20210822155648727.png" srcset="/img/loading.gif" lazyload alt="image-20210822155648727" style="zoom:67%;">

<p>依次往后探查，直到有空位，就把元素放入；查找时，也遵循线性探查。</p>
<p>（2）解决哈希冲突——拉链法</p>
<p><img src="/images/image-20210822155900443.png" srcset="/img/loading.gif" lazyload alt="image-20210822155900443"></p>
<p>常见哈希函数：</p>
<img src="/images/image-20210822160146130.png" srcset="/img/loading.gif" lazyload alt="image-20210822160146130" style="zoom: 80%;">



<p>哈希表的应用：</p>
<p>（1）MD5算法</p>
<p><img src="/images/image-20210822161141184.png" srcset="/img/loading.gif" lazyload alt="image-20210822161141184"></p>
<p>MD5 (SHA-1) 已经被山东大学 王小云破解</p>
<p>（2）SHA-2算法</p>
<p>目前尚未被破解</p>
<p>（3）比特币</p>
<p><img src="/images/image-20210822161804851.png" srcset="/img/loading.gif" lazyload alt="image-20210822161804851"></p>
<p>没有反解哈希值的方法，所以只能暴力枚举，这个过程就是“挖矿”</p>
<p>6.树</p>
<p>（1）模拟Linux文件系统</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;dir&#x27;</span></span>):</span><br>        self.name = name<br>        self.<span class="hljs-built_in">type</span> = <span class="hljs-built_in">type</span><br>        self.children = []<br>        self.parent = <span class="hljs-literal">None</span><br><span class="hljs-comment"># 略</span><br></code></pre></td></tr></table></figure>

<p>（2）最常用的树——二叉树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BiTreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, data</span>):</span><br>        self.data = data<br>        self.lchild = <span class="hljs-literal">None</span><br>        self.rchild = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure>

<p><strong>重要知识点——二叉树的遍历：4种方式（面试常问）</strong></p>
<img src="/images/image-20210822171454500.png" srcset="/img/loading.gif" lazyload alt="image-20210822171454500" style="zoom:67%;">

<p>递归实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 前序遍历：根-左子树-右子树</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pre_order</span>(<span class="hljs-params">root</span>):</span><br>    <span class="hljs-keyword">if</span> root:<br>        <span class="hljs-built_in">print</span>(root.data)	<span class="hljs-comment"># 打印根节点</span><br>        pre_order(root.lchild)		<span class="hljs-comment"># 遍历左子树</span><br>        pre_order(root.rchild)		<span class="hljs-comment"># 遍历右子树</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 中序遍历：左子树-根-右子树</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">in_order</span>(<span class="hljs-params">root</span>):</span><br>    <span class="hljs-keyword">if</span> root:<br>        pre_order(root.lchild)<br>        <span class="hljs-built_in">print</span>(root.data)<br>        pre_order(root.rchild)<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 后序遍历：左-右-根</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post_order</span>(<span class="hljs-params">root</span>):</span><br>    <span class="hljs-keyword">if</span> root:<br>        post_order(root.lchild)<br>        post_order(root.rchild)<br>        <span class="hljs-built_in">print</span>(root.data)<br></code></pre></td></tr></table></figure>

<p><strong>层次遍历</strong>需要用到队列实现：</p>
<p>有点类似于<code>open、close</code>表的节点扩展过程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">level_order</span>(<span class="hljs-params">root</span>):</span><br>    q = deque()	<span class="hljs-comment"># 创建队列</span><br>    q.append(root)<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:	<span class="hljs-comment"># 只要队不空</span><br>        <span class="hljs-comment"># 队首出队，并访问其孩子(进队)</span><br>        node = q.popleft()<br>        <span class="hljs-built_in">print</span>(node.data)<br>        <span class="hljs-keyword">if</span> node.lchild:		<span class="hljs-comment"># 有左孩子</span><br>            q.append(node.lchild)<br>        <span class="hljs-keyword">if</span> node.rchild:<br>            q.append(node.rchild)      <br></code></pre></td></tr></table></figure>

<p>由遍历序列推导树的结构：只给一种遍历的结果，无法确定树的结构；必须至少给两种遍历方式的结果！</p>
<img src="/images/image-20210822172336003.png" srcset="/img/loading.gif" lazyload alt="image-20210822172336003" style="zoom: 67%;">



<p>（3）二叉树的应用——二叉搜索树<code>BST</code></p>
<img src="/images/image-20210822200013740.png" srcset="/img/loading.gif" lazyload alt="image-20210822200013740" style="zoom:67%;">

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BSTNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, data</span>):</span><br>        self.data = data<br>        self.lchild = <span class="hljs-literal">None</span><br>        self.rchild = <span class="hljs-literal">None</span><br>        self.parent = <span class="hljs-literal">None</span><br>        <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BST</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.root = <span class="hljs-literal">None</span><br>        <br>    <span class="hljs-comment"># 插入</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span>(<span class="hljs-params">self, node, val</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:	<span class="hljs-comment"># 如果node为空（递归停止），插进去</span><br>            node = BSTNode(val)<br>        <span class="hljs-keyword">elif</span> val &lt; node.data:<br>            node.lchild = self.insert(node.lchild, val)	<span class="hljs-comment"># 往左插</span><br>            node.lchild.parent = node<br>        <span class="hljs-keyword">elif</span> val &gt; node.data:<br>            node.rchild = self.insert(node.rchild, val)	<span class="hljs-comment"># 往右插</span><br>            node.rchild.parent = node<br>        <span class="hljs-keyword">return</span> node	<span class="hljs-comment"># 最后一层递归将新插入的node返回</span><br>    <br>    <span class="hljs-comment"># 插入——非递归</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_no_rec</span>(<span class="hljs-params">self, val</span>):</span><br>        p = self.root<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p:	<span class="hljs-comment"># 根节点为空，直接插在根节点</span><br>            self.root = BSTNode(val)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span> val &lt; p.data:<br>                <span class="hljs-keyword">if</span> p.lchild:	<span class="hljs-comment"># 左子树存在</span><br>                    p = p.lchild 	<span class="hljs-comment"># 往左子树走一步</span><br>                <span class="hljs-keyword">else</span>：<br>                	p.lchild = BSTNode(val)	<span class="hljs-comment"># 插在这</span><br>                    p.lchild.parent = p<br>                    <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">elif</span> val &gt; p.data:<br>                <span class="hljs-keyword">if</span> p.rchild:<br>                    p = p.rchild<br>                <span class="hljs-keyword">else</span>:<br>                    p.rchild = BSTNode(val)<br>                    p.rchild.parent = p<br>                    <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>

<p>对于 二叉搜索树的中序遍历，是有序的序列！</p>
<p>以下的方法都属于<code>BST</code>类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查询</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">query</span>(<span class="hljs-params">self, node, val</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> node.data &gt; val:<br>        <span class="hljs-keyword">return</span> self.query(node.lchild, val)<br>    <span class="hljs-keyword">elif</span> node.data &lt; val:<br>        <span class="hljs-keyword">return</span> self.query(node.rchild, val)<br>    <span class="hljs-keyword">else</span>:	<span class="hljs-comment"># 相等，找到了</span><br>        <span class="hljs-keyword">return</span> node<br>    <br><span class="hljs-comment"># 查询——非递归</span><br><span class="hljs-comment"># 略</span><br></code></pre></td></tr></table></figure>

<p>BST节点的删除，由于删除后要填补上这个节点，所以分情况：</p>
<img src="/images/image-20210822220735007.png" srcset="/img/loading.gif" lazyload alt="image-20210822220735007" style="zoom:67%;">

<img src="/images/image-20210822220205908.png" srcset="/img/loading.gif" lazyload alt="image-20210822220205908" style="zoom: 67%;">

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 情况1：node是叶子节点，直接删</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__remove_node_1</span>(<span class="hljs-params">self, node</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.parent:	<span class="hljs-comment"># 根节点</span><br>        self.root = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> node == node.parent.lchild:<br>        node.parent.lchild = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">else</span>:<br>        node.parent.rchild = <span class="hljs-literal">None</span><br>        <br><span class="hljs-comment"># 情况2：node只有一个孩子        </span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__remove_node_2l</span>(<span class="hljs-params">self, node</span>):</span>	<span class="hljs-comment"># 只有一个左孩子</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.parent:<br>        self.root = node.lchild<br>        node.lchild.parent = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">elif</span> node == node.parent.lchild:<br>        node.parent.lchild = node.lchild	<span class="hljs-comment"># 将node父亲和node的左孩子相连</span><br>        node.lchild.parent = node.parent<br>    <span class="hljs-keyword">else</span>:<br>        node.parent.rchild = node.lchild<br>        node.lchild.parent = node.parent<br>        <br><span class="hljs-comment"># 情况2：node只有一个孩子        </span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__remove_node_2r</span>(<span class="hljs-params">self, node</span>):</span>	<span class="hljs-comment"># 只有一个右孩子</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.parent:<br>        self.root = node.lchild<br>        node.rchild.parent = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">elif</span> node == node.parent.lchild:<br>        node.parent.lchild = node.rchild	<span class="hljs-comment"># 将node父亲和node的右孩子相连</span><br>        node.lchild.parent = node.parent<br>    <span class="hljs-keyword">else</span>:<br>        node.parent.rchild = node.rchild<br>        node.lchild.parent = node.parent <br>        <br><span class="hljs-comment"># 情况3：node有两个孩子，用到上面的函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">self, val</span>):</span><br>    <span class="hljs-keyword">if</span> self.root:		<span class="hljs-comment"># 不是空树才操作</span><br>        node = self.query_no_rec(val)		<span class="hljs-comment"># 先通过val找到要删除的node</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>	<span class="hljs-comment"># raise xx error</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.lchild <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.rchild:		<span class="hljs-comment"># 叶子节点</span><br>            self.__remove_node_1(node)<br>        <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> node.rchild:	<span class="hljs-comment"># 只有左孩子</span><br>            self._remove_node_2l(node)<br>        <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> node.lchild:	<span class="hljs-comment"># 只有右孩子</span><br>            self._remove_node_2r(node)<br>            <br>        <span class="hljs-comment"># 情况3：两个孩子</span><br>        <span class="hljs-keyword">else</span>:<br>            min_node = node.rchild		<span class="hljs-comment"># 找右子树的最小节点：一直找左子树</span><br>            <span class="hljs-keyword">while</span> min_node.lchild:		<span class="hljs-comment"># 当左不为空时</span><br>                min_node = min_node.lchild	<span class="hljs-comment"># 一直往左走</span><br>            node.data = min_node.data<br>            <span class="hljs-comment"># 删除min_node</span><br>            <span class="hljs-keyword">if</span> min_node.rchild:		<span class="hljs-comment"># min_node一定没有左子树了，只剩2种可能</span><br>                self.__remove_node_2r(min_node)<br>            <span class="hljs-keyword">else</span>:<br>                self.__remove_node_1(min_node)<br></code></pre></td></tr></table></figure>

<p>二叉搜索树的效率：</p>
<img src="/images/image-20210823170315829.png" srcset="/img/loading.gif" lazyload alt="image-20210823170315829" style="zoom: 67%;">



<p>（4）二叉搜索树的改进——AVL树</p>
<p>AVL树是一棵自平衡的二叉搜索树；</p>
<p>平衡：任何节点的左右子树高度差不超过1！</p>
<p>AVL树的维护：旋转操作</p>
<p><img src="/images/image-20210823171032911.png" srcset="/img/loading.gif" lazyload alt="image-20210823171032911"></p>
<p>1.不平衡由对于K的右孩子的右子树插入导致：左旋</p>
<p><img src="/images/image-20210823171135402.png" srcset="/img/loading.gif" lazyload alt="image-20210823171135402" style="zoom:50%;"><img src="/images/image-20210823171303056.png" srcset="/img/loading.gif" lazyload alt="image-20210823171303056" style="zoom:50%;"></p>
<p>2.不平衡由对于K的左孩子的左子树插入导致：右旋</p>
<img src="/images/image-20210823171415381.png" srcset="/img/loading.gif" lazyload alt="image-20210823171415381" style="zoom: 50%;">

<p>3.由右孩子的左子树插入导致：先右旋-再左旋</p>
<img src="/images/image-20210823171507631.png" srcset="/img/loading.gif" lazyload alt="image-20210823171507631" style="zoom: 67%;">

<p>4.左右：左右</p>
<p>AVL旋转的实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 同样，节点类、树类要分别实现</span><br><span class="hljs-comment"># 由于AVL是平衡的二叉搜索树，所以直接继承</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVLNode</span>(<span class="hljs-params">BSTNode</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span> (<span class="hljs-params">self, data</span>):</span><br>        BSTNode.__init__(self, data)<br>        self.bf = <span class="hljs-number">0</span>		<span class="hljs-comment"># balence factor: 本节点左右子树的高度差</span><br>        <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVLTree</span>(<span class="hljs-params">BST</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, li=<span class="hljs-literal">None</span></span>):</span><br>        BST.__init__(self, li)<br>        <br>    <span class="hljs-comment"># 左旋    </span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotate_left</span>(<span class="hljs-params">self, p, c</span>):</span><br>        s2 = c.lchild<br>        p.rchild = s2<br>        <span class="hljs-keyword">if</span> s2:<br>            s2.parent = p<br>        c.lchild = p<br>        p.parent = c<br>        p.bf = <span class="hljs-number">0</span><br>        c.bf = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 右旋    </span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotate_right</span>(<span class="hljs-params">self, p, c</span>):</span><br>        s2 = c.rchild<br>        p.lchild = s2<br>        <span class="hljs-keyword">if</span> s2:<br>            s2.parent = p<br>        c.rchild = p<br>        p.parent = c<br>        p.bf = <span class="hljs-number">0</span><br>        c.bf = <span class="hljs-number">0</span><br>        <br>    <span class="hljs-comment"># 右旋-左旋    </span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotate_right_left</span>(<span class="hljs-params">self, p, c</span>):</span><br>        <span class="hljs-comment"># 以整体结果为过程写代码</span><br>        <span class="hljs-comment"># 不是简单的左右旋叠加</span><br>        g = c.lchild<br>        s3 = g.rchild<br>        c.lchild = s3<br>        <span class="hljs-keyword">if</span> s3:<br>            s3.parent = c<br>            <br>        g.rchild = c<br>        c.parent = g<br>        <br>        s2 = g.lchild<br>        p.rchild = s2<br>        <span class="hljs-keyword">if</span> s2:<br>            s2.parent = p<br>        <br>        g.rchild = p<br>        p.parent = g<br>        <br>        <span class="hljs-comment"># 更新bf</span><br>        <span class="hljs-comment"># 有2种插入可能：插g的左孩子，插g的右孩子</span><br>        <span class="hljs-comment"># 左：</span><br>        <span class="hljs-keyword">if</span> g.bf &lt; <span class="hljs-number">0</span>:<br>            p.bf = <span class="hljs-number">1</span><br>            c.bf = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> g.bf &gt; <span class="hljs-number">0</span>:<br>            p.bf = <span class="hljs-number">0</span><br>            c.bf = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            p.bf = <span class="hljs-number">0</span><br>            c.bf = <span class="hljs-number">0</span><br>            <br>    <span class="hljs-comment"># 左旋-右旋    </span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotate_left_right</span>(<span class="hljs-params">self, p, c</span>):</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_no_rec</span>(<span class="hljs-params">self, val</span>):</span><br>        <span class="hljs-comment"># 略</span><br></code></pre></td></tr></table></figure>

<p>插入的实现，应用上述四个旋转函数实现，过程比较复杂，不做记录；</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1uA411N7c5?p=78">清华大学博士讲解Python数据结构与算法（完整版）全套100节_哔哩哔哩_bilibili</a></p>
<h2 id="算法进阶"><a href="#算法进阶" class="headerlink" title="算法进阶"></a>算法进阶</h2><p>优化算法：</p>
<h3 id="一、贪心算法"><a href="#一、贪心算法" class="headerlink" title="一、贪心算法"></a>一、贪心算法</h3><img src="/images/image-20210824100743228.png" srcset="/img/loading.gif" lazyload alt="image-20210824100743228" style="zoom: 67%;">



<p>1.背包问题</p>
<img src="/images/image-20210824101106201.png" srcset="/img/loading.gif" lazyload alt="image-20210824101106201" style="zoom: 80%;">

<p>0-1背包：要么全拿，要么不拿；  分数背包：可以只拿一部分</p>
<p>贪心算法是分数背包的最优解！</p>
<p>分数背包的实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">goods = [(<span class="hljs-number">60</span>,<span class="hljs-number">10</span>), (<span class="hljs-number">100</span>,<span class="hljs-number">20</span>), (<span class="hljs-number">120</span>,<span class="hljs-number">30</span>)]	<span class="hljs-comment"># 商品(价值，重量)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fenshu_backpack</span>(<span class="hljs-params">goods, w</span>):</span>	<span class="hljs-comment"># w:背包容量</span><br>    goods.sort(key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">0</span>]/x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)	<span class="hljs-comment"># 按单位价值降序排列</span><br>    <br>    m = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(goods))]	 <span class="hljs-comment"># 记录每种商品取的数量</span><br>    <span class="hljs-keyword">for</span> i,(prize, weight) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(goods):<br>        m[i] = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> w &gt;= weight <span class="hljs-keyword">else</span> w / weight<br>        <br>        <span class="hljs-comment"># 略</span><br></code></pre></td></tr></table></figure>

<p>2.拼接最大数字问题：</p>
<img src="/images/image-20210824103922481.png" srcset="/img/loading.gif" lazyload alt="image-20210824103922481" style="zoom:80%;">

<p>整体使用贪心算法啊，但有一点需要考虑：</p>
<p><img src="/images/image-20210824104229156.png" srcset="/img/loading.gif" lazyload alt="image-20210824104229156"></p>
<p>当出现128、1286时怎么拼接？</p>
<p>这种情况可以归类为“两数不等长，且短的是长的数的子集”，此时应该<strong>先合并再比较</strong>！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> cmp_to_key	<span class="hljs-comment"># 传python2的cmp函数，转换为python3的key函数</span><br><br>data = [<span class="hljs-number">32</span>,<span class="hljs-number">94</span>,<span class="hljs-number">128</span>,<span class="hljs-number">1286</span>,<span class="hljs-number">6</span>,<span class="hljs-number">71</span>]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">xy_cmp</span>(<span class="hljs-params">x, y</span>):</span><br>    <span class="hljs-keyword">if</span> x+y &lt; y+x:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> x+y &gt; y+x:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">number_concat</span>(<span class="hljs-params">data</span>):</span><br>    data = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, data)) 	<span class="hljs-comment"># 所有元素转为字符串，构造一个新的list</span><br>    <span class="hljs-comment"># 排序：</span><br>    <span class="hljs-comment"># 通过交换列表中的元素：</span><br>    <span class="hljs-comment"># 如果 x+y &lt; y+x，则交换</span><br>    <span class="hljs-comment"># data.sort(cmp=lambda x,y:x+y,y+x)	# python2的写法，比较x、y两数</span><br>    data.sort(key=cmp_to_key(xy_cmp))	<br>    <br>    <span class="hljs-comment">#注：这里的排序必须使用cmp策略，即根据x+y和y+x来交换元素。否则会把位数多的排前面，达不到目的</span><br></code></pre></td></tr></table></figure>

<p>3.活动选择问题</p>
<img src="/images/image-20210824105505070.png" srcset="/img/loading.gif" lazyload alt="image-20210824105505070" style="zoom: 67%;">

<p><img src="/images/image-20210824110011973.png" srcset="/img/loading.gif" lazyload alt="image-20210824110011973"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">activities = [(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>), (<span class="hljs-number">3</span>,<span class="hljs-number">5</span>), (<span class="hljs-number">0</span>,<span class="hljs-number">6</span>)]<br><span class="hljs-comment"># 活动按照结束实践排序</span><br>activities.sort(key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>])<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">activity_selection</span>(<span class="hljs-params">data</span>):</span><br>    res = [a[<span class="hljs-number">0</span>]]	<span class="hljs-comment"># 结束最早的一定在答案里</span><br>    <br>    <span class="hljs-comment"># 再依次往后看，只要开始时间不冲突，就可以加到答案里</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(data)):<br>        <span class="hljs-keyword">if</span> data[i][<span class="hljs-number">0</span>] &gt;= res[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]:	 <span class="hljs-comment"># 不冲突</span><br>            res.append(a[i])<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>



<p>贪心算法总结：</p>
<p>难点在于：意识到一个问题应用贪心算法解决；  代码部分并不难</p>
<h3 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h3><p>To be continued.</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Data-Structures-and-Algorithms/">Data Structures and Algorithms</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/26/%E5%A6%82%E4%BD%95clone%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%B9%B6%E5%9C%A8Pycharm%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0/">
                        <span class="hidden-mobile">如何clone开源项目并在Pycharm提交更新</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
