

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/Tan.png">
  <link rel="icon" href="/img/Tan.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="项目二：目标检测算法中的anchor、NMS和FPN">
  <meta name="author" content="Eric Tan">
  <meta name="keywords" content="">
  
  <title>Pytorch_Related（三） - Eric Tan</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 80vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Eric Tan</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archives
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Categories
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tags
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/curry2.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Pytorch_Related（三）">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-08-15 22:17" pubdate>
        August 15, 2021 pm
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.2k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      59
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="iconfont icon-arrowdown"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Pytorch_Related（三）</h1>
            
            <div class="markdown-body">
              <h2 id="项目二：目标检测算法中的anchor、NMS和FPN"><a href="#项目二：目标检测算法中的anchor、NMS和FPN" class="headerlink" title="项目二：目标检测算法中的anchor、NMS和FPN"></a>项目二：目标检测算法中的anchor、NMS和FPN</h2><span id="more"></span>

<h3 id="一、anchor"><a href="#一、anchor" class="headerlink" title="一、anchor"></a>一、anchor</h3><p>1.由预定义的大小scale和高宽比ratio生成的一组anchor box，选定好scale和ratio之后，通过滑动窗口的方式将这些anchor铺满整个图片，具体方式为对于目标图片（一般指经过conv后的feature map），图中的每个点都要对应一组anchor，即在feature map上逐点滑窗，以这些点为中心生成anchor box。</p>
<p>有了这些anchor box后，模型不是直接去回归坐标框位置，而是以anchor box为基准，回归GT框和anchor box之间的<strong>平移和缩放值</strong>。</p>
<p>2.参数：</p>
<p>base_size：基础大小</p>
<p>anchor_scale：在base_size的基础上，调整anchor的大小</p>
<p>anchor_ratio：用以生成各种长宽比例的长方形anchor</p>
<p>3.主要计算公式：</p>
<img src="/.com//blog\source\images\image-20210805165454366.png" srcset="/img/loading.gif" lazyload alt="image-20210805165454366" style="zoom: 50%;">

<p>4.代码</p>
<p>获取anchor box的实质，就是获取anchor box的四维坐标：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 定义anchor生成器类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnchorGenerator</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, base_size, scales, ratios, ctr=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-comment"># base_size 是anchor的基本大小</span><br>        <span class="hljs-comment"># scales 是anchor缩放的比例，我们可以在基础大小上给定倍数来缩放anchor从而生成更多anchor</span><br>        <span class="hljs-comment"># ratios 指的是anchor的高宽变化比例</span><br>        <span class="hljs-comment"># ctr 为anchor中心点坐标，默认为None，通过anchor大小来自动计算中心点</span><br>        self.base_size = base_size<br>        self.scales = torch.Tensor(scales)<br>        self.ratios = torch.Tensor(ratios)<br>        self.ctr = ctr<br>        self.base_anchors = self.gen_base_anchors()<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">num_base_anchors</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.base_anchors.size(<span class="hljs-number">0</span>)<br>	 <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_base_anchors</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 用于生成基础anchor，这些基础anchor将会滑动窗口形式铺满图片</span><br>        <span class="hljs-comment"># 基础anchor的宽和高</span><br>        w = self.base_size<br>        h = self.base_size<br>        <span class="hljs-comment"># 计算基础anchor的中心坐标（左上角为0，0点）</span><br>        <span class="hljs-keyword">if</span> self.ctr <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            x_ctr = <span class="hljs-number">0.5</span> * (w - <span class="hljs-number">1</span>)<br>            y_ctr = <span class="hljs-number">0.5</span> * (h - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            x_ctr, y_ctr = self.ctr<br>        <span class="hljs-comment"># 计算高宽比例并将基础anchor乘上这一比例</span><br>        h_ratios = torch.sqrt(self.ratios)<br>        w_ratios = <span class="hljs-number">1</span> / h_ratios<br><br>        ws = (w * w_ratios[:, <span class="hljs-literal">None</span>] * self.scales[<span class="hljs-literal">None</span>, :]).view(-<span class="hljs-number">1</span>)<br>        hs = (h * h_ratios[:, <span class="hljs-literal">None</span>] * self.scales[<span class="hljs-literal">None</span>, :]).view(-<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 使用之前计算的anchor中心坐标和最终的高度和宽度计算得到最终的base anchor, 为了保证坐标是整数，最后使用round取整</span><br>        base_anchors = torch.stack(<br>            [<br>                x_ctr - <span class="hljs-number">0.5</span> * (ws - <span class="hljs-number">1</span>), y_ctr - <span class="hljs-number">0.5</span> * (hs - <span class="hljs-number">1</span>),<br>                x_ctr + <span class="hljs-number">0.5</span> * (ws - <span class="hljs-number">1</span>), y_ctr + <span class="hljs-number">0.5</span> * (hs - <span class="hljs-number">1</span>)<br>            ],<br>            dim=-<span class="hljs-number">1</span>).<span class="hljs-built_in">round</span>()<br><br>        <span class="hljs-keyword">return</span> base_anchors<br>    <br>    <span class="hljs-comment"># 猜测：_meshgird作用应该是搭配后面的grid_anchors完成“滑动窗口”，逐点产生anchor组</span><br>	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_meshgrid</span>(<span class="hljs-params">self, x, y, row_major=<span class="hljs-literal">True</span></span>):</span><br>        xx = x.repeat(<span class="hljs-built_in">len</span>(y))<br>        yy = y.view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>).repeat(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(x)).view(-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> row_major:<br>            <span class="hljs-keyword">return</span> xx, yy<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> yy, xx<br>	<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grid_anchors</span>(<span class="hljs-params">self, featmap_size, device=<span class="hljs-string">&#x27;cpu&#x27;</span></span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;device: cuda or cpu&#x27;&#x27;&#x27;</span><br>        <span class="hljs-comment"># 首先生成base anchor </span><br>        base_anchors = self.base_anchors.to(device)<br>        <span class="hljs-comment"># 然后使用当前anchor要覆盖图片的大小来给定所有需要滑窗铺设anchor的点的位置（其实就是这个图的所有点）</span><br>        feat_h, feat_w = featmap_size<br>        shift_x = torch.arange(<span class="hljs-number">0</span>, feat_w, device=device)<br>        shift_y = torch.arange(<span class="hljs-number">0</span>, feat_h, device=device)<br>        <span class="hljs-comment"># 生成滑动窗口的x和y坐标</span><br>        shift_xx, shift_yy = self._meshgrid(shift_x, shift_y)<br>        shifts = torch.stack([shift_xx, shift_yy, shift_xx, shift_yy], dim=-<span class="hljs-number">1</span>)<br>        shifts = shifts.type_as(base_anchors)<br>        <span class="hljs-comment"># 将based anchor 沿着x，y坐标平移滑窗，将anchor铺满图片</span><br>        all_anchors = base_anchors[<span class="hljs-literal">None</span>, :, :] + shifts[:, <span class="hljs-literal">None</span>, :]<br>        all_anchors = all_anchors.view(-<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br>        <span class="hljs-keyword">return</span> all_anchors<br></code></pre></td></tr></table></figure>

<p>调用方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># base大小为9，缩放倍数为1，ratio为[0.5,1,2.0]</span><br>ag = AnchorGenerator(<span class="hljs-number">9</span>, [<span class="hljs-number">1.</span>], [<span class="hljs-number">0.5</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">2.0</span>])<br>all_anchors = ag.grid_anchors((<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))   <span class="hljs-comment"># 假定feature map大小为1*1，测试看看结果</span><br><span class="hljs-built_in">print</span>(all_anchors)<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor([[-<span class="hljs-number">2.</span>,  <span class="hljs-number">1.</span>, <span class="hljs-number">10.</span>,  <span class="hljs-number">7.</span>],<br>        [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">8.</span>,  <span class="hljs-number">8.</span>],<br>        [ <span class="hljs-number">1.</span>, -<span class="hljs-number">2.</span>,  <span class="hljs-number">7.</span>, <span class="hljs-number">10.</span>]])<br></code></pre></td></tr></table></figure>



<h3 id="二、anchor-box与GT-box匹配"><a href="#二、anchor-box与GT-box匹配" class="headerlink" title="二、anchor box与GT box匹配"></a>二、anchor box与GT box匹配</h3><p>根据IoU 直接为GT box分配anchor box</p>
<p>上一步生成了非常多的预设anchor，接下来需要给每个GT bbox 匹配一个对应的anchor，这样这个GT 框就是以这个anchor为基准来检测。<br>常用的匹配策略叫做max iou assign，也就是依据anchor box和gt box之间的IoU值来匹配，每个GT 选择与其IoU值大于一定阈值中最大的那个anchor来匹配，<br>一般分为以下几个步骤：</p>
<p>（1）计算所有anchor和gt框的iou值<br>（2）如果一个<strong>anchor和所有gt的iou值都小于阈值neg_iou_thr</strong>，也就是说这个anchor没有覆盖到任何的gt框，那么就将这个anchor标记为负样本（neg_iou_thr一般取0.3）<br>（3）对于每一个anchor，先找到<strong>与它iou最大的gt框</strong>，如果他们的<strong>iou大于pos_iou_thr阈值</strong>（一般取0.7或者0.5），那么就将这个gt和这个anchor匹配<br>（4）对于所有的gt框，将它与和<strong>它iou值最大的anchor匹配</strong>（这一步是为了解决上一步中可能存在部分gt框没有anchor匹配的问题）</p>
<p>这样每个gt框都匹配上了一个或者多个anchor</p>
<p><strong>1.计算两组bbox之间的overlap或iou值</strong></p>
<p>先上代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bbox_overlaps</span>(<span class="hljs-params">bboxes1, bboxes2, mode=<span class="hljs-string">&#x27;iou&#x27;</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;计算输入的两组bboxes之间的overlap值.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    rows = bboxes1.size(<span class="hljs-number">0</span>) <span class="hljs-comment"># bboxes1中box的个数</span><br>    cols = bboxes2.size(<span class="hljs-number">0</span>) <span class="hljs-comment"># bboxes2中box的个数</span><br><br>    <span class="hljs-keyword">if</span> rows * cols == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> bboxes1.new(rows, cols)<br><br>    lt = torch.<span class="hljs-built_in">max</span>(bboxes1[:, <span class="hljs-literal">None</span>, :<span class="hljs-number">2</span>], bboxes2[:, :<span class="hljs-number">2</span>])  <span class="hljs-comment"># [rows, cols, 2]</span><br>    rb = torch.<span class="hljs-built_in">min</span>(bboxes1[:, <span class="hljs-literal">None</span>, <span class="hljs-number">2</span>:], bboxes2[:, <span class="hljs-number">2</span>:])  <span class="hljs-comment"># [rows, cols, 2]</span><br><br>    wh = (rb - lt + <span class="hljs-number">1</span>).clamp(<span class="hljs-built_in">min</span>=<span class="hljs-number">0</span>)  <span class="hljs-comment"># [rows, cols, 2]</span><br>    overlap = wh[:, :, <span class="hljs-number">0</span>] * wh[:, :, <span class="hljs-number">1</span>]<br>    area1 = (bboxes1[:, <span class="hljs-number">2</span>] - bboxes1[:, <span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) * (bboxes1[:, <span class="hljs-number">3</span>] - bboxes1[:, <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">if</span> mode == <span class="hljs-string">&#x27;iou&#x27;</span>:<br>        area2 = (bboxes2[:, <span class="hljs-number">2</span>] - bboxes2[:, <span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) * (bboxes2[:, <span class="hljs-number">3</span>] - bboxes2[:, <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)<br>        ious = overlap / (area1[:, <span class="hljs-literal">None</span>] + area2 - overlap)<br>    <span class="hljs-keyword">else</span>:<br>        ious = overlap / (area1[:, <span class="hljs-literal">None</span>])<br><br>    <span class="hljs-keyword">return</span> ious<br></code></pre></td></tr></table></figure>

<p>使用举例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># bbox的顺序为[xmin,ymin,xmax,ymax]</span><br>bboxes1 = torch.FloatTensor([<br>            [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>],<br>            [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>],<br>            [<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">38</span>, <span class="hljs-number">42</span>],<br>            ])<br>bboxes2 = torch.FloatTensor([<br>            [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>],<br>            [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">19</span>],<br>            [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>],<br>            ])<br>ious = bbox_overlaps(bboxes1, bboxes2)<br><span class="hljs-built_in">print</span>(ious)<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor([[<span class="hljs-number">0.5238</span>, <span class="hljs-number">0.0500</span>, <span class="hljs-number">0.0041</span>],<br>        [<span class="hljs-number">0.0323</span>, <span class="hljs-number">0.0452</span>, <span class="hljs-number">1.0000</span>],<br>        [<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0000</span>]])<br></code></pre></td></tr></table></figure>



<p>（1）<code>torch.max()</code>有多个版本！！！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">input</span>,dim,keepdim=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># dim=0列取最大，dim=1行取最大</span><br><br>torch.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">input</span>,other,out=<span class="hljs-literal">None</span>)  <span class="hljs-comment"># input和other都是tensor，实现逐元素比较两个tensor，输出最大值</span><br>							  <span class="hljs-comment"># 两个tensor维度不一定一致，但必须满足“可广播”</span><br>    						  <span class="hljs-comment"># 输出的维度就是广播后的维度</span><br></code></pre></td></tr></table></figure>

<p>（2）切片中的<code>None</code>:</p>
<p>经常见<code>a[:, None, :4]</code>的语句，切片中的None实际上是numpy中newaxis的别名，也即<strong>增加维度</strong>！</p>
<p>实验结果：</p>
<p><img src="/.com//blog\source\images\image-20210806091544126.png" srcset="/img/loading.gif" lazyload alt="image-20210806091544126"></p>
<p>也即：None增加了维度，结果为1</p>
<p>（3）pytorch中的广播机制：</p>
<p>如果满足以下规则，则两个张量是“可广播的”：<br>１、每个张量具有至少一个维度。<br>２、从尾随尺寸开始迭代尺寸时，尺寸<strong>要么相等</strong>，<strong>要么其中之一为1</strong>，<strong>或者不存在其中之一</strong>。（从<strong>尾部开始比较</strong>！）</p>
<p>符合广播条件的，按照下面方式广播：</p>
<p>１、如果x和y的维度不相同，<strong>用１来扩张维度少的那个</strong>，使两个张量维度一致。<br>２、对于每个维度，<strong>结果维度是x,y对应维度的最大值</strong>。</p>
<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x=torch.empty(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>y=torch.empty(  <span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>(x+y).size()<br>torch.Size([<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure>

<p>再举一个：</p>
<img src="/.com//blog\source\images\image-20210806091954070.png" srcset="/img/loading.gif" lazyload alt="image-20210806091954070" style="zoom: 50%;">

<p>(4) 计算iou代码的整体思路：</p>
<img src="/.com//blog\source\images\image-20210806104239858.png" srcset="/img/loading.gif" lazyload alt="image-20210806104239858" style="zoom: 50%;">



<p><strong>2.anchor box与GT box匹配</strong></p>
<p>先上代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># anchor与GT匹配的类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxIoUAssigner</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    每个候选框会被打上一个标签：`-1`, `0`, `1`</span><br><span class="hljs-string"></span><br><span class="hljs-string">    - -1: 忽略</span><br><span class="hljs-string">    - 0: 负样本，表示这个anchor没有和任何gt box匹配成功，代表背景</span><br><span class="hljs-string">    - index: 正样本，值为所匹配的gt的label，从1开始</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        pos_iou_thr (float): 正样本iou阈值.</span><br><span class="hljs-string">        neg_iou_thr (float or tuple): 负样本iou阈值.</span><br><span class="hljs-string">        min_pos_iou (float): 最小正样本iou阈值，用于当GT没有anchor匹配时二次降低标准寻找合适的anchor，保证每个GT都有anchor匹配上</span><br><span class="hljs-string">        gt_max_assign_all (bool): 如果出现一个GT与多个anchor的iou相同且均为最大值，是否将这些anchor都和该GT匹配</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,</span></span><br><span class="hljs-function"><span class="hljs-params">                 pos_iou_thr,</span></span><br><span class="hljs-function"><span class="hljs-params">                 neg_iou_thr,</span></span><br><span class="hljs-function"><span class="hljs-params">                 min_pos_iou=<span class="hljs-number">.0</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 gt_max_assign_all=<span class="hljs-literal">True</span></span>):</span><br>        self.pos_iou_thr = pos_iou_thr<br>        self.neg_iou_thr = neg_iou_thr<br>        self.min_pos_iou = min_pos_iou<br>        self.gt_max_assign_all = gt_max_assign_all<br>        <br>	<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">assign</span>(<span class="hljs-params">self, bboxes, gt_bboxes, gt_labels=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;匹配gt框和anchor.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        匹配步骤按照如下进行：</span><br><span class="hljs-string"></span><br><span class="hljs-string">        1. 将所有的anchor都初始化为 -1</span><br><span class="hljs-string">        2. 如果anchor与所有GT的iou值 all gts &lt; neg_iou_thr， 就说明这个anchor不能喝任何GT匹配，标记为 0，负样本</span><br><span class="hljs-string">        3. 对每个anchor，如果与它与对应最大iou值的gt框的iou值大于pos_iou_thr,就把这个anchor匹配到这个框上，标记为对应的gt的lable，</span><br><span class="hljs-string">           属于正样本</span><br><span class="hljs-string">        4. 对于每个gt，将与其iou最大的所有anchor均与它匹配</span><br><span class="hljs-string"></span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        bboxes = bboxes[:, :<span class="hljs-number">4</span>]<br>        overlaps = bbox_overlaps(gt_bboxes, bboxes)<br><br>        assign_result = self.assign_wrt_overlaps(overlaps, gt_labels)<br>        <br>        <span class="hljs-keyword">return</span> assign_result<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">assign_wrt_overlaps</span>(<span class="hljs-params">self, overlaps, gt_labels=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;Assign w.r.t. the overlaps of bboxes with gts.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Args:</span><br><span class="hljs-string">            overlaps (Tensor): gt和anchor之间的overlaps</span><br><span class="hljs-string">            gt_labels (Tensor, optional): gtbox的类别label.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Returns:</span><br><span class="hljs-string">            :obj:`AssignResult`: The assign result.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        num_gts, num_bboxes = overlaps.size(<span class="hljs-number">0</span>), overlaps.size(<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 计算iou函数返回的overlaps，第一维是GT box个数，第二维是anchor box个数</span><br>		<span class="hljs-comment"># 这里分别把它们取出来        </span><br>        <br>		<span class="hljs-comment"># 1. 将所有的anchor都初始化为 -1</span><br>        assigned_gt_inds = overlaps.new_full((num_bboxes, ),<br>                                             -<span class="hljs-number">1</span>,<br>                                             dtype=torch.long)<br><br>        <span class="hljs-comment"># 对于每个anchor，找到与其iou最大的gt</span><br>        max_overlaps, argmax_overlaps = overlaps.<span class="hljs-built_in">max</span>(dim=<span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 对于每个gt，找到与其iou最大的anchor</span><br>        gt_max_overlaps, gt_argmax_overlaps = overlaps.<span class="hljs-built_in">max</span>(dim=<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 2. 如果anchor与所有GT的iou值 all gts &lt; neg_iou_thr， 就说明这个anchor不能喝任何GT匹配，标记为 0，负样本</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(self.neg_iou_thr, <span class="hljs-built_in">float</span>):<br>            assigned_gt_inds[(max_overlaps &gt;= <span class="hljs-number">0</span>)<br>                             &amp; (max_overlaps &lt; self.neg_iou_thr)] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(self.neg_iou_thr, <span class="hljs-built_in">tuple</span>):<br>            <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(self.neg_iou_thr) == <span class="hljs-number">2</span><br>            assigned_gt_inds[(max_overlaps &gt;= self.neg_iou_thr[<span class="hljs-number">0</span>])<br>                             &amp; (max_overlaps &lt; self.neg_iou_thr[<span class="hljs-number">1</span>])] = <span class="hljs-number">0</span><br> 	   <span class="hljs-comment"># 3. 对每个anchor，如果与它与对应最大iou值的gt框的iou值大于pos_iou_thr,就把这个anchor匹配到这个框上，标记为对应的gt的lable，</span><br>	   <span class="hljs-comment"># 属于正样本</span><br>        pos_inds = max_overlaps &gt;= self.pos_iou_thr<br>        assigned_gt_inds[pos_inds] = argmax_overlaps[pos_inds] + <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 4. 对于每个gt，将与其iou最大的所有anchor均与它匹配</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_gts):<br>            <span class="hljs-keyword">if</span> gt_max_overlaps[i] &gt;= self.min_pos_iou:<br>                <span class="hljs-keyword">if</span> self.gt_max_assign_all:<br>                    max_iou_inds = overlaps[i, :] == gt_max_overlaps[i]<br>                    assigned_gt_inds[max_iou_inds] = i + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    assigned_gt_inds[gt_argmax_overlaps[i]] = i + <span class="hljs-number">1</span><br>                <br>                <br>        <span class="hljs-keyword">if</span> gt_labels <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            assigned_labels = assigned_gt_inds.new_zeros((num_bboxes, ))<br>            pos_inds = torch.nonzero(assigned_gt_inds &gt; <span class="hljs-number">0</span>).squeeze()<br>            <span class="hljs-keyword">if</span> pos_inds.numel() &gt; <span class="hljs-number">0</span>:<br>                assigned_labels[pos_inds] = gt_labels[<br>                    assigned_gt_inds[pos_inds] - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>:<br>            assigned_labels = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># 返回值分别为： gt的数量，anchor匹配到gt的序号， anchor和所匹配gt的iou， anchor匹配到的label值</span><br>        <span class="hljs-keyword">return</span> num_gts, assigned_gt_inds, max_overlaps, assigned_labels<br><br></code></pre></td></tr></table></figure>

<p>匹配举例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">assigner = MaxIoUAssigner(<br>        pos_iou_thr=<span class="hljs-number">0.5</span>,<br>        neg_iou_thr=<span class="hljs-number">0.5</span>,<br>    )<br>anchors = torch.FloatTensor([<br>        [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>],<br>        [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>],<br>        [<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>],<br>        [<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">38</span>, <span class="hljs-number">42</span>],<br>    ])<br>gt_bboxes = torch.FloatTensor([<br>        [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>],<br>        [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">19</span>],<br>    ])<br>gt_labels = torch.LongTensor([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>assign_result = assigner.assign(anchors, gt_bboxes, gt_labels=gt_labels)<br>num_gts, assigned_gt_inds, max_overlaps, assigned_labels = assign_result<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;gt的数量： &quot;</span>, num_gts)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;anchor匹配到第几个gt： &quot;</span>, assigned_gt_inds)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;anchor匹配到gt的序号： &quot;</span>, max_overlaps)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;anchor匹配到的label值： &quot;</span>, assigned_labels)<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">gt的数量：  <span class="hljs-number">2</span><br>anchor匹配到第几个gt：  tensor([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>])<br>anchor匹配到gt的序号：  tensor([<span class="hljs-number">0.9091</span>, <span class="hljs-number">0.0452</span>, <span class="hljs-number">0.1846</span>, <span class="hljs-number">0.0000</span>])<br>anchor匹配到的label值：  tensor([<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure>



<h3 id="三、基于anchor-box的坐标编码和解码"><a href="#三、基于anchor-box的坐标编码和解码" class="headerlink" title="三、基于anchor box的坐标编码和解码"></a>三、基于anchor box的坐标编码和解码</h3><p>前面说过，anchor based的方法，基本都是对“GT和anchor之间的平移量、缩放量”进行回归修正，因此上一步完成GT和anchor的匹配之后，就要求解GT相对于anchor的平移、缩放量了，这一步又称为坐标编码。</p>
<p>定义：<br>$p_x$ 为achor的x轴中心点，$p_y$ 为anchor的y轴中心点, $p_w$ 为anchor的宽度，$p_h$ 为anchor的高<br>$g_x$ 为gt box的x轴中心点，$g_y$ 为gt box的y轴中心点, $g_w$ 为gt box的宽度，$g_h$ 为gt box的高<br>编码过程：<br><img src="/.com//blog\source\images\image-20210806152341948.png" srcset="/img/loading.gif" lazyload alt="image-20210806152341948"><br>其中$d_x$和$d_y$表示平移，$d_w$和$d_h$表示缩放</p>
<p>实现代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bbox2delta</span>(<span class="hljs-params">proposals, gt, means=[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], stds=[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]</span>):</span><br>    <span class="hljs-keyword">assert</span> proposals.size() == gt.size()<br><br>    proposals = proposals.<span class="hljs-built_in">float</span>()<br>    gt = gt.<span class="hljs-built_in">float</span>()<br>    <span class="hljs-comment"># 求出 anchor的中心点和高宽</span><br>    px = (proposals[..., <span class="hljs-number">0</span>] + proposals[..., <span class="hljs-number">2</span>]) * <span class="hljs-number">0.5</span><br>    py = (proposals[..., <span class="hljs-number">1</span>] + proposals[..., <span class="hljs-number">3</span>]) * <span class="hljs-number">0.5</span><br>    pw = proposals[..., <span class="hljs-number">2</span>] - proposals[..., <span class="hljs-number">0</span>] + <span class="hljs-number">1.0</span><br>    ph = proposals[..., <span class="hljs-number">3</span>] - proposals[..., <span class="hljs-number">1</span>] + <span class="hljs-number">1.0</span><br>    <span class="hljs-comment"># 求出gt的中心点和高宽</span><br>    gx = (gt[..., <span class="hljs-number">0</span>] + gt[..., <span class="hljs-number">2</span>]) * <span class="hljs-number">0.5</span><br>    gy = (gt[..., <span class="hljs-number">1</span>] + gt[..., <span class="hljs-number">3</span>]) * <span class="hljs-number">0.5</span><br>    gw = gt[..., <span class="hljs-number">2</span>] - gt[..., <span class="hljs-number">0</span>] + <span class="hljs-number">1.0</span><br>    gh = gt[..., <span class="hljs-number">3</span>] - gt[..., <span class="hljs-number">1</span>] + <span class="hljs-number">1.0</span><br>    <span class="hljs-comment"># 编码</span><br>    dx = (gx - px) / pw<br>    dy = (gy - py) / ph<br>    dw = torch.log(gw / pw)<br>    dh = torch.log(gh / ph)<br>    deltas = torch.stack([dx, dy, dw, dh], dim=-<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 用均值标准差来归一化</span><br>    means = deltas.new_tensor(means).unsqueeze(<span class="hljs-number">0</span>)<br>    stds = deltas.new_tensor(stds).unsqueeze(<span class="hljs-number">0</span>)<br>    deltas = deltas.sub_(means).div_(stds)<br><br>    <span class="hljs-keyword">return</span> deltas<br></code></pre></td></tr></table></figure>

<p>使用举例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">anchors = torch.Tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],<br>                      [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],<br>                      [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],<br>                      [ <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>]])<br>gt_bbox = torch.Tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">1.0000</span>,  <span class="hljs-number">1.0000</span>],<br>                        [ <span class="hljs-number">0.2817</span>,  <span class="hljs-number">0.2817</span>,  <span class="hljs-number">4.7183</span>,  <span class="hljs-number">4.7183</span>],<br>                        [-<span class="hljs-number">6.3891</span>,  <span class="hljs-number">0.6321</span>,  <span class="hljs-number">7.3891</span>,  <span class="hljs-number">0.3679</span>],<br>                        [ <span class="hljs-number">5.8967</span>,  <span class="hljs-number">2.9251</span>,  <span class="hljs-number">5.5033</span>,  <span class="hljs-number">3.2749</span>]])<br>deltas = bbox2delta(anchors, gt_bbox)<br><span class="hljs-built_in">print</span>(deltas)<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.0000</span>],<br>        [ <span class="hljs-number">1.0000</span>,  <span class="hljs-number">1.0000</span>,  <span class="hljs-number">1.0000</span>,  <span class="hljs-number">1.0000</span>],<br>        [ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">2.0000</span>, -<span class="hljs-number">0.9999</span>],<br>        [ <span class="hljs-number">0.7000</span>, -<span class="hljs-number">1.9000</span>, -<span class="hljs-number">0.4999</span>,  <span class="hljs-number">0.3000</span>]])<br></code></pre></td></tr></table></figure>



<p>2.经过上述编码，模型最终学习的结果就是编码的值，想要得到最终实际的坐标框，需要进行解码！</p>
<p>解码就是上述的逆过程：</p>
<p><img src="/.com//blog\source\images\image-20210806152649302.png" srcset="/img/loading.gif" lazyload alt="image-20210806152649302"></p>
<p>最终（x1，y1）为预测框左上角坐标，（x2，y2）为预测框右下角坐标。</p>
<p>实现代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delta2bbox</span>(<span class="hljs-params">rois,</span></span><br><span class="hljs-function"><span class="hljs-params">               deltas,</span></span><br><span class="hljs-function"><span class="hljs-params">               means=[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span></span><br><span class="hljs-function"><span class="hljs-params">               stds=[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],</span></span><br><span class="hljs-function"><span class="hljs-params">               max_shape=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">               wh_ratio_clip=<span class="hljs-number">16</span> / <span class="hljs-number">1000</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    对bbox进行解码，使用delta 从rois解码回bbox</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        rois (Tensor): anchor box或者proposal坐标</span><br><span class="hljs-string">        deltas (Tensor): 编码后的结果，即相对每个roi的平移和缩放量</span><br><span class="hljs-string">        means (list): delta 的均值，用于反标准化</span><br><span class="hljs-string">        stds (list): delta 的标准差，用于反标准化</span><br><span class="hljs-string">        max_shape (tuple[int, int]): 解码后bbox 的最大尺度</span><br><span class="hljs-string">        wh_ratio_clip (float): 解码后bbbox的最大高宽比</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Returns:</span><br><span class="hljs-string">        Tensor: 返回值为bbox的坐标，每一行是一个框，格式为 [tl_x, tl_y, br_x, br_y],即左上角点坐标和右下角点坐标</span><br><span class="hljs-string"></span><br><span class="hljs-string">    References:</span><br><span class="hljs-string">        .. [1] https://arxiv.org/abs/1311.2524</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    means = deltas.new_tensor(means).repeat(<span class="hljs-number">1</span>, deltas.size(<span class="hljs-number">1</span>) // <span class="hljs-number">4</span>)<br>    stds = deltas.new_tensor(stds).repeat(<span class="hljs-number">1</span>, deltas.size(<span class="hljs-number">1</span>) // <span class="hljs-number">4</span>)<br>    denorm_deltas = deltas * stds + means<br>    dx = denorm_deltas[:, <span class="hljs-number">0</span>::<span class="hljs-number">4</span>]<br>    dy = denorm_deltas[:, <span class="hljs-number">1</span>::<span class="hljs-number">4</span>]<br>    dw = denorm_deltas[:, <span class="hljs-number">2</span>::<span class="hljs-number">4</span>]<br>    dh = denorm_deltas[:, <span class="hljs-number">3</span>::<span class="hljs-number">4</span>]<br>    max_ratio = np.<span class="hljs-built_in">abs</span>(np.log(wh_ratio_clip))<br>    dw = dw.clamp(<span class="hljs-built_in">min</span>=-max_ratio, <span class="hljs-built_in">max</span>=max_ratio)<br>    dh = dh.clamp(<span class="hljs-built_in">min</span>=-max_ratio, <span class="hljs-built_in">max</span>=max_ratio)<br>    <span class="hljs-comment"># 计算每个 roi 的中心</span><br>    px = ((rois[:, <span class="hljs-number">0</span>] + rois[:, <span class="hljs-number">2</span>]) * <span class="hljs-number">0.5</span>).unsqueeze(<span class="hljs-number">1</span>).expand_as(dx)<br>    py = ((rois[:, <span class="hljs-number">1</span>] + rois[:, <span class="hljs-number">3</span>]) * <span class="hljs-number">0.5</span>).unsqueeze(<span class="hljs-number">1</span>).expand_as(dy)<br>    <span class="hljs-comment"># 计算高度和宽度</span><br>    pw = (rois[:, <span class="hljs-number">2</span>] - rois[:, <span class="hljs-number">0</span>] + <span class="hljs-number">1.0</span>).unsqueeze(<span class="hljs-number">1</span>).expand_as(dw)<br>    ph = (rois[:, <span class="hljs-number">3</span>] - rois[:, <span class="hljs-number">1</span>] + <span class="hljs-number">1.0</span>).unsqueeze(<span class="hljs-number">1</span>).expand_as(dh)<br>    <span class="hljs-comment"># 使用 exp 函数来缩放</span><br>    gw = pw * dw.exp()<br>    gh = ph * dh.exp()<br>    <span class="hljs-comment"># 使用 dx和 dy平移</span><br>    gx = torch.addcmul(px, <span class="hljs-number">1</span>, pw, dx)  <span class="hljs-comment"># gx = px + pw * dx</span><br>    gy = torch.addcmul(py, <span class="hljs-number">1</span>, ph, dy)  <span class="hljs-comment"># gy = py + ph * dy</span><br>    <span class="hljs-comment"># 转换为左上角和右下角坐标形式</span><br>    x1 = gx - gw * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span><br>    y1 = gy - gh * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span><br>    x2 = gx + gw * <span class="hljs-number">0.5</span> - <span class="hljs-number">0.5</span><br>    y2 = gy + gh * <span class="hljs-number">0.5</span> - <span class="hljs-number">0.5</span><br>    <span class="hljs-keyword">if</span> max_shape <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        x1 = x1.clamp(<span class="hljs-built_in">min</span>=<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>=max_shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>)<br>        y1 = y1.clamp(<span class="hljs-built_in">min</span>=<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>=max_shape[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>)<br>        x2 = x2.clamp(<span class="hljs-built_in">min</span>=<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>=max_shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>)<br>        y2 = y2.clamp(<span class="hljs-built_in">min</span>=<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>=max_shape[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>)<br>    bboxes = torch.stack([x1, y1, x2, y2], dim=-<span class="hljs-number">1</span>).view_as(deltas)<br>    <span class="hljs-keyword">return</span> bboxes<br></code></pre></td></tr></table></figure>

<p>使用举例：</p>
<p>将模型预测出来的deltas基于anchor解码成正常的bbox：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">anchor = torch.Tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],<br>                      [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],<br>                      [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],<br>                      [ <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>]])<br>deltas = torch.Tensor([[  <span class="hljs-number">0.</span>,   <span class="hljs-number">0.</span>,   <span class="hljs-number">0.</span>,   <span class="hljs-number">0.</span>],<br>                        [  <span class="hljs-number">1.</span>,   <span class="hljs-number">1.</span>,   <span class="hljs-number">1.</span>,   <span class="hljs-number">1.</span>],<br>                        [  <span class="hljs-number">0.</span>,   <span class="hljs-number">0.</span>,   <span class="hljs-number">2.</span>,  -<span class="hljs-number">1.</span>],<br>                        [ <span class="hljs-number">0.7</span>, -<span class="hljs-number">1.9</span>, -<span class="hljs-number">0.5</span>,  <span class="hljs-number">0.3</span>]])<br>bbox = delta2bbox(rois, deltas)<br><span class="hljs-built_in">print</span>(bbox)<br></code></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">1.0000</span>,  <span class="hljs-number">1.0000</span>],<br>        [ <span class="hljs-number">0.2817</span>,  <span class="hljs-number">0.2817</span>,  <span class="hljs-number">4.7183</span>,  <span class="hljs-number">4.7183</span>],<br>        [-<span class="hljs-number">6.3891</span>,  <span class="hljs-number">0.6321</span>,  <span class="hljs-number">7.3891</span>,  <span class="hljs-number">0.3679</span>],<br>        [ <span class="hljs-number">5.8967</span>,  <span class="hljs-number">2.9251</span>,  <span class="hljs-number">5.5033</span>,  <span class="hljs-number">3.2749</span>]])<br></code></pre></td></tr></table></figure>



<p>至此，基于anchor的算法实现就介绍完毕，当然，这是比较底层的实现方法，目前有很多库可以直接调用faster-rcnn模型； 了解底层算法的好处：有助实现算法的优化，例如算法可有如下优化思路：</p>
<p>1.若目标检测的对象类别比较单一，可以在选取 anchor 的尺寸和高宽比时对 GT box 的这两个参数进行聚类，得到一个比较合适的数值。<br>2.可以尝试在每张图的不同位置设置不同尺寸和大小的 adaptive anchor<br>3.针对检测目标的特性选择anchor的形状，如使用平行四边形</p>
<h2 id="Post-Process之NMS"><a href="#Post-Process之NMS" class="headerlink" title="Post-Process之NMS"></a>Post-Process之NMS</h2><p>由于目标检测算法往往会在一个目标的周围产生大量的目标检测框，而我们最终只需要其检测的最合适的一个，所以需要使用NMS算法来对结果进行后处理。<br>NMS算法的基本思想为：对于一个目标周围的若干大量检测框，找出其中置信度最高的一个保留，然后将其余的框去除<br>具体步骤为：</p>
<ol>
<li>对所有的检测框按照置信度从高到低的顺序排序</li>
<li>求出其他检测框与置信度最高的框的iou值，如果大于一定阈值则说明这些框与置信度最高的框重复性高，将这些框移除（抑制），小于阈值的框保留等待进一步处理，置信度最高的框保存到结果中</li>
<li>将上一步剩余的框再一次按照1和2步骤操作，反复循环到没有框在需要处理（上一步能留下来的框，一般都是另一个物体的框了，所以可继续执行）</li>
</ol>
<img src="/.com//blog\source\images\2020-9-17-plHxTI1BECT3fke_cGCll.png" srcset="/img/loading.gif" lazyload alt="avatar">



<h2 id="卷积结构之FPN——feature-pyrimid-network-特征金字塔网络"><a href="#卷积结构之FPN——feature-pyrimid-network-特征金字塔网络" class="headerlink" title="卷积结构之FPN——feature pyrimid network 特征金字塔网络"></a>卷积结构之FPN——feature pyrimid network 特征金字塔网络</h2><p>特征金字塔思路主要是利用bakcbone多个stage对应多个分辨率特征图的特点，采用<strong>小尺寸特征图用于检测大尺寸物体</strong>，而<strong>大尺寸特征图检测小尺寸物体</strong>的思路。<br>如上图所示，backbone的多个stage每个stage都会输出一个特征图，通过融合浅层和深层的特征来动态分配大目标和小目标。<br>上图中的C2，C3, C4, C5代表了backbone的4个stage对应的输出，然后通过如图所示的自上向下，也就是从深层特征到浅层特征的方式融合后，再经过一个卷积层，生成最终的P2,P3,P4，P5特征图用于后续的分类和回归。</p>
<img src="/.com//blog\source\images\2020-9-17-3cvzw2q7dFkKn3dFpRWEq.png" srcset="/img/loading.gif" lazyload alt="avatar" style="zoom:67%;">

<img src="/.com//blog\source\images\2020-9-17-s53Z_xFHPsEI68hxTMmwm.png" srcset="/img/loading.gif" lazyload alt="avatar" style="zoom:80%;">
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Deep-Learning-Objects-Detection/">Deep Learning-Objects Detection</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/08/13/Pytorch-Related%EF%BC%88%E4%BA%8C%EF%BC%89/">
                        <span class="hidden-mobile">Pytorch_Related（二）</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  

  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
