<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>如何将本地项目上传至Github</title>
    <link href="/2022/02/09/%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E8%87%B3Github/"/>
    <url>/2022/02/09/%E5%A6%82%E4%BD%95%E5%B0%86%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0%E8%87%B3Github/</url>
    
    <content type="html"><![CDATA[<p>本文介绍如何将代码上传至Github、团队内协作、跨团队协作、<code>.gitignore</code>文件配置</p><span id="more"></span><h2 id="如何将本地代码上传至Github"><a href="#如何将本地代码上传至Github" class="headerlink" title="如何将本地代码上传至Github"></a>如何将本地代码上传至Github</h2><p>简介如何将本地项目开源至Github平台</p><img src="/images/gitmode.png" alt="img" style="zoom: 33%;"><h3 id="一、本地端"><a href="#一、本地端" class="headerlink" title="一、本地端"></a>一、本地端</h3><ol><li>首先在本地开发代码时，在项目目录下使用Git工具：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 初始化本地仓库</span><br>git init<br><br>git add xxx.py<br>git commit xxx.py -m <span class="hljs-string">&#x27;add files&#x27;</span><br></code></pre></td></tr></table></figure><p>显然，上述<code>add</code>、<code>commit</code>等操作<strong>可以在Pycharm中完成</strong></p><ol start="2"><li>查看当前状态（是否有文件未添加到暂存区、未更新至版本库），查看历史版本，查看版本更新记录</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查看文件状态、当前分支</span><br>git status<br><br><span class="hljs-comment"># 查看历史版本信息</span><br>git reflog<br><span class="hljs-comment"># 回到历史版本（版本号在git reflog中有显示）</span><br>git reset --hard [版本号]<br><br><span class="hljs-comment"># 查看版本更新记录（作者、时间）</span><br>git log<br></code></pre></td></tr></table></figure><ol start="3"><li>撤销修改、删除恢复等操作：</li></ol><img src="/images/image-20220209102143593.png" alt="image-20220209102143593" style="zoom: 80%;"><h3 id="二、Github端"><a href="#二、Github端" class="headerlink" title="二、Github端"></a>二、Github端</h3><ol><li><p>创建远程库<br>首先在Github自己的账号下<code>Create Repository</code>；</p><blockquote><ol><li>仓库名最好和本地库同名；</li><li>Public和Private选择<code>Public</code>即可，所有人都可以clone你的代码；</li></ol></blockquote><img src="/images/image-20220209102410279.png" alt="image-20220209102410279" style="zoom:67%;"></li><li><p>在本地库关联<br>使用远程库<code>地址</code>即可完成推送，通常为地址创建别名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建别名</span><br>git remote add [别名] https://github.com/Ericccccc/xxx.git<br>    <br><br><span class="hljs-comment"># 查看当前本地库关联的 远程库别名</span><br>git remote -v<br></code></pre></td></tr></table></figure></li></ol><h3 id="三、推送与拉取"><a href="#三、推送与拉取" class="headerlink" title="三、推送与拉取"></a>三、推送与拉取</h3><ol><li><p>推送更新<br>以分支为单位推送；<br>创建、切换、合并、删除分支等操作，设计<code>Git的分支管理</code>内容，具体命令见<a href="https://ericccccc1022.github.io/2021/04/11/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">Git学习笔记（二） - Eric Tan (ericccccc1022.github.io)</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 推送</span><br>git push [别名] [分支]<br><span class="hljs-comment"># 逻辑：先add、commit到本地库，然后从本地库push到远程库拉取</span><br></code></pre></td></tr></table></figure></li></ol><p>由于操作非常方便，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全！<br>这里一定要回顾上述贴出的笔记！</p><ol start="2"><li><p>拉取更新<br>团队内有同伴修改过代码，可拉取到本地；<br>拉取的一个重要意义：时刻保证 <strong>本地库=远程库</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 拉取</span><br>git pull [别名] [分支]<br></code></pre></td></tr></table></figure></li><li><p>克隆<br>克隆他人的项目代码，<code>git clone</code>命令会自动做3件事：</p><blockquote><ol><li>拉取代码；    2. 初始化本地仓库；    3. 创建别名（clone的别名固定为<code>origin</code>）</li></ol></blockquote></li></ol><h3 id="四、团队内协作"><a href="#四、团队内协作" class="headerlink" title="四、团队内协作"></a>四、团队内协作</h3><p>团队内不需要先<code>Fork</code>仓库，队内成员可以直接推送更新至队长的远程库，但是这一步需要队长在github上开放权限：</p><ol><li>添加<code>collaborator</code><br>队长在自己账号下，对应仓库中，选择<code>settings</code>–&gt;<code>manage access</code>–&gt;<code>invite a collaborator</code>，将队友添加进来；<br>添加后会生成一个网址，队长将该网址发给队友，队友登陆后“接受邀请”；<br>之后队友就可以直接推送更新至该仓库；</li><li>拉取更新<br>其他人可以随时拉取队友的更新</li><li>协作模式<br>整个开发模式、分支管理，都参考笔记<a href="https://ericccccc1022.github.io/2021/04/11/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/">Git学习笔记（二） - Eric Tan (ericccccc1022.github.io)</a><br>有非常详尽清晰的说明</li></ol><h3 id="五、跨团队协作"><a href="#五、跨团队协作" class="headerlink" title="五、跨团队协作"></a>五、跨团队协作</h3><p>先<code>Fork</code>，在<code>clone</code>至本地库；<br>任何更新只在fork分支上，要更新至原仓库，需要<code>pull request</code></p><h3 id="六、配置Git忽略文件-gitignore"><a href="#六、配置Git忽略文件-gitignore" class="headerlink" title="六、配置Git忽略文件.gitignore"></a>六、配置Git忽略文件<code>.gitignore</code></h3><p>与项目实际功能无关，不参与服务器部署运行，亦或是太大的权重文件，使用<code>.gitignore</code>文件进行配置，把它们忽略掉；<br>有时也用于屏蔽不同IDE之间的差异</p><p>在项目目录下创建<code>.gitignore</code>文件，写入需要忽略的文件即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#过滤整个mtk文件夹</span><br>/mtk/              <br><br><span class="hljs-comment">#过滤所有.zip文件</span><br>*.<span class="hljs-built_in">zip</span>               <br><br><span class="hljs-comment">#过滤/mtk/do.c文件</span><br>/mtk/do.c        <br><br><span class="hljs-comment">#忽略目录 fd1 下的全部内容</span><br>fd1/*　　　   　　　<br><br><span class="hljs-comment">#不忽略 根目录下的 /fw/bin/ 和 /fw/sf/ 目录；</span><br>!/fw/<span class="hljs-built_in">bin</span>/<br>!/fw/sf/<br></code></pre></td></tr></table></figure><h3 id="七、在Pycharm中使用Git"><a href="#七、在Pycharm中使用Git" class="headerlink" title="七、在Pycharm中使用Git"></a>七、在Pycharm中使用Git</h3><p>参考<a href="https://ericccccc1022.github.io/2021/08/26/%E5%A6%82%E4%BD%95clone%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%B9%B6%E5%9C%A8Pycharm%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0/">如何clone开源项目并在Pycharm提交更新 - Eric Tan (ericccccc1022.github.io)</a><br>有简易全面的说明</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IoU Loss系列</title>
    <link href="/2022/02/09/IoU-Loss%E7%B3%BB%E5%88%97/"/>
    <url>/2022/02/09/IoU-Loss%E7%B3%BB%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>为了弥补传统loss在目标检测任务中的不足，诞生了一系列<code>iou loss</code>，本文做简要介绍。</p><span id="more"></span><h2 id="IoU-Loss系列"><a href="#IoU-Loss系列" class="headerlink" title="IoU Loss系列"></a>IoU Loss系列</h2><p>在<code>YOLOv3-SPP</code>中使用了<code>CIoU loss</code><br>发展历程：<br><img src="/images/image-20220206114721962.png" alt="image-20220206114721962"></p><h3 id="一、IoU-Loss"><a href="#一、IoU-Loss" class="headerlink" title="一、IoU Loss"></a>一、IoU Loss</h3><p>在引入IoU loss之前，使用的是边界框坐标的<code>L2 Loss</code>，会造成不同IoU下损失相同的情况（如下图）<br><img src="/images/image-20220206115017055.png" alt="image-20220206115017055"></p><p>因此引入<code>IoU Loss= -ln(iou)或者直接（1-iou）</code>；<br>缺点：当不相交时loss = 0；</p><h3 id="二、GIoU-Loss"><a href="#二、GIoU-Loss" class="headerlink" title="二、GIoU Loss"></a>二、GIoU Loss</h3><p><code>Generalized IoU Loss = 1 - GIoU</code><br><img src="/images/image-20220206115303191.png" alt="image-20220206115303191" style="zoom:80%;"></p><h3 id="三、DIoU-Loss"><a href="#三、DIoU-Loss" class="headerlink" title="三、DIoU Loss"></a>三、DIoU Loss</h3><p><code>Distance IoU Loss = 1 - DIoU</code></p><p>上述两种损失的缺点：收敛慢、回归不准确；</p><blockquote><p>上述两种损失均考虑了：重叠面积；<br>而<code>DIoU Loss</code>考虑了：重叠面积、中心点距离；</p></blockquote><h3 id="四、CIoU-Loss"><a href="#四、CIoU-Loss" class="headerlink" title="四、CIoU Loss"></a>四、CIoU Loss</h3><p><code>Complete IoU Loss = 1 - CIoU</code></p><p>考虑了3种几何参数：重叠面积、中心点距离、<strong>长宽比</strong>；<br><img src="/images/image-20220206120249223.png" alt="image-20220206120249223" style="zoom: 33%;"> </p><h3 id="Focal-Loss"><a href="#Focal-Loss" class="headerlink" title="Focal Loss"></a>Focal Loss</h3><p>关于Focal Loss是否真的有效，一直存在争议；在<code>YOLOv3</code>中作者指出使用Focal loss后降了2个点；<br>主要针对于<code>One-stage</code>目标检测网络：</p><blockquote><ol><li><code>One-stage</code>普遍存在“类别不平衡问题”，一张图像中能匹配到目标的候选框一般只有十几个，而没匹配到的有上万个！</li><li>而<code>two-stage</code>网络经过RPN的筛选后，输送给检测网络的样本基本不存在类别不平衡问题</li></ol></blockquote>]]></content>
    
    
    <categories>
      
      <category>Deep Learning-Objects Detection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Faster RCNN复读——RPN的训练与正负样本划分</title>
    <link href="/2022/01/28/Faster-RCNN%E5%A4%8D%E8%AF%BB%E2%80%94%E2%80%94RPN%E7%9A%84%E8%AE%AD%E7%BB%83%E4%B8%8E%E6%AD%A3%E8%B4%9F%E6%A0%B7%E6%9C%AC%E5%88%92%E5%88%86/"/>
    <url>/2022/01/28/Faster-RCNN%E5%A4%8D%E8%AF%BB%E2%80%94%E2%80%94RPN%E7%9A%84%E8%AE%AD%E7%BB%83%E4%B8%8E%E6%AD%A3%E8%B4%9F%E6%A0%B7%E6%9C%AC%E5%88%92%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>近期在阅读<code>Cascade RCNN</code>论文时对正负样本的划分存疑，返回来复读<code>Faster RCNN</code>，对于RPN网络的训练、正负样本的划分有了新的理解，同时也进一步理解了<code>anchor</code>机制；记录于此</p><span id="more"></span><h2 id="Faster-RCNN"><a href="#Faster-RCNN" class="headerlink" title="Faster RCNN"></a>Faster RCNN</h2><h3 id="一、总览"><a href="#一、总览" class="headerlink" title="一、总览"></a>一、总览</h3><p>目标检测算法分为<code>One-stage</code>和<code>Two-stage</code></p><blockquote><p>one stage：SSD、YOLO</p><p>two stage：Faster RCNN；（先候选区域，再针对<strong>候选区域</strong>分类、回归）</p></blockquote><p><code>Faster rcnn = RPN + Fast rcnn</code></p><h3 id="二、RPN"><a href="#二、RPN" class="headerlink" title="二、RPN"></a>二、RPN</h3><p><img src="/images/image-20220128160635245.png" alt="image-20220128160635245"></p><img src="/images/image-20220128161631349.png" alt="image-20220128161631349" style="zoom:80%;"><h4 id="（1）做法："><a href="#（1）做法：" class="headerlink" title="（1）做法："></a>（1）做法：</h4><p>​        在<code>feature map</code>上滑动窗口，每个位置计算出<code>256-d</code>向量，进而计算<code>2k scores</code>和<code>4k coordinates</code></p><blockquote><ol><li><code>256-d</code>：由于卷积backbone使用ZF网络，<code>feature map</code>的深度为256<pre><code>若使用VGG16，则此处为`512-d`</code></pre></li><li><code>2k scores</code>：<code>k</code>个<code>anchors</code>是前景、背景的得分</li><li><code>4k coordinates</code>：<code>k</code>个<code>anchors</code>的边界框坐标偏移参数；<code>d_x、d_y、d_w、d_h</code>在后面的偏移公式中使用</li></ol></blockquote><h4 id="（2）anchors的映射"><a href="#（2）anchors的映射" class="headerlink" title="（2）anchors的映射"></a>（2）<code>anchors</code>的映射</h4><p>​        在特征图上每一点都是一个<code>anchor</code>，映射回原图，按照一定比例在原图上取边界框即为<code>anchor box</code>.<br>​        “anchor”的意义就很好理解了，<code>feature map</code>上每个点都是“锚点”，以这些点为锚在原图上生成<code>anchor box</code>！</p><h4 id="（3）anchor-box的尺度与比例（scale、ratio）"><a href="#（3）anchor-box的尺度与比例（scale、ratio）" class="headerlink" title="（3）anchor box的尺度与比例（scale、ratio）"></a>（3）<code>anchor box</code>的尺度与比例（<code>scale</code>、<code>ratio</code>）</h4><p>​        原文中使用<br>​        三种尺度（面积）：<code>&#123;128^2, 256^2, 512^2&#125;</code><br>​        三种比例：<code>&#123;1:1, 1:2, 2:1&#125;</code><br>​        特征图上每个点在原图上都对应有3*3=9个anchors</p><h4 id="（4）感受野讨论"><a href="#（4）感受野讨论" class="headerlink" title="（4）感受野讨论"></a>（4）感受野讨论</h4><p>​        在特征图上使用<code>3×3</code>滑动窗口卷积，对应在原图中的感受野为<br>​        ZF：171<br>​        VGG16：228</p><h4 id="（5）anchor-boxes数量讨论"><a href="#（5）anchor-boxes数量讨论" class="headerlink" title="（5）anchor boxes数量讨论"></a>（5）<code>anchor boxes</code>数量讨论</h4><p>​        对于一张<code>1000×600×3</code>的图像，大约有<code>60×40×9 = 20k</code>个<code>anchor boxes</code><br>​        忽略跨越边界的<code>anchor box</code>，剩下约<code>6k</code>个；<br>​        此时生成的候选框之间存在大量重叠，基于候选框的<code>cls</code>得分，采用非极大值抑制，<code>IoU</code>设为0.7，这样每张图片只剩<code>2k</code>个候选框。</p><blockquote><p>注：此处<code>候选框</code> ≠ <code>anchor box</code>，候选框是经过边界框回归参数初步调整后的<code>anchor box</code></p></blockquote><h4 id="（6）代码实现思路"><a href="#（6）代码实现思路" class="headerlink" title="（6）代码实现思路"></a>（6）代码实现思路</h4><ol><li>feature map –&gt; 256-d：<code>pad=1 stride=1</code>的<code>3*3</code>卷积；</li><li>256-d  –&gt; 2k、4k：  <code>1*1</code>卷积，卷积核个数分别为<code>2k</code>、<code>4k</code></li></ol><h4 id="（7）训练数据集的采样（正样本、负样本）"><a href="#（7）训练数据集的采样（正样本、负样本）" class="headerlink" title="（7）训练数据集的采样（正样本、负样本）"></a>（7）训练数据集的采样（正样本、负样本）</h4><p>​        通过常规的梯度下降反向传播训练<code>RPN</code>网络，理论上可以使用所有<code>anchor boxes</code>，但是其中负样本占主导，会影响训练效果；<br>​        所以应进行采样，随机采样256个<code>anchor boxes</code>来计算损失，并且正负样本比为<code>1:1</code>；如果正样本不足128个，则用负样本填充。</p><blockquote><p>正负样本的划分：<br>（我的理解：在训练RPN阶段，候选区域没有标签，需要认为划分标签才能训练；所以是“为了训练RPN，为每个anchors分配一个二值标签”，这也同时满足了上述正负样本采样1：1的要求）</p><ol><li>我们给两种锚点分配一个正标签：（i）具有与实际边界框的重叠最高交并比（IoU）的锚点，或者（ii）具有与实际边界框的重叠超过0.7 IoU的锚点。（注意，单个真实边界框可以为多个锚点分配正标签。通常第二个条件足以确定正样本；但我们仍然采用第一个条件，因为在一些极少数情况下，第二个条件可能找不到正样本，因为可能所有的IOU值均小于0.7）。</li><li>对于所有的真实边界框，如果一个锚点的IoU低于0.3，我们给这个锚点分配一个负标签（表示背景）。</li><li>那些既不是正标签也不是负标签的锚点不会有助于训练目标函数。</li></ol></blockquote><h4 id="（8）损失"><a href="#（8）损失" class="headerlink" title="（8）损失"></a>（8）损失</h4><img src="/images/image-20220128165315744.png" alt="image-20220128165315744" style="zoom:80%;"><ol><li><p>分类损失<br>两种角度看待</p><blockquote><ol><li>多分类：仍然预测<code>2k</code>个得分；使用<code>cross entropy loss</code></li><li>二分类：只预测<code>k</code>个得分；使用<code>binary cross entropy</code></li></ol></blockquote><p>在<code>pytorch</code>中调用两种损失，都自动集成了<code>softmax</code>和<code>sigmoid</code>操作，这也是二者的主要区别：</p><img src="/images/image-20220128215646916.png" alt="image-20220128215646916" style="zoom:67%;"></li></ol><h3 id="三、Fast-RCNN"><a href="#三、Fast-RCNN" class="headerlink" title="三、Fast RCNN"></a>三、Fast RCNN</h3><p>使用RPN生成候选框后，将候选框投影到特征图上获得相应的特征矩阵；</p><p>每个特征矩阵通过<code>ROI pooling</code>层缩放到<code>7×7</code>大小的特征图，接着将特征图展平通过一系列全连接层得到预测结果。</p><p>综上，Faster RCNN不像Fast RCNN需要额外的<code>SS</code>等区域建议算法，不像RCNN需要训练SVM分类器，直接在一个卷积网络中完成，实现<code>end-to-end</code>训练：</p><img src="/images/v2-2af911b893e0592290baa35accd95fdb_720w.jpg" alt="img" style="zoom:80%;">]]></content>
    
    
    <categories>
      
      <category>Deep Learning-Objects Detection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>pycocotools使用</title>
    <link href="/2022/01/22/pycocotools%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/01/22/pycocotools%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>近期尝试修改<code>MMDetection</code>构建自己工程，<code>customize dataset</code>时必须熟悉<code>pycocotools</code>使用</p><span id="more"></span><h2 id="Pycocotools使用"><a href="#Pycocotools使用" class="headerlink" title="Pycocotools使用"></a>Pycocotools使用</h2><h3 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h3><p><code>pycocotools</code>由coco官方提供，文件非常简洁，无说明文档。<br><img src="/images/image-20220122211249201.png" alt="image-20220122211249201"></p><h3 id="二、使用"><a href="#二、使用" class="headerlink" title="二、使用"></a>二、使用</h3><p>可参考官方的代码注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># The following API functions are defined:</span><br><span class="hljs-comment">#  COCO       - COCO api class that loads COCO annotation file and prepare data structures.</span><br><span class="hljs-comment">#  decodeMask - Decode binary mask M encoded via run-length encoding.</span><br><span class="hljs-comment">#  encodeMask - Encode binary mask M using run-length encoding.</span><br><span class="hljs-comment">#  getAnnIds  - Get ann ids that satisfy given filter conditions.</span><br><span class="hljs-comment">#  getCatIds  - Get cat ids that satisfy given filter conditions.</span><br><span class="hljs-comment">#  getImgIds  - Get img ids that satisfy given filter conditions.</span><br><span class="hljs-comment">#  loadAnns   - Load anns with the specified ids.</span><br><span class="hljs-comment">#  loadCats   - Load cats with the specified ids.</span><br><span class="hljs-comment">#  loadImgs   - Load imgs with the specified ids.</span><br><span class="hljs-comment">#  annToMask  - Convert segmentation in an annotation to binary mask.</span><br><span class="hljs-comment">#  showAnns   - Display the specified annotations.</span><br><span class="hljs-comment">#  loadRes    - Load algorithm results and create API for accessing them.</span><br><span class="hljs-comment">#  download   - Download COCO images from mscoco.org server.</span><br><span class="hljs-comment"># Throughout the API &quot;ann&quot;=annotation, &quot;cat&quot;=category, and &quot;img&quot;=image.</span><br><span class="hljs-comment"># Help on each functions can be accessed by: &quot;help COCO&gt;function&quot;.</span><br></code></pre></td></tr></table></figure><p>API使用<br>整体思路：由<code>id</code>获取整个字段的信息，进而获取字段的某个属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pycocotools.coco <span class="hljs-keyword">import</span> COCO<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">类别id：categories字段的&quot;id&quot;</span><br><span class="hljs-string">图片id：annotations字段的&quot;image_id&quot;、images字段的&quot;id&quot;</span><br><span class="hljs-string">标注id：annotations字段的&quot;id&quot;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>ImageRoot = <span class="hljs-string">&#x27;../../labeled_trainval/SSLAD-2D/labeled/train&#x27;</span><br>annfile = <span class="hljs-string">&quot;../../labeled_trainval/SSLAD-2D/labeled/annotations/instance_train.json&quot;</span><br>coco = COCO(annfile)<br><br><span class="hljs-comment"># 类别名--&gt;类别id （annotation中用的是类别id</span><br><span class="hljs-comment"># ids = coco.getCatIds()</span><br><span class="hljs-comment"># ids = coco.getCatIds(&#x27;Truck&#x27;)</span><br>ids = coco.getCatIds([<span class="hljs-string">&#x27;Truck&#x27;</span>, <span class="hljs-string">&#x27;Car&#x27;</span>])<br><span class="hljs-comment"># 返回列表</span><br><span class="hljs-comment"># ids = coco.getCatIds(&#x27;Truck&#x27;)[0]</span><br><br><span class="hljs-comment"># 类别id--&gt;类别名</span><br>cats = coco.loadCats(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 获取包含类别3、4的图片id</span><br>imgIds = coco.getImgIds(catIds=[<span class="hljs-number">4</span>])<br><br><span class="hljs-comment"># 图片id--&gt;图片字段的全部信息</span><br>imgId = [imgIds[<span class="hljs-number">2</span>], imgIds[<span class="hljs-number">3</span>]]<br>imgInfo = coco.loadImgs(imgId)[<span class="hljs-number">0</span>]<br><br>impath = os.path.join(ImageRoot, imgInfo[<span class="hljs-string">&#x27;file_name&#x27;</span>])<br>img = cv2.imread(impath)<br>plt.imshow(img)<br>plt.show()<br><br><span class="hljs-comment"># 图片id--&gt;标注id  （获取该张图片的所有标注）</span><br>annIds = coco.getAnnIds(imgIds=imgInfo[<span class="hljs-string">&#x27;id&#x27;</span>])<br>anns = coco.loadAnns(annIds)<br><br><br><span class="hljs-comment"># 展示标注图片  （无segmentation标注的数据会报错）</span><br>coco.showAnns(anns)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Deep Learning-Objects Detection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Transformer入门篇</title>
    <link href="/2022/01/20/Transformer%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <url>/2022/01/20/Transformer%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p><code>Transformer</code>、<code>ViT</code>、<code>Swin Transformer</code></p><span id="more"></span><h2 id="Transformer"><a href="#Transformer" class="headerlink" title="Transformer"></a>Transformer</h2><p>2017 《Attention is all you need》</p><p>解决：NLP领域中RNN网络的缺点，（1）RNN的记忆长度问题；    （2）LSTM等无法并行的问题</p><h3 id="1-Attention"><a href="#1-Attention" class="headerlink" title="1. Attention"></a>1. Attention</h3><h4 id="（1）Q、K、V矩阵"><a href="#（1）Q、K、V矩阵" class="headerlink" title="（1）Q、K、V矩阵"></a>（1）Q、K、V矩阵</h4><img src="/images/image-20220115103745254.png" alt="image-20220115103745254" style="zoom:80%;"><p>输入x–&gt;embedding层–&gt;输入a–&gt;分别和3个矩阵相乘–&gt;q、k、v</p><p>所有样本的q、k、v组合在一起，得到大矩阵Q、K、V</p><p>注：</p><blockquote><ol><li>q是<code>query</code>，表示它之后要与其他部分做乘法 ，完成“询问”</li><li>v是<code>information</code>，提炼了该输入包含的信息</li></ol></blockquote><h4 id="（2）Attention的计算"><a href="#（2）Attention的计算" class="headerlink" title="（2）Attention的计算"></a>（2）Attention的计算</h4><img src="/images/image-20220115104141762.png" alt="image-20220115104141762" style="zoom:80%;"><p>每一层的<code>q</code>与其余层的<code>k</code>做点乘操作，再做softmax操作</p><img src="/images/image-20220115104516687.png" alt="image-20220115104516687" style="zoom:80%;"><p>将上述得到的<code>alpha</code>与对应层的<code>v</code>相乘（不是点乘），再相加</p><p>同理将上述两个步骤合起来，再把所有层的操作合起来写成矩阵形式，得到<code>Attention</code>，将其抽象为模块：</p><img src="/images/image-20220115104829578.png" alt="image-20220115104829578" style="zoom:80%;"><h4 id="（3）Multi-head-Self-Attention"><a href="#（3）Multi-head-Self-Attention" class="headerlink" title="（3）Multi-head Self Attention"></a>（3）Multi-head Self Attention</h4><img src="/images/image-20220115104928243.png" alt="image-20220115104928243" style="zoom:67%;"><p>Multi-head：对q、k、v进行均分（线性映射），将第i个q、k、v归为headi </p><img src="/images/image-20220115105602813.png" alt="image-20220115105602813" style="zoom:67%;"><img src="/images/image-20220115105655463.png" alt="image-20220115105655463" style="zoom:67%;"><p>之后对每个head分别执行<code>self-attention</code>操作，然后对结果进行拼接：</p><img src="/images/image-20220115105825077.png" alt="image-20220115105825077" style="zoom:80%;"><p><img src="/images/image-20220115105921395.png" alt="image-20220115105921395" style="zoom:80%;"><img src="/images/image-20220115110134926.png" alt="image-20220115110134926"></p><p>最后同样将<code>Multi-head attention</code>抽象：</p><img src="/images/image-20220115110349632.png" alt="image-20220115110349632" style="zoom:80%;"><h4 id="（4）位置编码"><a href="#（4）位置编码" class="headerlink" title="（4）位置编码"></a>（4）位置编码</h4><p>不进行位置编码的情况下，经过attention层的输出与输入序列的顺序无关，所以通常添加位置编码：</p><p><img src="/images/image-20220115110500818.png" alt="image-20220115110500818"></p><h2 id="Vison-Transformer（ViT）"><a href="#Vison-Transformer（ViT）" class="headerlink" title="Vison Transformer（ViT）"></a>Vison Transformer（ViT）</h2><p>2020 《An Image is worth 16×16 words》</p><p>纯“Transformer”架构，图像分类。</p><h4 id="（1）网络结构"><a href="#（1）网络结构" class="headerlink" title="（1）网络结构"></a>（1）网络结构</h4><p><img src="/images/image-20220115111445528.png" alt="image-20220115111445528"></p><ol><li>将输入切分为patches；</li><li>patches送入<code>Linear Projection</code>层，即<code>Embedding</code>层，每个patch得到一个<code>token</code></li><li>添加一个<code>class token</code>，这里参考了BERT模型的做法；</li><li>为每个token添加一个位置信息，即<code>Position Embedding</code></li><li>所有这些token送入<code>Transformer Encoder</code>，其特点是输出个数=输入个数；</li><li>只取<code>class token</code>对应的输出，送入<code>MLP</code>（多层感知器）进行分类</li></ol><h4 id="（2）Embedding层"><a href="#（2）Embedding层" class="headerlink" title="（2）Embedding层"></a>（2）Embedding层</h4><img src="/images/image-20220115112123292.png" alt="image-20220115112123292" style="zoom:80%;"><p>通过卷积层实现：</p><blockquote><p>卷积核大小 = patch的大小</p><p>卷积步长 = patch的大小</p><p>卷积核个数 = token的长度</p></blockquote><p><code>Position Embedding</code>直接相加在<code>token</code>上，不影响<code>token</code>的维度</p><h4 id="（3）Transformer-Encoder层"><a href="#（3）Transformer-Encoder层" class="headerlink" title="（3）Transformer Encoder层"></a>（3）Transformer Encoder层</h4><img src="/images/image-20220115113304315.png" alt="image-20220115113304315" style="zoom:80%;"><h4 id="（4）MLP层"><a href="#（4）MLP层" class="headerlink" title="（4）MLP层"></a>（4）MLP层</h4><p>常规的全连接神经网络，Linear+激活+dropout</p><p>整体网络结构：</p><img src="/images/img-paramofMLP.png" alt="img" style="zoom:80%;"><h4 id="（5）常见的网络参数"><a href="#（5）常见的网络参数" class="headerlink" title="（5）常见的网络参数"></a>（5）常见的网络参数</h4><img src="/images/image-20220115114948463.png" alt="image-20220115114948463" style="zoom: 67%;"><h4 id="（6）CNN与Transformer混合模型"><a href="#（6）CNN与Transformer混合模型" class="headerlink" title="（6）CNN与Transformer混合模型"></a>（6）CNN与Transformer混合模型</h4><p>纯Transformer的特征提取：通过与patch大小相当的卷积层进行下采样</p><p>Hybrid模型：通过CNN进行特征提取（原文中以<code>ResNet50</code>为例）</p><blockquote><ol><li>将Conv2d变为StdConv2d</li><li>将所有BN层变为GroupNorm层</li></ol></blockquote><img src="https://img-blog.csdnimg.cn/20210704124638234.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NTQxMDk3,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:80%;"><h4 id="（7）代码参考"><a href="#（7）代码参考" class="headerlink" title="（7）代码参考"></a>（7）代码参考</h4><p>参考：<a href="https://github.com/WZMIAOMIAO/deep-learning-for-image-processing">https://github.com/WZMIAOMIAO/deep-learning-for-image-processing</a></p><p><code>nn.Parameter()</code>构建可训练参数，如ViT中的<code>class token</code>和<code>position embedding</code></p><h2 id="Swin-Transformer"><a href="#Swin-Transformer" class="headerlink" title="Swin Transformer"></a>Swin Transformer</h2><p>2021 ICCV best paper</p><p>《Swin Transformer: Hierarchical Vision Transformer using Shifted Windows》</p><h4 id="（1）网络结构-1"><a href="#（1）网络结构-1" class="headerlink" title="（1）网络结构"></a>（1）网络结构</h4><p><img src="/images/image-20220115154746180.png" alt="image-20220115154746180"></p><h4 id="（2）Patch-Merging"><a href="#（2）Patch-Merging" class="headerlink" title="（2）Patch Merging"></a>（2）Patch Merging</h4><p>尺寸减半、通道加倍<br>每个<code>Swin Transformer Block</code>之前做一次，相当于一次下采样</p><img src="/images/image-20220115154853244.png" alt="image-20220115154853244" style="zoom:67%;"><blockquote><ol><li>切分为patch（实现尺寸减半）</li><li>在深度方向堆叠，然后在深度方向做全连接层（实现通道数翻倍）</li></ol></blockquote><h4 id="（3）W-MSA"><a href="#（3）W-MSA" class="headerlink" title="（3）W-MSA"></a>（3）W-MSA</h4><p><code>Window Multi-head self attention</code></p><p>目的：减少计算量；    缺点：窗口之间无法进行信息交互</p><img src="/images/image-20220115160631709.png" alt="image-20220115160631709" style="zoom:50%;"><img src="/images/image-20220115160716369.png" alt="image-20220115160716369" style="zoom:80%;"><p><code>FLOPs</code>表示计算量，用于衡量模型复杂度</p><h4 id="（4）SW-MSA"><a href="#（4）SW-MSA" class="headerlink" title="（4）SW-MSA"></a>（4）SW-MSA</h4><p><code>Shifted Window Multi-head self attention</code></p><p>比较复杂，我的理解：</p><p>目的：实现各窗口间的信息交互<br>做法：shifted顾名思义，将窗口移动，移动后的新窗口囊括之前的多个窗口信息：<br><img src="/images/image-20220115162411041.png" alt="image-20220115162411041" style="zoom:80%;"></p><p>此时窗口大小不一致，不方便做<code>MSA</code>操作，直接在外圈padding增加太多计算量，论文的做法比较复杂：<br><img src="/images/image-20220115162644949.png" alt="image-20220115162644949" style="zoom:67%;"></p><p>移动之后加<code>Mask</code>，实现：在窗口上可以直接做<code>MSA</code>操作，在区域上添加Mask又可避免不相邻窗口之间的信息交互。</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning-Objects Detection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在Pytorch中使用Tensorboard可视化</title>
    <link href="/2022/01/20/%E5%9C%A8Pytorch%E4%B8%AD%E4%BD%BF%E7%94%A8Tensorboard%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <url>/2022/01/20/%E5%9C%A8Pytorch%E4%B8%AD%E4%BD%BF%E7%94%A8Tensorboard%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>其他可视化工具：<code>Visdom</code>，支持torch和numpy</p><span id="more"></span><h2 id="在Pytorch中使用Tensorboard可视化训练"><a href="#在Pytorch中使用Tensorboard可视化训练" class="headerlink" title="在Pytorch中使用Tensorboard可视化训练"></a>在Pytorch中使用Tensorboard可视化训练</h2><p><img src="/images/image-20220115204332591.png" alt="image-20220115204332591"></p><p>大致有几个模块：</p><blockquote><ol><li>SCALARS</li><li>Images：绘制随迭代轮次变化，图片预测准确率</li><li>Graphs：网络结构图等</li><li>Distributions参数权重分布图</li><li>Histograms：参数权重分布直方图</li></ol></blockquote><p>下面示例几行代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br><span class="hljs-comment"># 实例化</span><br>tb_writer = SummaryWriter(log_dir=<span class="hljs-string">&quot;runs/flower_experiment&quot;</span>)<br>model = models.resnet18()<br><span class="hljs-comment"># 将模型写入tensorboard</span><br>init_img = torch.zeros((<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">224</span>, <span class="hljs-number">224</span>))<br>tb_writer.add_graph(model, init_img)<br><br><span class="hljs-comment"># ....</span><br><span class="hljs-comment"># 每一轮训练完，计算得到loss、acc</span><br><span class="hljs-comment"># 写入tensorboard</span><br>tags = [<span class="hljs-string">&quot;train_loss&quot;</span>, <span class="hljs-string">&quot;accuracy&quot;</span>, <span class="hljs-string">&quot;learning_rate&quot;</span>]<br>tb_writer.add_scalar(tags[<span class="hljs-number">0</span>], mean_loss, epoch)<br>tb_writer.add_scalar(tags[<span class="hljs-number">1</span>], acc, epoch)<br>tb_writer.add_scalar(tags[<span class="hljs-number">2</span>], optimizer.param_groups[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;lr&quot;</span>], epoch)<br><br><span class="hljs-comment"># add figure into tensorboard</span><br>fig = plot_class_preds(net=model,<br>                       images_dir=<span class="hljs-string">&quot;./plot_img&quot;</span>,<br>                       transform=data_transform[<span class="hljs-string">&quot;val&quot;</span>],<br>                       num_plot=<span class="hljs-number">5</span>,<br>                       device=device)<br><span class="hljs-keyword">if</span> fig <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>    tb_writer.add_figure(<span class="hljs-string">&quot;predictions vs. actuals&quot;</span>,<br>                          figure=fig,<br>                          global_step=epoch)<br>    <br><span class="hljs-comment"># add conv1 weights into tensorboard</span><br>tb_writer.add_histogram(tag=<span class="hljs-string">&quot;conv1&quot;</span>,<br>                        values=model.conv1.weight,<br>                        global_step=epoch)<br>tb_writer.add_histogram(tag=<span class="hljs-string">&quot;layer1/block0/conv1&quot;</span>,<br>                        values=model.layer1[<span class="hljs-number">0</span>].conv1.weight,<br>                        global_step=epoch)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Deep Learning-Objects Detection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>制作自己的数据集3--目标检测VOC/COCO</title>
    <link href="/2022/01/20/%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%863-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BVOC-COCO/"/>
    <url>/2022/01/20/%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%863-%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8BVOC-COCO/</url>
    
    <content type="html"><![CDATA[<p>VOC –xml标注；COCO –json标注</p><p>完整代码参考：<br><a href="https://github.com/WZMIAOMIAO/deep-learning-for-image-processing">https://github.com/WZMIAOMIAO/deep-learning-for-image-processing</a></p><span id="more"></span><h3 id="二、目标检测–PASCAL-VOC-自己的图片"><a href="#二、目标检测–PASCAL-VOC-自己的图片" class="headerlink" title="二、目标检测–PASCAL VOC/自己的图片"></a>二、目标检测–PASCAL VOC/自己的图片</h3><h4 id="1-VOC数据集结构"><a href="#1-VOC数据集结构" class="headerlink" title="1.VOC数据集结构"></a>1.VOC数据集结构</h4><p>官网下载Development Kit，VOC2012的test数据集不公开</p><img src="/images/image-20220113194001120.png" alt="image-20220113194001120" style="zoom:80%;"><p><img src="/images/image-20220113194042652.png" alt="image-20220113194042652"></p><blockquote><p>Annotations包含所有xml文件</p><p>ImageSets中重点关注<code>train.txt</code>、<code>val.txt</code>、<code>trainval.txt</code>文件，包含对应图片的名称</p></blockquote><p>通常的训练模式：</p><blockquote><p>使用trainval训练，用VOC2007的test测试</p><p>使用trainval训练，官网下载专门的测试软件</p></blockquote><p>通常制作数据集的流程：<br>        从<code>ImageSets\Main</code>文件下的<code>train.txt</code>出发，由其中的文件名称找（1）<code>Annotations</code>中的标注文件；（2）<code>JPEGImages</code>中的图片</p><p>自己打标注：</p><ol><li><code>labelImg</code>：xml格式</li><li><code>labelme</code>：json格式</li></ol><h4 id="2-构建Dataset"><a href="#2-构建Dataset" class="headerlink" title="2.构建Dataset"></a>2.构建Dataset</h4><p>此处提供的构建Dataset方法，适用于VOC / 自己的数据（只要标注由xml文件提供）</p><blockquote><p>注：自己的数据必须用VOC一样的形式组织文件</p></blockquote><h5 id="生成train-txt脚本"><a href="#生成train-txt脚本" class="headerlink" title="生成train.txt脚本"></a>生成train.txt脚本</h5><p>对于自己的数据集，首先要生成<code>train.txt</code>这样的脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">PASCAL VOC: 标注由xml文件提供</span><br><span class="hljs-string">自己的数据集：标注由xml文件提供</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 自己的数据集生成train.txt文件</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-comment"># 查看标注信息是否存在</span><br>file_path = <span class="hljs-string">&#x27;./VOCdevkit/VOC2012/Annotations&#x27;</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(file_path):<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文件夹不存在&quot;</span>)<br><br><span class="hljs-comment"># 验证集比例</span><br>val_rate = <span class="hljs-number">0.3</span><br><br>file_name = <span class="hljs-built_in">sorted</span>([file.split(<span class="hljs-string">&quot;.&quot;</span>)[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> os.listdir(file_path)])<span class="hljs-comment"># 获取所有xml文件名</span><br><span class="hljs-comment"># 统计数量，随机采样</span><br>file_num = <span class="hljs-built_in">len</span>(file_name)<br>val_index = random.sample(<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, file_num), k=<span class="hljs-built_in">int</span>(file_num*val_rate))<br><span class="hljs-comment"># 根据随机采样的索引构建val、train</span><br>train_files, val_files = [], []<br><span class="hljs-keyword">for</span> idx, file_name <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(file_name):<br><span class="hljs-keyword">if</span> idx <span class="hljs-keyword">in</span> val_index:<br>val_files.append(file_name)<br><span class="hljs-keyword">else</span>:<br>train_files.appned(file_name)<br><br><span class="hljs-comment"># 写.txt文件</span><br><span class="hljs-keyword">try</span>:<br>train_f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;train.txt&quot;</span>, <span class="hljs-string">&#x27;x&#x27;</span>)<br>val_f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;val.txt&quot;</span>, <span class="hljs-string">&#x27;x&#x27;</span>)<br>train_f.write(<span class="hljs-string">&quot;\n&quot;</span>.join(train_files))<span class="hljs-comment"># train_files列表每两个元素之间用\n连接</span><br>val_f.write(<span class="hljs-string">&quot;\n&quot;</span>.join(val_files))<br><br><span class="hljs-keyword">except</span> FileExistsError <span class="hljs-keyword">as</span> e:<br><span class="hljs-built_in">print</span>(e)<br></code></pre></td></tr></table></figure><h5 id="构建Dataset"><a href="#构建Dataset" class="headerlink" title="构建Dataset"></a>构建Dataset</h5><p>然后构建自己的Dataset</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 构建自己的Dataset</span><br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myDataset</span>(<span class="hljs-params">Dataset</span>):</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, voc_root, year=<span class="hljs-string">&quot;2012&quot;</span>, transforms=<span class="hljs-literal">None</span>, txt_name: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;train.txt&quot;</span></span>):</span><br>        <span class="hljs-keyword">assert</span> year <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;2007&quot;</span>, <span class="hljs-string">&quot;2012&quot;</span>], <span class="hljs-string">&quot;year must be in [&#x27;2007&#x27;, &#x27;2012&#x27;]&quot;</span><br><br>        self.root = os.path.join(voc_root, <span class="hljs-string">&quot;VOCdevkit&quot;</span>, <span class="hljs-string">f&quot;VOC<span class="hljs-subst">&#123;year&#125;</span>&quot;</span>)<br>        self.img_root = os.path.join(self.root, <span class="hljs-string">&quot;JPEGImages&quot;</span>)<br>        self.annotations_root = os.path.join(self.root, <span class="hljs-string">&quot;Annotations&quot;</span>)<br><br>        <span class="hljs-comment"># read train.txt or val.txt file</span><br>        txt_path = os.path.join(self.root, <span class="hljs-string">&quot;ImageSets&quot;</span>, <span class="hljs-string">&quot;Main&quot;</span>, txt_name)<br>        <span class="hljs-keyword">assert</span> os.path.exists(txt_path), <span class="hljs-string">&quot;not found &#123;&#125; file.&quot;</span>.<span class="hljs-built_in">format</span>(txt_name)<br><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(txt_path) <span class="hljs-keyword">as</span> read:<br>        <span class="hljs-comment"># line.strip()方法去掉换行符 </span><br>            self.xml_list = [os.path.join(self.annotations_root, line.strip() + <span class="hljs-string">&quot;.xml&quot;</span>)<br>                             <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> read.readlines() <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(line.strip()) &gt; <span class="hljs-number">0</span>]<br><br>        <span class="hljs-comment"># check file</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(self.xml_list) &gt; <span class="hljs-number">0</span>, <span class="hljs-string">&quot;in &#x27;&#123;&#125;&#x27; file does not find any information.&quot;</span>.<span class="hljs-built_in">format</span>(txt_path)<br>        <span class="hljs-keyword">for</span> xml_path <span class="hljs-keyword">in</span> self.xml_list:<br>            <span class="hljs-keyword">assert</span> os.path.exists(xml_path), <span class="hljs-string">&quot;not found &#x27;&#123;&#125;&#x27; file.&quot;</span>.<span class="hljs-built_in">format</span>(xml_path)<br><br>        <span class="hljs-comment"># read class_indict</span><br>        json_file = <span class="hljs-string">&#x27;./pascal_voc_classes.json&#x27;</span><br>        <span class="hljs-keyword">assert</span> os.path.exists(json_file), <span class="hljs-string">&quot;&#123;&#125; file not exist.&quot;</span>.<span class="hljs-built_in">format</span>(json_file)<br>        json_file = <span class="hljs-built_in">open</span>(json_file, <span class="hljs-string">&#x27;r&#x27;</span>)<br>        self.class_dict = json.load(json_file)<span class="hljs-comment"># 每个类别对应一个数字</span><br>        json_file.close()<br><br>        self.transforms = transforms<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.xml_list)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, idx</span>):</span><br>        <span class="hljs-comment"># read xml</span><br>        xml_path = self.xml_list[idx]<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(xml_path) <span class="hljs-keyword">as</span> fid:<br>            xml_str = fid.read()<br><br>        <span class="hljs-comment"># 利用xlml包解析xml文件 </span><br>        xml = etree.fromstring(xml_str)<br>        data = self.parse_xml_to_dict(xml)[<span class="hljs-string">&quot;annotation&quot;</span>]<span class="hljs-comment"># 自己实现的方法</span><br>        <span class="hljs-comment"># 将xml解析成字典</span><br>        img_path = os.path.join(self.img_root, data[<span class="hljs-string">&quot;filename&quot;</span>])<br>        image = Image.<span class="hljs-built_in">open</span>(img_path)<br>        <span class="hljs-keyword">if</span> image.<span class="hljs-built_in">format</span> != <span class="hljs-string">&quot;JPEG&quot;</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Image &#x27;&#123;&#125;&#x27; format not JPEG&quot;</span>.<span class="hljs-built_in">format</span>(img_path))<br><br>        boxes = []<br>        labels = []<br>        iscrowd = []<br>        <span class="hljs-keyword">assert</span> <span class="hljs-string">&quot;object&quot;</span> <span class="hljs-keyword">in</span> data, <span class="hljs-string">&quot;&#123;&#125; lack of object information.&quot;</span>.<span class="hljs-built_in">format</span>(xml_path)<br>        <span class="hljs-keyword">for</span> obj <span class="hljs-keyword">in</span> data[<span class="hljs-string">&quot;object&quot;</span>]:<br>            xmin = <span class="hljs-built_in">float</span>(obj[<span class="hljs-string">&quot;bndbox&quot;</span>][<span class="hljs-string">&quot;xmin&quot;</span>])<br>            xmax = <span class="hljs-built_in">float</span>(obj[<span class="hljs-string">&quot;bndbox&quot;</span>][<span class="hljs-string">&quot;xmax&quot;</span>])<br>            ymin = <span class="hljs-built_in">float</span>(obj[<span class="hljs-string">&quot;bndbox&quot;</span>][<span class="hljs-string">&quot;ymin&quot;</span>])<br>            ymax = <span class="hljs-built_in">float</span>(obj[<span class="hljs-string">&quot;bndbox&quot;</span>][<span class="hljs-string">&quot;ymax&quot;</span>])<br><br>            <span class="hljs-comment"># 进一步检查数据，有的标注信息中可能有w或h为0的情况，这样的数据会导致计算回归loss为nan</span><br>            <span class="hljs-keyword">if</span> xmax &lt;= xmin <span class="hljs-keyword">or</span> ymax &lt;= ymin:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Warning: in &#x27;&#123;&#125;&#x27; xml, there are some bbox w/h &lt;=0&quot;</span>.<span class="hljs-built_in">format</span>(xml_path))<br>                <span class="hljs-keyword">continue</span><br>            <br>            boxes.append([xmin, ymin, xmax, ymax])<br>            labels.append(self.class_dict[obj[<span class="hljs-string">&quot;name&quot;</span>]])<br>            <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;difficult&quot;</span> <span class="hljs-keyword">in</span> obj:<br>                iscrowd.append(<span class="hljs-built_in">int</span>(obj[<span class="hljs-string">&quot;difficult&quot;</span>]))<br>            <span class="hljs-keyword">else</span>:<br>                iscrowd.append(<span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># convert everything into a torch.Tensor</span><br>        boxes = torch.as_tensor(boxes, dtype=torch.float32)<br>        labels = torch.as_tensor(labels, dtype=torch.int64)<br>        iscrowd = torch.as_tensor(iscrowd, dtype=torch.int64)<br>        image_id = torch.tensor([idx])<br>        area = (boxes[:, <span class="hljs-number">3</span>] - boxes[:, <span class="hljs-number">1</span>]) * (boxes[:, <span class="hljs-number">2</span>] - boxes[:, <span class="hljs-number">0</span>])<br><br>        target = &#123;&#125;<br>        target[<span class="hljs-string">&quot;boxes&quot;</span>] = boxes<br>        target[<span class="hljs-string">&quot;labels&quot;</span>] = labels<br>        target[<span class="hljs-string">&quot;image_id&quot;</span>] = image_id<br>        target[<span class="hljs-string">&quot;area&quot;</span>] = area<br>        target[<span class="hljs-string">&quot;iscrowd&quot;</span>] = iscrowd<br><br>        <span class="hljs-keyword">if</span> self.transforms <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            image, target = self.transforms(image, target)<br><br>        <span class="hljs-keyword">return</span> image, target <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_height_and_width</span>(<span class="hljs-params">self, idx</span>):</span><br>        <span class="hljs-comment"># read xml</span><br>        xml_path = self.xml_list[idx]<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(xml_path) <span class="hljs-keyword">as</span> fid:<br>            xml_str = fid.read()<br>        xml = etree.fromstring(xml_str)<br>        data = self.parse_xml_to_dict(xml)[<span class="hljs-string">&quot;annotation&quot;</span>]<br>        data_height = <span class="hljs-built_in">int</span>(data[<span class="hljs-string">&quot;size&quot;</span>][<span class="hljs-string">&quot;height&quot;</span>])<br>        data_width = <span class="hljs-built_in">int</span>(data[<span class="hljs-string">&quot;size&quot;</span>][<span class="hljs-string">&quot;width&quot;</span>])<br>        <span class="hljs-keyword">return</span> data_height, data_width<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_xml_to_dict</span>(<span class="hljs-params">self, xml</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        将xml文件解析成字典形式，参考tensorflow的recursive_parse_xml_to_dict</span><br><span class="hljs-string">        Args:</span><br><span class="hljs-string">            xml: xml tree obtained by parsing XML file contents using lxml.etree</span><br><span class="hljs-string">        Returns:</span><br><span class="hljs-string">            Python dictionary holding XML contents.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(xml) == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 遍历到底层，直接返回tag对应的信息</span><br>            <span class="hljs-keyword">return</span> &#123;xml.tag: xml.text&#125;<br><br>        result = &#123;&#125;<br>        <span class="hljs-keyword">for</span> child <span class="hljs-keyword">in</span> xml:<span class="hljs-comment"># 遍历子标签   </span><br>            child_result = self.parse_xml_to_dict(child)  <span class="hljs-comment"># 递归遍历标签信息</span><br>            <span class="hljs-keyword">if</span> child.tag != <span class="hljs-string">&#x27;object&#x27;</span>:<br>                result[child.tag] = child_result[child.tag]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> child.tag <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> result:  <span class="hljs-comment"># 因为object可能有多个，所以需要放入列表里</span><br>                    result[child.tag] = []<br>                result[child.tag].append(child_result[child.tag])<br>        <span class="hljs-keyword">return</span> &#123;xml.tag: result&#125; <br></code></pre></td></tr></table></figure><h5 id="目标检测数据增强：自己的transforms-py"><a href="#目标检测数据增强：自己的transforms-py" class="headerlink" title="目标检测数据增强：自己的transforms.py"></a>目标检测数据增强：自己的transforms.py</h5><p>注意在随机翻转时要同时翻转bbox，所以自己实现类：</p><blockquote><p>目标检测任务通常写自己的transforms.py函数，里面可实现随即反转、裁剪、平移等操作，连同bbox一起变换</p><p>在train.py函数中用自己的transforms函数构建数据预处理</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">目标检测任务中，随机变换时要同时变换bbox</span><br><span class="hljs-string">自己实现transforms类：transforms.py</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> torchvision.transforms <span class="hljs-keyword">import</span> functional <span class="hljs-keyword">as</span> F<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Compose</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;组合多个transform函数&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, transforms</span>):</span><br>        self.transforms = transforms<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, image, target</span>):</span><br>        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> self.transforms:<br>            image, target = t(image, target)<br>        <span class="hljs-keyword">return</span> image, target<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToTensor</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;将PIL图像转为Tensor&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, image, target</span>):</span><br>        image = F.to_tensor(image)<br>        <span class="hljs-keyword">return</span> image, target<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomHorizontalFlip</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;随机水平翻转图像以及bboxes&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, prob=<span class="hljs-number">0.5</span></span>):</span><br>        self.prob = prob<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, image, target</span>):</span><br>        <span class="hljs-keyword">if</span> random.random() &lt; self.prob:<br>            height, width = image.shape[-<span class="hljs-number">2</span>:]<br>            image = image.flip(-<span class="hljs-number">1</span>)  <span class="hljs-comment"># 水平翻转图片</span><br>            bbox = target[<span class="hljs-string">&quot;boxes&quot;</span>]<br>            <span class="hljs-comment"># bbox: xmin, ymin, xmax, ymax</span><br>            bbox[:, [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]] = width - bbox[:, [<span class="hljs-number">2</span>, <span class="hljs-number">0</span>]]  <span class="hljs-comment"># 翻转对应bbox坐标信息</span><br>            target[<span class="hljs-string">&quot;boxes&quot;</span>] = bbox<br>        <span class="hljs-keyword">return</span> image, target<br></code></pre></td></tr></table></figure><p>最后，就可直接用pytorch的<code>torch.utils.data.DataLoader</code>方法直接读取batch</p><h3 id="三、目标检测–COCO与pycocotools使用"><a href="#三、目标检测–COCO与pycocotools使用" class="headerlink" title="三、目标检测–COCO与pycocotools使用"></a>三、目标检测–COCO与pycocotools使用</h3><h4 id="1-MS-COCO数据集结构"><a href="#1-MS-COCO数据集结构" class="headerlink" title="1. MS COCO数据集结构"></a>1. MS COCO数据集结构</h4><p><img src="/images/image-20220115181616429.png" alt="image-20220115181616429"></p><h4 id="2-pycocotools工具"><a href="#2-pycocotools工具" class="headerlink" title="2.pycocotools工具"></a>2.pycocotools工具</h4><p>（1）安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install pycocotools# Linux系统<br>pip install pycocotools-windows # windows系统<br></code></pre></td></tr></table></figure><p>（2）使用</p><p>annotations和imgs不在一个字段中，所以要先用img_id找出该张图片的所有annotations，具体转换过程不可能记下来的，只能：</p><blockquote><p>断点debug + 官网data-format 结合编写代码</p></blockquote><p>（3）结果检测-mAP</p><p> 使用pycocotools可以方便地计算mAP</p><p>前提：将预测结果保存为官网要求的格式，并写成json文件。<br>格式要求：去官网的<code>Evaluate</code>下面的<code>Results Format</code>查看，<br><a href="https://cocodataset.org/#format-data">COCO - Common Objects in Context (cocodataset.org)</a><br>例如：<br><img src="/images/image-20220115201220734.png" alt="image-20220115201220734"></p><p>然后将所有结果写入一个json文件，之后调用pycocotools即可：</p><p><img src="/images/image-20220115201350424.png" alt="image-20220115201350424"></p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning-Objects Detection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>制作自己的数据集2-图像分类</title>
    <link href="/2022/01/15/%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%862-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"/>
    <url>/2022/01/15/%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%862-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>json文件与分布式训练</p><span id="more"></span><h4 id="方法三：json–-gt-Dataset（适用于多GPU训练）"><a href="#方法三：json–-gt-Dataset（适用于多GPU训练）" class="headerlink" title="方法三：json–&gt;Dataset（适用于多GPU训练）"></a>方法三：json–&gt;Dataset（适用于多GPU训练）</h4><p>最一般的数据集制作流程：</p><blockquote><ol><li><code>utils.py</code>中写json文件</li><li><code>my_dataset.py</code>的Dataset类中读取json文件、预处理、判断图片类型等</li></ol></blockquote><ol><li>utils.py</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">写json文件</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> pickle<br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_split_data</span>(<span class="hljs-params">root: <span class="hljs-built_in">str</span>, val_rate: <span class="hljs-built_in">float</span> = <span class="hljs-number">0.2</span></span>):</span><br>    random.seed(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 保证随机结果可复现</span><br>    <span class="hljs-keyword">assert</span> os.path.exists(root), <span class="hljs-string">&quot;dataset root: &#123;&#125; does not exist.&quot;</span>.<span class="hljs-built_in">format</span>(root)<br><br>    <span class="hljs-comment"># 遍历文件夹，一个文件夹对应一个类别</span><br>    flower_class = [cla <span class="hljs-keyword">for</span> cla <span class="hljs-keyword">in</span> os.listdir(root) <span class="hljs-keyword">if</span> os.path.isdir(os.path.join(root, cla))]<br>    <span class="hljs-comment"># 排序，保证顺序一致</span><br>    flower_class.sort()<br>    <span class="hljs-comment"># 生成类别名称以及对应的数字索引</span><br>    class_indices = <span class="hljs-built_in">dict</span>((k, v) <span class="hljs-keyword">for</span> v, k <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(flower_class))<br>    json_str = json.dumps(<span class="hljs-built_in">dict</span>((val, key) <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> class_indices.items()), indent=<span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;class_indices.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> json_file:<br>        json_file.write(json_str)<br><br>    train_images_path = []  <span class="hljs-comment"># 存储训练集的所有图片路径</span><br>    train_images_label = []  <span class="hljs-comment"># 存储训练集图片对应索引信息</span><br>    val_images_path = []  <span class="hljs-comment"># 存储验证集的所有图片路径</span><br>    val_images_label = []  <span class="hljs-comment"># 存储验证集图片对应索引信息</span><br>    every_class_num = []  <span class="hljs-comment"># 存储每个类别的样本总数</span><br>    supported = [<span class="hljs-string">&quot;.jpg&quot;</span>, <span class="hljs-string">&quot;.JPG&quot;</span>, <span class="hljs-string">&quot;.png&quot;</span>, <span class="hljs-string">&quot;.PNG&quot;</span>]  <span class="hljs-comment"># 支持的文件后缀类型</span><br>    <span class="hljs-comment"># 遍历每个文件夹下的文件</span><br>    <span class="hljs-keyword">for</span> cla <span class="hljs-keyword">in</span> flower_class:<br>        cla_path = os.path.join(root, cla)<br>        <span class="hljs-comment"># 遍历获取supported支持的所有文件路径</span><br>        images = [os.path.join(root, cla, i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> os.listdir(cla_path)<br>                  <span class="hljs-keyword">if</span> os.path.splitext(i)[-<span class="hljs-number">1</span>] <span class="hljs-keyword">in</span> supported]<br>        <span class="hljs-comment"># 获取该类别对应的索引</span><br>        image_class = class_indices[cla]<br>        <span class="hljs-comment"># 记录该类别的样本数量</span><br>        every_class_num.append(<span class="hljs-built_in">len</span>(images))<br>        <span class="hljs-comment"># 按比例随机采样验证样本</span><br>        val_path = random.sample(images, k=<span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(images) * val_rate))<br><br>        <span class="hljs-keyword">for</span> img_path <span class="hljs-keyword">in</span> images:<br>            <span class="hljs-keyword">if</span> img_path <span class="hljs-keyword">in</span> val_path:  <span class="hljs-comment"># 如果该路径在采样的验证集样本中则存入验证集</span><br>                val_images_path.append(img_path)<br>                val_images_label.append(image_class)<br>            <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 否则存入训练集</span><br>                train_images_path.append(img_path)<br>                train_images_label.append(image_class)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; images were found in the dataset.&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">sum</span>(every_class_num)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; images for training.&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(train_images_path)))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125; images for validation.&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(val_images_path)))<br><br>    plot_image = <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">if</span> plot_image:<br>        <span class="hljs-comment"># 绘制每种类别个数柱状图</span><br>        plt.bar(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(flower_class)), every_class_num, align=<span class="hljs-string">&#x27;center&#x27;</span>)<br>        <span class="hljs-comment"># 将横坐标0,1,2,3,4替换为相应的类别名称</span><br>        plt.xticks(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(flower_class)), flower_class)<br>        <span class="hljs-comment"># 在柱状图上添加数值标签</span><br>        <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(every_class_num):<br>            plt.text(x=i, y=v + <span class="hljs-number">5</span>, s=<span class="hljs-built_in">str</span>(v), ha=<span class="hljs-string">&#x27;center&#x27;</span>)<br>        <span class="hljs-comment"># 设置x坐标</span><br>        plt.xlabel(<span class="hljs-string">&#x27;image class&#x27;</span>)<br>        <span class="hljs-comment"># 设置y坐标</span><br>        plt.ylabel(<span class="hljs-string">&#x27;number of images&#x27;</span>)<br>        <span class="hljs-comment"># 设置柱状图的标题</span><br>        plt.title(<span class="hljs-string">&#x27;flower class distribution&#x27;</span>)<br>        plt.show()<br><br>    <span class="hljs-keyword">return</span> train_images_path, train_images_label, val_images_path, val_images_label<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_data_loader_image</span>(<span class="hljs-params">data_loader</span>):</span><br>    batch_size = data_loader.batch_size<br>    plot_num = <span class="hljs-built_in">min</span>(batch_size, <span class="hljs-number">4</span>)<br><br>    json_path = <span class="hljs-string">&#x27;./class_indices.json&#x27;</span><br>    <span class="hljs-keyword">assert</span> os.path.exists(json_path), json_path + <span class="hljs-string">&quot; does not exist.&quot;</span><br>    json_file = <span class="hljs-built_in">open</span>(json_path, <span class="hljs-string">&#x27;r&#x27;</span>)<br>    class_indices = json.load(json_file)<br><br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> data_loader:<br>        images, labels = data<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(plot_num):<br>            <span class="hljs-comment"># [C, H, W] -&gt; [H, W, C]</span><br>            img = images[i].numpy().transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)<br>            <span class="hljs-comment"># 反Normalize操作</span><br>            img = (img * [<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>] + [<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>]) * <span class="hljs-number">255</span><br>            label = labels[i].item()<br>            plt.subplot(<span class="hljs-number">1</span>, plot_num, i+<span class="hljs-number">1</span>)<br>            plt.xlabel(class_indices[<span class="hljs-built_in">str</span>(label)])<br>            plt.xticks([])  <span class="hljs-comment"># 去掉x轴的刻度</span><br>            plt.yticks([])  <span class="hljs-comment"># 去掉y轴的刻度</span><br>            plt.imshow(img.astype(<span class="hljs-string">&#x27;uint8&#x27;</span>))<br>        plt.show()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_pickle</span>(<span class="hljs-params">list_info: <span class="hljs-built_in">list</span>, file_name: <span class="hljs-built_in">str</span></span>):</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        pickle.dump(list_info, f)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_pickle</span>(<span class="hljs-params">file_name: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>:</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        info_list = pickle.load(f)<br>        <span class="hljs-keyword">return</span> <br></code></pre></td></tr></table></figure><ol start="2"><li>my_dataset.py</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">自己实现了DataLoader中的collate_fn方法</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDataSet</span>(<span class="hljs-params">Dataset</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;自定义数据集&quot;&quot;&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, images_path: <span class="hljs-built_in">list</span>, images_class: <span class="hljs-built_in">list</span>, transform=<span class="hljs-literal">None</span></span>):</span><br>        self.images_path = images_path<br>        self.images_class = images_class<br>        self.transform = transform<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.images_path)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, item</span>):</span><br>        img = Image.<span class="hljs-built_in">open</span>(self.images_path[item])<br>        <span class="hljs-comment"># RGB为彩色图片，L为灰度图片</span><br>        <span class="hljs-keyword">if</span> img.mode != <span class="hljs-string">&#x27;RGB&#x27;</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;image: &#123;&#125; isn&#x27;t RGB mode.&quot;</span>.<span class="hljs-built_in">format</span>(self.images_path[item]))<br>        label = self.images_class[item]<br><br>        <span class="hljs-keyword">if</span> self.transform <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            img = self.transform(img)<br>        <span class="hljs-keyword">return</span> img, label<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">collate_fn</span>(<span class="hljs-params">batch</span>):</span><br>        <span class="hljs-comment"># 官方实现的default_collate可以参考</span><br>        <span class="hljs-comment"># https://github.com/pytorch/pytorch/blob/67b7e751e6b5931a9f45274653f4f653a4e6cdf6/torch/utils/data/_utils/collate.py</span><br>        images, labels = <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">zip</span>(*batch))<br><br>        images = torch.stack(images, dim=<span class="hljs-number">0</span>)<br>        labels = torch.as_tensor(labels)<br>        <span class="hljs-keyword">return</span> images, labels<br></code></pre></td></tr></table></figure><ol start="3"><li>main.py</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><br><span class="hljs-keyword">from</span> my_dataset <span class="hljs-keyword">import</span> MyDataSet<br><span class="hljs-keyword">from</span> utils <span class="hljs-keyword">import</span> read_split_data, plot_data_loader_image<br><br><span class="hljs-comment"># http://download.tensorflow.org/example_images/flower_photos.tgz</span><br>root = <span class="hljs-string">&quot;/home/wz/my_github/data_set/flower_data/flower_photos&quot;</span>  <span class="hljs-comment"># 数据集所在根目录</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;using &#123;&#125; device.&quot;</span>.<span class="hljs-built_in">format</span>(device))<br><br>    train_images_path, train_images_label, val_images_path, val_images_label = read_split_data(root)<br><br>    data_transform = &#123;<br>        <span class="hljs-string">&quot;train&quot;</span>: transforms.Compose([transforms.RandomResizedCrop(<span class="hljs-number">224</span>),<br>                                     transforms.RandomHorizontalFlip(),<br>                                     transforms.ToTensor(),<br>                                     transforms.Normalize([<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>], [<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])]),<br>        <span class="hljs-string">&quot;val&quot;</span>: transforms.Compose([transforms.Resize(<span class="hljs-number">256</span>),<br>                                   transforms.CenterCrop(<span class="hljs-number">224</span>),<br>                                   transforms.ToTensor(),<br>                                   transforms.Normalize([<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>], [<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])])&#125;<br><br>    train_data_set = MyDataSet(images_path=train_images_path,<br>                               images_class=train_images_label,<br>                               transform=data_transform[<span class="hljs-string">&quot;train&quot;</span>])<br><br>    batch_size = <span class="hljs-number">8</span><br>    nw = <span class="hljs-built_in">min</span>([os.cpu_count(), batch_size <span class="hljs-keyword">if</span> batch_size &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>, <span class="hljs-number">8</span>])  <span class="hljs-comment"># number of workers</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Using &#123;&#125; dataloader workers&#x27;</span>.<span class="hljs-built_in">format</span>(nw))<br>    train_loader = torch.utils.data.DataLoader(train_data_set,<br>                                               batch_size=batch_size,<br>                                               shuffle=<span class="hljs-literal">True</span>,<br>                                               num_workers=nw,<br>                                               collate_fn=train_data_set.collate_fn)<br><br>    <span class="hljs-comment"># plot_data_loader_image(train_loader)</span><br><br>    <span class="hljs-keyword">for</span> step, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>        images, labels = data<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>分布式训练2种模式：</p><img src="/images/image-20220114095812979.png" alt="image-20220114095812979" style="zoom:80%;"><blockquote><ol><li>model parallel适用于训练超大模型，训练速度上无提升；</li><li>data parallel适用于速度提升</li></ol></blockquote><p>Pytorch提供<code>DistributedDataParallel</code>方法，“多进程”，可工作在单机、多机情况。</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning-Objects Detection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>制作自己的数据集1--图像分类</title>
    <link href="/2022/01/14/%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%861-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/"/>
    <url>/2022/01/14/%E5%88%B6%E4%BD%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%861-%E5%9B%BE%E5%83%8F%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>ImageFolder、csv方法、json方法（普适，分布式训练）</p><p>本系列目的是记录代码，供需要时查阅</p><span id="more"></span><p>构建自己的Dataset类，必须遵循的思路：Pytorch官方给出的指引</p><blockquote><p>1.继承torch.utils.data.Dataset</p><p>2.实现两个方法：<code>__len__</code>、<code>__getitem__</code></p></blockquote><h3 id="一、图像分类–自己的图片"><a href="#一、图像分类–自己的图片" class="headerlink" title="一、图像分类–自己的图片"></a>一、图像分类–自己的图片</h3><h4 id="方法一：ImageFolder"><a href="#方法一：ImageFolder" class="headerlink" title="方法一：ImageFolder"></a>方法一：ImageFolder</h4><p>每类一个文件夹，读取的同时用transforms</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">每类一个文件夹</span><br><span class="hljs-string">读取的同时用transforms</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> torchvision.datasets <span class="hljs-keyword">import</span> ImageFolder<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><br>trans = transforms.Compose([<br>    transforms.RandomCrop(<span class="hljs-number">180</span>),<br>    transforms.RandomHorizontalFlip(),<br>    transforms.ToTensor(), <span class="hljs-comment">#将图片转换为Tensor,归一化至[0,1]</span><br>    transforms.Normalize(mean=[<span class="hljs-number">.5</span>,<span class="hljs-number">.5</span>,<span class="hljs-number">.5</span>],std=[<span class="hljs-number">.5</span>,<span class="hljs-number">.5</span>,<span class="hljs-number">.5</span>])<br>])<br><br>dataset=ImageFolder(<span class="hljs-string">&#x27;./data/train&#x27;</span>,transform=trans)<br>train_loader = torch.utils.data.DataLoader(dataset=dataset, batch_size=<span class="hljs-number">32</span>, shuffle=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># dataset的结构：[(img_data,class_id),(img_data,class_id),…]</span><br><span class="hljs-comment"># print(dataset[0])</span><br><span class="hljs-comment"># print(dataset[0][0])# 第一张图片的图片矩阵</span><br><span class="hljs-comment"># print(dataset[0][1])# 第一张图片的标签</span><br><span class="hljs-comment"># print(dataset.classes)</span><br><span class="hljs-comment"># print(dataset.class_to_idx)</span><br></code></pre></td></tr></table></figure><h4 id="方法二：csv–-gt-Dataset"><a href="#方法二：csv–-gt-Dataset" class="headerlink" title="方法二：csv–&gt;Dataset"></a>方法二：csv–&gt;Dataset</h4><h5 id="1-open-参数"><a href="#1-open-参数" class="headerlink" title="1. open( )参数"></a>1. open( )参数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">open</span>(file, mode=<span class="hljs-string">&#x27;r&#x27;</span>, buffering=-<span class="hljs-number">1</span>, encoding=<span class="hljs-literal">None</span>, errors=<span class="hljs-literal">None</span>, newline=<span class="hljs-literal">None</span>, closefd=<span class="hljs-literal">True</span>, opener=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>mode参数：</p><img src="/images/image-mode" alt="image-20220113203844304" style="zoom: 80%;"><h5 id="2-由图片文件夹构建-csv"><a href="#2-由图片文件夹构建-csv" class="headerlink" title="2. 由图片文件夹构建.csv"></a>2. 由图片文件夹构建.csv</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">实际图片数据</span><br><span class="hljs-string">制作csv文件</span><br><span class="hljs-string">进而由csv文件制作自己的Dataset</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">import</span> os, glob<br><span class="hljs-keyword">import</span> csv<br><br>class_to_num = &#123;&#125;<br><br><span class="hljs-comment"># 获取类别名字列表</span><br>class_name_list = os.listdir(<span class="hljs-string">&quot;mydata&quot;</span>)<span class="hljs-comment"># 数据集存储在mydata文件夹中</span><br><br><span class="hljs-comment"># 为每个类别赋一个值：0，1，2... </span><br><span class="hljs-keyword">for</span> class_name <span class="hljs-keyword">in</span> class_name_list:<br>class_to_num[class_name] = <span class="hljs-built_in">len</span>(class_to_num.keys())<br><br><span class="hljs-comment"># 获取数据图片的路径</span><br>image_dir = []<br><span class="hljs-keyword">for</span> class_name <span class="hljs-keyword">in</span> class_name_list:<br>image_dir += glob.glob(os.path.join(<span class="hljs-string">&#x27;mydata&#x27;</span>, class_name, <span class="hljs-string">&#x27;*.jpg&#x27;</span>))<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">glob.glob()是很好用的文件全提函数</span><br><span class="hljs-string">常用于深度学习数据集的构建</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># glob.glob(&#x27;data/train/*&#x27;)</span><br><span class="hljs-comment"># 可获取train文件夹下所有文件的路径，构成一个列表</span><br><br><br><span class="hljs-comment"># 生成csv文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;myself_data.csv&#x27;</span>, mode=<span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br><span class="hljs-comment"># 文件名传给csv写函数  </span><br>writer = csv.writer(f)<br><span class="hljs-keyword">for</span> image <span class="hljs-keyword">in</span> image_dir:<br><span class="hljs-comment"># 获取类别名</span><br>class_name = image.split(os.sep)[-<span class="hljs-number">2</span>]<span class="hljs-comment"># os.sep指系统的分隔符，windows是\，Linux是/</span><br><span class="hljs-comment"># 获取类别名对应的数字</span><br>label = class_to_num[class_name]<br><span class="hljs-comment"># 写入csv：路径 + 类别数字 组成一行 </span><br>writer.writerow([image, label])<span class="hljs-comment">#路径 + 类别数字</span><br><br><span class="hljs-comment"># 可选择将数据的顺序打乱</span><br><span class="hljs-keyword">import</span> random<br>random.shuffle(image_dir)<br></code></pre></td></tr></table></figure><h5 id="3-基于-csv构建自己的Dataset"><a href="#3-基于-csv构建自己的Dataset" class="headerlink" title="3. 基于.csv构建自己的Dataset"></a>3. 基于.csv构建自己的Dataset</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 接下来制作自己的Dataset</span><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">import</span> csv<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">myDataset</span>(<span class="hljs-params">Dataset</span>):</span><span class="hljs-comment"># 继承pytorch的dataset</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, csv_filename, resize, mode</span>):</span><br><span class="hljs-built_in">super</span>(myDataset, self).__init__()<br><br>self.csv_filename = csv_filename<br>self.resize = resize<br>self.image, self.label = self.load_csv()<br><br><span class="hljs-comment"># 此处仍在操作路径</span><br><span class="hljs-keyword">if</span> mode == <span class="hljs-string">&#x27;train&#x27;</span>: <span class="hljs-comment"># 60%训练</span><br>self.image = self.image[:<span class="hljs-built_in">int</span>(<span class="hljs-number">0.6</span> * <span class="hljs-built_in">len</span>(self.image))]<br>self.label = self.label[:<span class="hljs-built_in">int</span>(<span class="hljs-number">0.6</span> * <span class="hljs-built_in">len</span>(self.label))]<br><span class="hljs-keyword">elif</span> mode == <span class="hljs-string">&#x27;val&#x27;</span>: <span class="hljs-comment"># 20%验证</span><br>self.image = self.image[<span class="hljs-built_in">int</span>(<span class="hljs-number">0.6</span> * <span class="hljs-built_in">len</span>(self.image)):<span class="hljs-built_in">int</span>(<span class="hljs-number">0.8</span> * <span class="hljs-built_in">len</span>(self.image))]<br>self.label = self.label[<span class="hljs-built_in">int</span>(<span class="hljs-number">0.6</span> * <span class="hljs-built_in">len</span>(self.label)):<span class="hljs-built_in">int</span>(<span class="hljs-number">0.8</span> * <span class="hljs-built_in">len</span>(self.label))]<br><span class="hljs-keyword">else</span>:<span class="hljs-comment"># 20%测试</span><br>self.image = self.image[<span class="hljs-built_in">int</span>(<span class="hljs-number">0.8</span> * <span class="hljs-built_in">len</span>(self.image)):]<br>self.label = self.label[<span class="hljs-built_in">int</span>(<span class="hljs-number">0.8</span> * <span class="hljs-built_in">len</span>(self.label)):]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_csv</span>(<span class="hljs-params">self</span>):</span><br>image, label = [], []<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(self.csv_filename) <span class="hljs-keyword">as</span> f:<br>reader = csv.reader(f)<br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader:<br>i, l = row<br>image.append(i)<br>label.append(<span class="hljs-built_in">int</span>(l))<br><span class="hljs-keyword">return</span> image, label<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.image)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, idx</span>):</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">transforms对PIL图像操作</span><br><span class="hljs-string">要么直接用PIL读图像</span><br><span class="hljs-string">要么用cv2读图像，先转PIL格式</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 1. 直接用PIL读取</span><br><span class="hljs-comment"># img = Image.open(self.iamge[idx])# 不使用lambda函数</span><br><span class="hljs-comment"># img = trans(img)</span><br>trans = transforms.Compose([<span class="hljs-keyword">lambda</span> x:Image.<span class="hljs-built_in">open</span>(x).convert(<span class="hljs-string">&#x27;RGB&#x27;</span>),<span class="hljs-comment"># PIL库读取图片</span><br>transforms.Resize(self.resize),<span class="hljs-comment"># resize</span><br>transforms.ToTensor(),<span class="hljs-comment"># 转换为tensor</span><br>transforms.Normalize(mean=[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>], std=[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])])<br><br><span class="hljs-comment"># 2. 用cv2读，在transform前转PIL</span><br>trans = transforms.Compose([transforms.ToPILImage(),<span class="hljs-comment"># 转PIL格式</span><br>transforms.Resize(self.resize),<span class="hljs-comment"># resize</span><br>transforms.ToTensor(),<span class="hljs-comment"># 转换为tensor</span><br>transforms.Normalize(mean=[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>], std=[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])])<br><br>image_tensor = trans(self.image[idx])<br>label_tensor = torch.tensor(self.label[idx])<br> <br><span class="hljs-keyword">return</span> image_tensor, label_tensor<br><br>train_db = myDataset(<span class="hljs-string">&#x27;myself_data.csv&#x27;</span>, <span class="hljs-number">128</span>, <span class="hljs-string">&#x27;train&#x27;</span>)<br><br>train_loader = DataLoader(train_db, batch_size=<span class="hljs-number">4</span>)<br><span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> train_loader:<br><span class="hljs-built_in">print</span>(x.shape)<br><span class="hljs-built_in">print</span>(y.shape)<br></code></pre></td></tr></table></figure><h4 id="方法三：json–-gt-Dataset（适用于多GPU训练）"><a href="#方法三：json–-gt-Dataset（适用于多GPU训练）" class="headerlink" title="方法三：json–&gt;Dataset（适用于多GPU训练）"></a>方法三：json–&gt;Dataset（适用于多GPU训练）</h4><p>见下一篇</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning-Objects Detection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GAN入门篇</title>
    <link href="/2022/01/13/GAN%E5%85%A5%E9%97%A8%E7%AF%87/"/>
    <url>/2022/01/13/GAN%E5%85%A5%E9%97%A8%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p>本节介绍GAN最基本的知识，理解对抗生成的数学过程</p><p>从GAN的JS Divergence → WGAN的Wasserstein Distance</p><span id="more"></span><h2 id="GAN入门篇"><a href="#GAN入门篇" class="headerlink" title="GAN入门篇"></a>GAN入门篇</h2><h3 id="1-数学推导"><a href="#1-数学推导" class="headerlink" title="1. 数学推导"></a>1. 数学推导</h3><img src="/images/image-20220113113624666.png" alt="image-20220113113624666" style="zoom:67%;"><img src="/images/image-20220113113635910.png" alt="image-20220113113635910" style="zoom:67%;"><h3 id="2-DCGAN"><a href="#2-DCGAN" class="headerlink" title="2.DCGAN"></a>2.DCGAN</h3><h4 id="转置卷积"><a href="#转置卷积" class="headerlink" title="转置卷积"></a>转置卷积</h4><p>普通卷积：输入维度下采样，最多也只能保持维度；</p><p>转置卷积：输入维度上采样，最早用在图像语义分割网络FCN中。Transposed conv / Deconv</p><p>​            有时被称为反卷积，其实不够恰当，因为转置卷积只能恢复图像尺寸，不能恢复原始值！严格来说不是逆运算。</p><img src="/images/image-20220113100615815.png" alt="image-20220113100615815" style="zoom:67%;"><p>输入的每个像素和kernel逐元素相乘，形成一个矩阵，即input的每一个像素→kernel大小的矩阵。</p><p>stride：上述小矩阵以什么步长在output上堆叠，不是卷积核的滑动步长！</p><p>padding：使输出维度减小！padding=1表示把输出的最外层一圈删除掉</p><p>注：在pytorch等框架中，使用和卷积<strong>相同的超参数</strong>，即可将尺寸还原</p><h3 id="3-问题"><a href="#3-问题" class="headerlink" title="3.问题"></a>3.问题</h3><p>traning stability</p><p>一开始当Generator分布与真实分布没有overlap时是很难训练的，存在严重的<strong>梯度消失</strong>问题，推导和JS Divergence有关，暂略。<br>说明JS Divergence作为优化目标是不宜的，需要新的优化思路：</p><p>Earth‘s Mover’s Distance，即将P分布转换为Q分布？</p><img src="/images/image-20220113103411865.png" alt="image-20220113103411865" style="zoom:50%;"><h3 id="4-WGAN"><a href="#4-WGAN" class="headerlink" title="4. WGAN"></a>4. WGAN</h3><p>WGAN采用的优化目标——Wasserstein Distance</p><img src="/images/image-20220113103502372.png" alt="image-20220113103502372" style="zoom:67%;"><p>添加惩罚项</p><img src="/images/image-20220113110921657.png" alt="image-20220113110921657" style="zoom:67%;">]]></content>
    
    
    <categories>
      
      <category>Deep Learning-GAN</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python爬虫</title>
    <link href="/2021/08/27/Python%E7%88%AC%E8%99%AB/"/>
    <url>/2021/08/27/Python%E7%88%AC%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<p>本文记录python爬虫学习笔记，重点是掌握数据解析的三种方法：Re正则、Bs4、Xpath， 以及浏览器抓包工具的使用，更深入的实战需要后面继续学习~</p><span id="more"></span><p>视频教程：<a href="https://www.bilibili.com/video/BV1i54y1h75W?p=46">2021年最新Python爬虫教程+实战项目案例（最新录制）_哔哩哔哩_bilibili</a></p><h3 id="Web请求全过程"><a href="#Web请求全过程" class="headerlink" title="Web请求全过程"></a>Web请求全过程</h3><p>1.服务器渲染：在服务器(如百度服务器)那边直接把检索的数据和html源代码整合在一起，返回给本机浏览器</p><p>​                        在页面源代码中能看到数据</p><p>2.客户端渲染：数据和html源代码的结合在客户端发生</p><p>​                        在页面源代码中看不到数据；</p><p>​                        客户端在第二次发生请求时，才请求数据，所以要想获得数据，须熟练使用浏览器抓包工具</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>http：超文本传输协议        html：超文本标记语言</p><img src="/images/image-20210821212712231.png" alt="image-20210821212712231" style="zoom:67%;"><img src="/images/image-20210821212512322.png" alt="image-20210821212512322" style="zoom: 67%;"><h3 id="请求Request入门"><a href="#请求Request入门" class="headerlink" title="请求Request入门"></a>请求<code>Request</code>入门</h3><p>请求有两种方式：</p><p>(1)<code>Get</code>： 参数直接拼接在url中，url中<code>?</code>后面即为参数        <code>requests.get(url)</code></p><p>​                url后面的一长串参数也可放在字典中，通过params参数传递：    <code>requests.get(url, params=dic)</code></p><p>​                反爬技巧之一：伪装<code>User-Agent</code>，通过<code>headers</code>参数传递：         <code>requests.get(url, headers=dic)</code></p><p>(2)<code>Post</code>：发送的数据必须放在字典中，通过data参数进行传递        <code>requests.post(url, data = dic)</code></p><p>1.第一个反爬小程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>url = <span class="hljs-string">&quot;http://www.sogou.com/web?query=周杰伦&quot;</span><br><br>resp = requests.get(url)<br><span class="hljs-built_in">print</span>(resp.text)<span class="hljs-comment"># 打印页面源代码.text</span><br></code></pre></td></tr></table></figure><p>这种情况下会出错，因为网站有反爬机制，会检查发送http请求的用户，即检查<code>User-Agent</code>字段，如果<code>User-Agent</code>不是浏览器，则会阻止http请求；</p><p>所以要伪装成浏览器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>url = <span class="hljs-string">&quot;http://www.sogou.com/web?query=周杰伦&quot;</span><br><br>header = &#123;<span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36 Edg/92.0.902.78&quot;</span>&#125;<br><br>resp = requests.get(url, headers=header)<span class="hljs-comment"># 修改请求标头中的User-Agent字段，伪装浏览器</span><br><span class="hljs-built_in">print</span>(resp.text)<span class="hljs-comment"># 打印页面源代码.text</span><br><br>resp.close()<span class="hljs-comment"># 爬取完毕后，关闭请求！</span><br></code></pre></td></tr></table></figure><p>一般来说，同一台计算机下同一个浏览器发出的请求，<code>User-Agent</code>字段是不变的。</p><p><img src="/images/image-20210821214645162.png" alt="image-20210821214645162"></p><p>2.熟练使用抓包工具<code>F12</code></p><p>可以选择文件类型，<code>XHR</code>一般是二次请求数据的包，比较有用</p><h3 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a>数据解析</h3><img src="/.com//Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210822084011571.png" alt="image-20210822084011571" style="zoom:80%;"><h4 id="一、Re解析-正则表达式"><a href="#一、Re解析-正则表达式" class="headerlink" title="一、Re解析 正则表达式"></a>一、Re解析 正则表达式</h4><p>在线正则表达式测试：<a href="https://tool.oschina.net/regex">在线正则表达式测试 (oschina.net)</a></p><p>正则的语法：使用元字符进行排列组合来匹配字符串；一个元字符对应字符串的一位。</p><p>1.元字符</p><p><img src="/images/image-20210822084548021.png" alt="image-20210822084548021"></p><p><code>^</code>表示字符串必须以正则中的表达式开头，<code>$</code>表示必须以正则中的表达式结尾</p><p><code>[...]</code>表示字符组，即字符串中只要有字符组中的字符，就匹配出来，一般字符组包括所有英文字母、数字等可以写作如下：<code>[a-zA-Z0-9]</code>        在字符组前加<code>^</code>表示非，除了字符组中的都能匹配</p><p>2.量词</p><p><img src="/images/image-20210822085621575.png" alt="image-20210822085621575"></p><p>搭配元字符使用，如<code>\d*</code>表示数字出现零次或更多次</p><p>3.贪婪匹配、惰性匹配</p><p><img src="/images/image-20210822085805932.png" alt="image-20210822085805932"></p><p>贪婪匹配：“尽可能长”地匹配</p><p>惰性匹配：“尽可能短”地匹配</p><p>4.python的Re模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br><span class="hljs-comment"># findall：匹配所有内容，返回列表</span><br><br><span class="hljs-comment"># finditer:匹配字符串中所有的内容，返回迭代器（最常用）</span><br>it = re.finditer(<span class="hljs-string">r&#x27;\d+&#x27;</span>, <span class="hljs-string">&quot;我的电话号是：10086&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> it:<br>    <span class="hljs-built_in">print</span>(i.group())<span class="hljs-comment"># match对象，需要通过group拿到文本</span><br>    <br><span class="hljs-comment"># search：找到一个结果就返回，返回match对象</span><br><br><span class="hljs-comment"># match：必须从头开始匹配</span><br><br><span class="hljs-comment"># 预加载正则表达式：</span><br>obj = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;\d+&#x27;</span>)<br>ret = obj.finditer(<span class="hljs-string">&quot;我的电话号是：10086&quot;</span>)<br></code></pre></td></tr></table></figure><p>如何取出正则匹配出的语句内的内容（再过滤一层）：</p><p><img src="/images/image-20210822100116497.png" alt="image-20210822100116497"></p><p>给要提取的内容加括号，然后用<code>?P&lt;分组名字&gt;</code>添加别名； 然后就可以在<code>group()</code>中添加别名以获得具体内容</p><p>5.实战项目——手刃豆瓣top 250电影</p><p>（1）首先确定页面的内容是否在页面源代码中：</p><p>​            如果在，则直接抓取页面源代码，然后用正则表达式提取需要的数据；</p><p>​            如果不在，则要用抓包工具查看第二次请求的url</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> csv<br><br><span class="hljs-comment"># 获取数据</span><br>url = <span class="hljs-string">&quot;https://movie.douban.com/top250&quot;</span><br>header = &#123;<span class="hljs-string">&quot;user-agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36 Edg/92.0.902.78&quot;</span>&#125;<br>resp = requests.get(url, headers=header)<br>page_content = resp.text<br><br><span class="hljs-comment"># 解析数据</span><br><span class="hljs-comment"># 正则表达式用单引号</span><br>obj = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;li&gt;.*?&lt;span class=&quot;title&quot;&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;.*?&lt;br&gt;\s*(?P&lt;year&gt;.*?)&amp;nbsp&#x27;</span>, re.S)<span class="hljs-comment"># re.S让.能匹配空白</span><br>result = obj.finditer(page_content)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> result:<br>    <span class="hljs-built_in">print</span>(i.group(<span class="hljs-string">&quot;name&quot;</span>))<br>    <span class="hljs-built_in">print</span>(i.group(<span class="hljs-string">&quot;year&quot;</span>))<br><br><span class="hljs-comment"># 存储数据csv</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;data.csv&quot;</span>, mode=<span class="hljs-string">&quot;w&quot;</span>)<span class="hljs-comment"># 准备一个csv文件</span><br>csv_writer = csv.writer(f)<span class="hljs-comment"># 准备一个笔</span><br><span class="hljs-keyword">for</span> it <span class="hljs-keyword">in</span> result:<br>    dic = it.groupdict()<span class="hljs-comment"># 把数据整理成字典格式，re模块的.groupdict()方法</span><br>    csv_writer.writerow(dic.values())<span class="hljs-comment"># 把字典中的values写入</span><br>f.close()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;over!&#x27;</span>)<br></code></pre></td></tr></table></figure><p>假设要提取下面这些信息：</p><p><img src="/images/image-20210822101335168.png" alt="image-20210822101335168"></p><p>写正则表达式时，必须配合查看页面源代码：</p><p>（1）从哪里开始匹配：一般都取需要内容处的前几级标签；</p><p>（2）哪些内容是不用的：用<code>.*?</code>代替</p><img src="/images/image-20210822101811242.png" alt="image-20210822101811242" style="zoom: 67%;"><p>拓展：上述只爬取了第一页的内容，若要爬取所有页面的内容，则只需要添加查询参数然后遍历循环即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">爬取排行榜全部250部电影</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># TODO：关键在于，理解不同页面的参数，通过抓包工具获取参数，并用params传参</span><br><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> csv<br><br>param=[&#123;<span class="hljs-string">&quot;start&quot;</span>: i,<br><span class="hljs-string">&quot;filter&quot;</span>: <span class="hljs-string">&quot;&quot;</span>&#125; <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">250</span>, <span class="hljs-number">25</span>)]     <span class="hljs-comment"># 抓包工具获取的参数</span><br><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;top250_all.csv&quot;</span>, mode=<span class="hljs-string">&quot;w&quot;</span>)    <span class="hljs-comment"># 准备一个csv文件</span><br>csvwriterss = csv.writer(f)    <span class="hljs-comment"># 准备一个笔</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    url = <span class="hljs-string">&quot;https://movie.douban.com/top250&quot;</span>     <span class="hljs-comment"># url只传基本的，参数通过params另传</span><br>    header = &#123;<br>        <span class="hljs-string">&quot;user-agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36 Edg/92.0.902.78&quot;</span>&#125;<br>    param_i = param[i]<br>    resp = requests.get(url, headers=header, params=param_i)<br>    page_content = resp.text<br><br>    <span class="hljs-comment"># 解析数据</span><br>    obj = re.<span class="hljs-built_in">compile</span>(<br>        <span class="hljs-string">r&#x27;&lt;li&gt;.*?&lt;span class=&quot;title&quot;&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;.*?&lt;br&gt;\s*(?P&lt;year&gt;.*?)&amp;nbsp.*?&quot;v:average&quot;&gt;(?P&lt;score&gt;.*?)&lt;/span&gt;&#x27;</span>,<br>        re.S)  <span class="hljs-comment"># re.S让.能匹配空白</span><br>    result = obj.finditer(page_content)<br><br>    <span class="hljs-keyword">for</span> it <span class="hljs-keyword">in</span> result:<br>        dic = it.groupdict()  <span class="hljs-comment"># 把数据整理成字典格式，re模块的.groupdict()方法</span><br>        <span class="hljs-built_in">print</span>(dic.values())<br>        csvwriterss.writerow(dic.values())  <span class="hljs-comment"># 把字典中的values写入</span><br><br>f.close()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;over!&#x27;</span>)<br></code></pre></td></tr></table></figure><p>抓包工具获取查询参数：</p><p><img src="/images/image-20210822111127257.png" alt="image-20210822111127257"></p><p>6.实战项目——手刃盗版电影天堂网站信息</p><p>任务：定位到“2021必看热片”，从中提取出子页面的链接地址</p><p>储备知识：在html中，a标签表示超链接 <code>&lt;a href=&#39;url&#39;&gt;周杰伦&lt;/a&gt;</code>    那么点击周杰伦，就会跳转到<code>url</code></p><p>​                  所以子页面链接就是<code>href</code>中的东西</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> csv<br><br><span class="hljs-comment"># 获取数据</span><br>url = <span class="hljs-string">&quot;https://dytt89.com&quot;</span><br>header = &#123;<span class="hljs-string">&quot;user-agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36 Edg/92.0.902.78&quot;</span>&#125;<br>resp = requests.get(url, headers=header)<br>resp.encoding = <span class="hljs-string">&quot;gb2312&quot;</span><span class="hljs-comment"># 默认用utf-8编码，当网站使用其它类型时，必须显式指定</span><br>  <span class="hljs-comment"># gb2312 = gbk， 都是国标码</span><br>page_content = resp.text<br><span class="hljs-built_in">print</span>(page_content)<br><br><span class="hljs-comment"># 解析数据</span><br>obj1 = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;2021必看热片.*?&lt;ul&gt;(?P&lt;uull&gt;.*?)&lt;/ul&gt;&#x27;</span>, re.S)<span class="hljs-comment"># re.S让.能匹配空白</span><br>obj2 = re.compile(r&#x27;&lt;a href=&#x27;(?P&lt;href&gt;.*?)&#x27;&#x27;, re.S)<br>result = obj.finditer(page_content)<br><span class="hljs-keyword">for</span> it <span class="hljs-keyword">in</span> result:<br>    ul = it.group(<span class="hljs-string">&quot;uull&quot;</span>)<br>    <span class="hljs-built_in">print</span>(ul)<br>    <br>    <span class="hljs-comment"># 提取子页面链接：href中的内容</span><br>    result2 = obj2.finditer(ul)<br>    <span class="hljs-keyword">for</span> it2 <span class="hljs-keyword">in</span> result2:<br>        <span class="hljs-comment"># 拼接子页面url地址： 域名 + 子页面地址，拼之前把链接前的/去掉 （有些网站不需要拼接） </span><br>        child_href = domain + it2.group(<span class="hljs-string">&quot;href&quot;</span>).strip(<span class="hljs-string">&#x27;/&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(child_href)<br></code></pre></td></tr></table></figure><h4 id="二、Bs4解析"><a href="#二、Bs4解析" class="headerlink" title="二、Bs4解析"></a>二、Bs4解析</h4><p>需要首先了解html语法，用Bs4时和html标签紧密相关。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;标签 属性=&quot;属性值&quot;&gt;被标记内容&lt;/标签&gt;<br><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;xxx.jpg&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><br>url = <span class="hljs-string">&quot;xxx&quot;</span><br>resp = requests.get(url)<br><br><span class="hljs-comment"># 解析数据</span><br><span class="hljs-comment"># 1.把页面源代码交给BeautifulSoup进行处理，生成bs对象</span><br>page = BeautifulSoup(resp.text, <span class="hljs-string">&quot;html.parser&quot;</span>)<span class="hljs-comment"># 指定html解析器</span><br><span class="hljs-comment"># 2.从bs对象种查找数据</span><br><span class="hljs-comment"># find(标签，属性=值)</span><br><span class="hljs-comment"># find_all</span><br>table = page.find(&quot;table&quot;, class=&quot;hq_table&quot;)# class是python关键字，会报错！<br>table = page.find(<span class="hljs-string">&quot;table&quot;</span>, class_=<span class="hljs-string">&quot;hq_table&quot;</span>)<span class="hljs-comment"># bs4允许添加下划线以区别</span><br>table = page.find(<span class="hljs-string">&quot;table&quot;</span>, atrrs=&#123;<span class="hljs-string">&quot;class&quot;</span>: <span class="hljs-string">&quot;hq_table&quot;</span>&#125;)<span class="hljs-comment"># 也可传字典来避免</span><br><br><span class="hljs-comment"># html中：tb标签是表格，tr是表格一行，td是一列</span><br><span class="hljs-comment"># 思路：先取出所有行，然后对每一行取列，单个元素就取出来了</span><br>trs = table.find_all(<span class="hljs-string">&quot;tr&quot;</span>)[<span class="hljs-number">1</span>:]<span class="hljs-comment"># 取出所有行</span><br><span class="hljs-keyword">for</span> tr <span class="hljs-keyword">in</span> trs:<span class="hljs-comment"># 遍历每一行</span><br>    tds = tr.find_all(<span class="hljs-string">&quot;td&quot;</span>)<span class="hljs-comment"># 取列</span><br>    name = tds[<span class="hljs-number">0</span>].text<br>    low = tds[<span class="hljs-number">1</span>].text<br>    avg = tds[<span class="hljs-number">2</span>].text<br>    ...<br></code></pre></td></tr></table></figure><img src="/images/image-20210823084354418.png" alt="image-20210823084354418" style="zoom:80%;"><img src="/images/image-20210823085126691.png" alt="image-20210823085126691" style="zoom:80%;"><p>Bs4案例——抓取优美图库的图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 1.拿到主页面源代码，提取子页面链接地址href</span><br>url = <span class="hljs-string">&quot;xxx&quot;</span><br>resp = requests.get(url)<br>resp.encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span><br><br>main_paeg = BeautifulSoup(resp.text, <span class="hljs-string">&quot;html.parser&quot;</span>)<br>alist = main_page.find(<span class="hljs-string">&quot;div&quot;</span>, class_=<span class="hljs-string">&quot;TypeList&quot;</span>).find_all(<span class="hljs-string">&quot;a&quot;</span>)<span class="hljs-comment"># 找到a标签（href）</span><br><span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> alist:<br>    href = a.get(<span class="hljs-string">&#x27;href&#x27;</span>)<span class="hljs-comment"># 通过get拿到属性值</span><br>    <span class="hljs-comment"># 2.拿到子页面源代码</span><br>    child_page_resp = requests.get(href)<br>    child_page_resp.encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span><br>    child_page_text = child_page_resp.text<br>    <span class="hljs-comment"># 3. 从子页面拿到图片下载路径</span><br>    child_page = BeautifulSoup(child_page_text, <span class="hljs-string">&quot;html.parser&quot;</span>)<br>    pp = child_page.find(<span class="hljs-string">&quot;p&quot;</span>, align=<span class="hljs-string">&quot;center&quot;</span>)<span class="hljs-comment"># 用p标签和align属性定位</span><br>    img = pp.find(<span class="hljs-string">&quot;img&quot;</span>)<br>    src = img.get(<span class="hljs-string">&quot;src&quot;</span>)<br>    <span class="hljs-comment"># 4.下载图片</span><br>    <span class="hljs-comment"># 原理：请求图片的下载链接，然后把请求的content写入文件</span><br>    img_resp = requests.get(src)<br>    img_name = src.split(<span class="hljs-string">&quot;/&quot;</span>)[-<span class="hljs-number">1</span>]<span class="hljs-comment"># url中最后一个/后面的内容作为图片名</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(img_name, mode=<span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(img_resp.content)<span class="hljs-comment"># img_resp.content是响应的内容，也即图片的字节</span><br>        <br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;over!&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)<span class="hljs-comment"># 技巧：防止高速request网站</span><br>    <br>    <br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;all over&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="三、Xpath解析"><a href="#三、Xpath解析" class="headerlink" title="三、Xpath解析"></a>三、Xpath解析</h4><p>在xml文档中搜索内容的一门语言；html是xml的一个子集。</p><p>Xpath主要是通过节点间的父子关系来查找节点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><br>tree = etree.parse(<span class="hljs-string">&quot;b.html&quot;</span>)<span class="hljs-comment"># 解析xml</span><br>result = tree.xpath()<span class="hljs-comment"># /表示根标签；  //表示后代   /*/ 通配符</span><br>  <span class="hljs-comment"># text()表示取文本</span><br>  <span class="hljs-comment"># li[1]表示索引；xpath的索引从1开始！</span><br>           <span class="hljs-comment"># li[@href=&#x27;dapao&#x27;]也表示索引；@表示对属性值的筛选</span><br>               <span class="hljs-comment"># ./表示相对，从当前节点出发</span><br>                   <span class="hljs-comment"># @href表示获取标签中的属性值</span><br>                    <br>result = tree.xpath(<span class="hljs-string">&quot;/html/body/ol/li[1]/a/text()&quot;</span>)<br>result = tree.xpath(<span class="hljs-string">&quot;/html/body/ol/li/a[@href=&#x27;dapao&#x27;]/text()&quot;</span>)<br><br>result = tree.xpath(<span class="hljs-string">&quot;/html/body/ol/li&quot;</span>)<br><span class="hljs-keyword">for</span> li <span class="hljs-keyword">in</span> result:<br>     result2 = li.xpath(<span class="hljs-string">&quot;./a/text()&quot;</span>)<span class="hljs-comment"># 相对查找</span><br>     result3 = li.xpath(<span class="hljs-string">&quot;./a/@href&quot;</span>)<span class="hljs-comment"># 取a标签的href属性值</span><br></code></pre></td></tr></table></figure><img src="/images/image-20210823100032045.png" alt="image-20210823100032045" style="zoom: 67%;"><p>1.Xpath实战——爬取猪八戒网信息</p><p>善用技巧：使用浏览器的抓包工具，动态定位指定块的内容，并右键复制Xpath路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><br>url = <span class="hljs-string">&quot;&quot;</span><br>resp = requests.get(url)<br><br><span class="hljs-comment"># 解析数据</span><br>html = etree.HTML(resp.text)<br><br></code></pre></td></tr></table></figure><h3 id="Requests进阶"><a href="#Requests进阶" class="headerlink" title="Requests进阶"></a>Requests进阶</h3><img src="/images/image-20210823105629767.png" alt="image-20210823105629767" style="zoom: 67%;"><h4 id="1-处理cookie"><a href="#1-处理cookie" class="headerlink" title="1.处理cookie"></a>1.处理<code>cookie</code></h4><p>cookie机制：第一次发送（用户登录）后服务器会返回cookie，后续请求须发送cookie。</p><img src="/images/image-20210823111034675.png" alt="image-20210823111034675" style="zoom:67%;"><p>模拟用户登录的方法：</p><p><img src="/images/image-20210823111126948.png" alt="image-20210823111126948"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>session = requests.session()<span class="hljs-comment"># 发起一个session (会话)</span><br>data=&#123;<br>    <span class="hljs-string">&quot;xxx&quot;</span>:xxx<br>    <span class="hljs-string">&quot;Xxx&quot;</span>:xxx<br>&#125;<span class="hljs-comment"># 抓包工具获得参数</span><br><br><span class="hljs-comment"># 1.登录</span><br>url = <span class="hljs-string">&quot;&quot;</span><br>session.post(url, data=data)<br><br><span class="hljs-comment"># 2.拿数据</span><br>resp = session.get(url2)<span class="hljs-comment"># 继续使用刚才的session，这个session中是有cookie的</span><br></code></pre></td></tr></table></figure><h4 id="2-处理防盗链——抓取梨视频"><a href="#2-处理防盗链——抓取梨视频" class="headerlink" title="2.处理防盗链——抓取梨视频"></a>2.处理防盗链——抓取梨视频</h4><p>初期流程：</p><p>查看页面源代码，发现源码中没有视频地址 —&gt; 所以网站是通过“二次请求”获取数据 —&gt; 抓包工具，到<code>XHR</code>中找二次请求数据包：</p><p><img src="/images/image-20210823113849372.png" alt="image-20210823113849372"></p><p>—&gt; 该数据包才是后续处理的对象 —&gt; 请求了另一个URL叫<code>videoStatus</code>，下面还有<code>cookie</code>、<code>Referer</code>等信息。</p><p>梨视频对视频url进行了反爬处理，将其中的<code>contId</code>替换为了<code>SystemTime</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1.拿到contId</span><br><span class="hljs-comment"># 2.拿到videoStatus中的视频srcURL</span><br><span class="hljs-comment"># 3.srcURL里面的内容进行修整</span><br><span class="hljs-comment"># 4.下载视频</span><br><br>url = <span class="hljs-string">&quot;https://www.pearvideo.com/video_1736704&quot;</span><br>contId = url.split(<span class="hljs-string">&quot;_&quot;</span>)[<span class="hljs-number">1</span>]<br><br>videoStatusURL = <span class="hljs-string">f&quot;https://www.pearvideo.com/videoStatus.jsp?contId=<span class="hljs-subst">&#123;contId&#125;</span>&amp;mrd=0.5904034213944991&quot;</span><br><br><span class="hljs-comment"># 配置一些参数(常规反爬)</span><br>headers = &#123;<br>    <span class="hljs-string">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36 Edg/92.0.902.78&quot;</span><br>    <span class="hljs-comment"># 防盗链：溯源</span><br>    <span class="hljs-string">&quot;Referer&quot;</span>: <span class="hljs-string">&quot;https://www.pearvideo.com/video_1736704&quot;</span><br>&#125;<br><br><span class="hljs-comment"># 2.拿到videoStatus中的视频srcURL</span><br>resp = requests.get(videoStatusURL, headers=headers)<br>dic = resp.json()<br>srcURL = dic[<span class="hljs-string">&#x27;videoInfo&#x27;</span>][<span class="hljs-string">&#x27;videos&#x27;</span>][<span class="hljs-string">&#x27;srcUrl&#x27;</span>]<br>systemTime = dic[<span class="hljs-string">&#x27;systemTime&#x27;</span>]<br><br><span class="hljs-comment"># 3.修整：使用python字符串的replace方法</span><br>srcURL = srcURL.replace(systemTime, <span class="hljs-string">f&quot;cont-<span class="hljs-subst">&#123;contId&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 4.下载视频</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;a.mp4&quot;</span>, mode=<span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(requests.get(srcURL).content)<br>    <br>f.close()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;over&quot;</span>)<br></code></pre></td></tr></table></figure><p>在请求srcURL时会被反爬，因为网站使用了防盗链<code>Referer</code>：</p><p>防盗链就是一个链式访问中间不能缺少环节，如果缺少就会报错；所以要给<code>headers</code>添加上<code>Referer</code>参数，以帮助程序”溯源“。</p><p><img src="/images/image-20210823113320104.png" alt="image-20210823113320104"></p><p>在对srcURL进行修整时，要结合网页预览：</p><p><img src="/images/image-20210823114949436.png" alt="image-20210823114949436"></p>]]></content>
    
    
    <categories>
      
      <category>Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构与算法-基础</title>
    <link href="/2021/08/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80/"/>
    <url>/2021/08/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>本文记录回顾数据结构与算法的学习笔记，代码实现为python；本文只记录基础的数据结构实现、算法实现，深入掌握数据结构与算法必不可少的环节是之后的大量刷题。</p><span id="more"></span><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>1.时间复杂度</p><img src="/images/image-20210817162422663.png" alt="image-20210817162422663" style="zoom:80%;"><p>快速判断时间复杂度的技巧：</p><img src="/images/image-20210817162603411.png" alt="image-20210817162603411" style="zoom:67%;"><p>2.空间复杂度</p><p>评估算法内存占用大小； “时间”比“空间”重要性更大！常用“空间换时间”</p><img src="/images/image-20210817162745159.png" alt="image-20210817162745159" style="zoom:67%;"><p>3.冷知识：计算机的运算能力：1s执行10^7次基本运算</p><p>​    结合算法的时间复杂度，可以大致估算程序的运行时间</p><p>经典递归问题：汉诺塔问题</p><p>关键：将<strong>上面n-1个盘子看成整体</strong>，<strong>最底下一个看成另一个整体</strong>；</p><p>​            每次先将上面n-1个盘子经由C移动到B，再移动最后一个盘子。</p><p>问题转化：n个盘子的移动问题 –&gt; n-1个盘子的移动问题；    不断递归下去，问题不断地化简</p><img src="/images/image-20210817163229613.png" alt="image-20210817163229613" style="zoom:67%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hanoi</span>(<span class="hljs-params">n, a, b, c</span>):</span><span class="hljs-comment"># a经c移动到b</span><br>    <span class="hljs-keyword">if</span> n&gt;<span class="hljs-number">0</span>:<br>        hanoi(n-<span class="hljs-number">1</span>, a, c, b)<span class="hljs-comment"># 先将n-1个经b移动到c</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;moving from &#123;&#125; to &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(a, c))<br>        hanoi(n-<span class="hljs-number">1</span>, b, a, c)<span class="hljs-comment"># 再将n-1个经a移动到</span><br><br>hanoi(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>1.顺序查找：O(n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">linear_search</span>(<span class="hljs-params">data, val</span>):</span><br>    <span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data):<br>        <span class="hljs-keyword">if</span> v == val:<br>            <span class="hljs-keyword">return</span> i<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> none<br></code></pre></td></tr></table></figure><p>2.二分查找：O(logn)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">binary_search</span>(<span class="hljs-params">data,val</span>):</span><br>    left = <span class="hljs-number">0</span><br>    right = <span class="hljs-built_in">len</span>(data)-<span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> left&lt;=right:<br>        mid = (left + right) // <span class="hljs-number">2</span><br>        <span class="hljs-keyword">if</span> data[mid] == val:<br>            <span class="hljs-keyword">return</span> mid<br>        <span class="hljs-keyword">elif</span> data[mid] &gt; val:<br>            right = mid-<span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            left = mid+<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> none<br></code></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><img src="/images/image-20210817165659847.png" alt="image-20210817165659847" style="zoom:67%;"><p>1.冒泡排序</p><p>列表中每两个相邻的数，如果前面比后面大，则交换两数；</p><p>一次排序完成后，无序区的最大数浮出来；</p><p>代码的关键点：趟数<code>n-1</code>、无序区的范围</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bubble_sort</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data)-<span class="hljs-number">1</span>):<span class="hljs-comment"># n-1趟</span><br>        change = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data)-i-<span class="hljs-number">1</span>):<span class="hljs-comment"># 无序区域</span><br>            <span class="hljs-keyword">if</span> data[j] &lt; data[j+<span class="hljs-number">1</span>]:<span class="hljs-comment"># 升序排列</span><br>                data[j], data[j+<span class="hljs-number">1</span>] = data[j+<span class="hljs-number">1</span>], data[j]<span class="hljs-comment"># 交换</span><br>                change = <span class="hljs-literal">True</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> change:<span class="hljs-comment"># 改良：一趟中五改变，提前停止</span><br>                <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>2.选择排序：</p><p>每次找无序区中最小的数，与第一个位置的元素交换位置；</p><p>趟数<code>n-1</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">select_sort</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data)-<span class="hljs-number">1</span>):<br>        min_loc = i<span class="hljs-comment"># 记录无序区min</span><br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(i+<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(data)):<span class="hljs-comment"># 找出无序区min</span><br>            <span class="hljs-keyword">if</span> data[j] &lt; data[min_loc]:<br>                min_loc = j<br>        <span class="hljs-keyword">if</span> min_loc != i:<br>            data[i], data[min_loc] = data[min_loc], data[i]<span class="hljs-comment"># 无序区第1个值 与 无序区min交换</span><br></code></pre></td></tr></table></figure><p>技巧：由于<strong>range的“前包后不包”</strong>特点 + <strong>数组的“从0开始”</strong>特点，数组第4位，index=3，我需要range到4；所以要取到数组第 i 位，就要range到 i 。</p><p>3.插入排序</p><p>每次从无序区取出一个数，插入有序区中正确的位置；</p><p>趟数<code>n-1</code>，直接把第一个数作为初始有序区，所以循环为<code>range(1, n)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_sort</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(data)):<span class="hljs-comment"># i 表示取出数的index</span><br>        tmp = data[i]<br>        j = i-<span class="hljs-number">1</span> <span class="hljs-comment"># j 表示有序区最右边元素的index</span><br>        <span class="hljs-keyword">while</span> data[j] &gt; tmp <span class="hljs-keyword">and</span> j &gt;=<span class="hljs-number">0</span>:<span class="hljs-comment"># 比tmp大</span><br>            data[j+<span class="hljs-number">1</span>] = data[j]<span class="hljs-comment"># 右移</span><br>            j -= <span class="hljs-number">1</span><br>        data[j+<span class="hljs-number">1</span>] = tmp<span class="hljs-comment"># 比tmp小，找到了合适的插入位置</span><br></code></pre></td></tr></table></figure><p>4.快速排序</p><p>思路较为复杂，速度明显快</p><img src="/images/image-20210817173517068.png" alt="image-20210817173517068" style="zoom: 50%;"><p>递归：p的左边、右边分别执行上述操作，再次一级的左边、右边分别执行上述操作；</p><p>实现：只需要实现归位的算法，后面递归调用即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort</span>(<span class="hljs-params">data, left, right</span>):</span><span class="hljs-comment"># 区域左端，区域右端</span><br>    <span class="hljs-keyword">if</span> left &lt; right:<span class="hljs-comment"># 递归停止条件：left = right， 即该区域只有1个元素</span><br>        mid = partition(data, left, right)<br>        quick_sort(data, left, mid-<span class="hljs-number">1</span>)<span class="hljs-comment"># 左分区递归</span><br>        quick_sort(data, mid+<span class="hljs-number">1</span>, right)<span class="hljs-comment"># 右分区递归</span><br></code></pre></td></tr></table></figure><p>关键在于<code>partition</code>函数的实现，即如何让元素归位，使得左边都是小于它的，右边都是大于它的；</p><p>过程较为复杂，左右交替进行，忘了就看这个：<a href="https://www.bilibili.com/video/BV1uA411N7c5?p=16">清华大学博士讲解Python数据结构与算法（完整版）全套100节_哔哩哔哩_bilibili</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">partition</span>(<span class="hljs-params">data,left,right</span>):</span><br>    tmp = data[left]<span class="hljs-comment"># 每次从左边取值寻找分区</span><br>    <span class="hljs-keyword">while</span> left &lt; right:<br>        <span class="hljs-keyword">while</span> data[right] &gt;= tmp <span class="hljs-keyword">and</span> left &lt; right: <span class="hljs-comment"># 从右边找比tmp小的数； </span><br>            <span class="hljs-comment"># 同时警惕可能都比tmp大，所以要判断left &lt; right，一旦指针重合，也退出</span><br>        right -= <span class="hljs-number">1</span><br>        data[left] = data[right]<span class="hljs-comment"># 找到比tmp小的数，把这个数写到left的位置上</span><br>        <br>        <span class="hljs-keyword">while</span> data[left] &lt;=tmp <span class="hljs-keyword">and</span> left &lt; right:<span class="hljs-comment"># 从左边找比tmp大的数</span><br>            left += <span class="hljs-number">1</span><br>        data[right] = data[left]<br>    data[left] = tmp<br>    <span class="hljs-keyword">return</span> left  <span class="hljs-comment"># return right也行 ，最后已经碰头了</span><br></code></pre></td></tr></table></figure><p>复杂度不严谨推导：</p><p>左右分区依次减半，所以logn；分区内的partition操作复杂度是n；所以整体是O(nlogn)</p><img src="/images/image-20210818100300341.png" alt="image-20210818100300341" style="zoom:67%;"><p>快速排序的最坏情况：列表原本呈倒序排列，则每次分区只能减少一个元素，复杂度变为 n方</p><p>拓展：随机化的快速排序：原始的快排每次都取最左侧元素寻找分区，进一步可以随机选择元素寻找分区</p><p>5.堆排序</p><p>基于：树与二叉树；简单了解概念</p><p>满二叉树、完全二叉树</p><img src="/images/image-20210818114926199.png" alt="image-20210818114926199" style="zoom:80%;"><p>二叉树的存储方式：链式存储、顺序存储 (列表存储)</p><img src="/images/image-20210818115921246.png" alt="image-20210818115921246" style="zoom: 50%;"><p>堆：一种特殊的完全二叉树；父节点大于孩子节点 / 小于</p><img src="/images/image-20210818120053585.png" alt="image-20210818120053585" style="zoom: 67%;"><p><strong>堆的向下调整：</strong>简单理解，就是不符合堆结构的，经过不断调整直至符合堆结构</p><p>以大根堆为例，</p><img src="/images/image-20210818120438134.png" alt="image-20210818120438134" style="zoom:67%;"><p>2比子节点小，必须更换，<strong>将子节点中更大的9换上去</strong>；继续比较，直至整棵树变为大根堆。</p><p>综上，总结堆排序过程：建立堆 –&gt; 挨个出数</p><p><img src="/images/image-20210818120711448.png" alt="image-20210818120711448"></p><p><strong>建立堆</strong>的过程：从末尾的小堆开始逐个调整。涉及知识点：由孩子节点找父节点： <code>(j-1) // 2</code></p><p>挨个出数过程：每次取出堆顶后，固定让堆最后一个元素放到堆顶（交换堆顶与堆尾），然后调整堆有序；重复直至堆空，至此降序排列完成。</p><p>代码实现：</p><p>挨个出数时，为了减少内存消耗，不另外创建列表存储出来的数，而是放到堆的最后面，并将“最后元素”的指针提前</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 堆的向下调整</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sift</span>(<span class="hljs-params">data, low, high</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    param data: 列表</span><br><span class="hljs-string">    param low: 堆的根节点位置</span><br><span class="hljs-string">    param high: 堆的最后一个元素的位置</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <br>    <span class="hljs-comment"># 需要两个“指针”来追踪 本节点和孩子节点</span><br>    i = low<span class="hljs-comment"># 取堆顶</span><br>    j = <span class="hljs-number">2</span>*i +<span class="hljs-number">1</span>  <span class="hljs-comment"># 左孩子</span><br>    tmp = data[i]<br>    <span class="hljs-keyword">while</span> j &lt;= high：<span class="hljs-comment"># 只要j没有越界</span><br>    <span class="hljs-keyword">if</span> data[j+<span class="hljs-number">1</span>] &gt; data[j] <span class="hljs-keyword">and</span> j+<span class="hljs-number">1</span> &lt;=high:<span class="hljs-comment"># 存在右孩子 且 右孩子&gt;左孩子</span><br>            j = j+<span class="hljs-number">1</span> <span class="hljs-comment"># 切换到右分支进行寻找</span><br>            <br>        <span class="hljs-keyword">if</span> data[j] &gt; tmp:<span class="hljs-comment"># 较大的孩子 &gt; tmp</span><br>            data[i] = data[j]<span class="hljs-comment"># 孩子换上去</span><br>            i = j<br>            j = <span class="hljs-number">2</span>*i + <span class="hljs-number">1</span><span class="hljs-comment"># 改变指针，往下追踪一层</span><br>        <span class="hljs-keyword">else</span>:<span class="hljs-comment"># tmp更大，把tmp放到i的位置上，就结束了</span><br>            data[i] = tmp<span class="hljs-comment"># i此时是某一级的领导位置</span><br>            <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">else</span>:<br>        data[i] = tmp<span class="hljs-comment"># 如果i一直找到了叶节点，则上面的循环会跳出，tmp还未放置；所以此时tmp直接放在i上</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 堆排序</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">heap_sort</span>()</span><br><span class="hljs-function">&quot;&quot;&quot;</span><br><span class="hljs-function">建立堆 --&gt; 出数 + 向下调整</span><br><span class="hljs-function">&quot;&quot;&quot;</span><br><span class="hljs-function"># 1.建堆</span><br><span class="hljs-function">    n = <span class="hljs-built_in">len</span>(data)</span><br><span class="hljs-function">    <span class="hljs-keyword">for</span> i <span class="hljs-built_in">range</span>((n-2)//2, -1, -1):</span><span class="hljs-comment"># 从最后节点的父节点开始，倒序遍历到0</span><br>        <span class="hljs-comment"># i表示建堆时，调整的部分的根节点</span><br>        sift(data, i, n-<span class="hljs-number">1</span>)<span class="hljs-comment"># 技巧：由于high仅用于判断孩子是否越界，所以此处不管在调整哪个子堆，都用整个堆的结尾元素作为high</span><br>        <br>    <span class="hljs-comment"># 2.出数</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        <span class="hljs-comment"># i表示当前堆的“最后位置”</span><br>        data[<span class="hljs-number">0</span>], data[i] = data[i], data[<span class="hljs-number">0</span>]<span class="hljs-comment"># 交换堆顶与堆尾</span><br>        sift(data, <span class="hljs-number">0</span>, i-<span class="hljs-number">1</span>) <span class="hljs-comment"># 为节省内存，最后一个位置已经放置了取出的元素，所以i-1是新的堆尾</span><br></code></pre></td></tr></table></figure><p>大根堆出数后的结果：最后的堆是升序；如果每次都输出一个数，则降序</p><p>小根堆出数后的结果：最后的堆是降序；如果每次都输出一个数，则升序。</p><p>堆排序的时间复杂度：</p><p><code>sift()</code>函数：<code>logn</code>，结合<code>heap_sort()</code>函数，最终<strong>O(nlogn)</strong></p><p><strong>堆排序的python内置模块</strong>：<code>heapq</code></p><p>堆排序的应用——<code>topk</code>问题</p><img src="/images/image-20210819072808158.png" alt="image-20210819072808158" style="zoom:67%;"><p>取列表中前k个数建立小根堆，然后依次取剩余元素调整堆，最后堆中剩下的元素就是前k大的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">topk</span>(<span class="hljs-params">data, k</span>):</span><br>    heap = data[:k]<span class="hljs-comment"># 取前k个元素建堆</span><br>    <span class="hljs-comment"># 1.建堆</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>((k-<span class="hljs-number">2</span>)//<span class="hljs-number">2</span>,-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>        sift(heap, i, k-<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-comment"># 2.遍历</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k, <span class="hljs-built_in">len</span>(data)-<span class="hljs-number">1</span>):    <span class="hljs-comment"># 依次遍历剩余元素</span><br>        <span class="hljs-keyword">if</span> data[i] &gt; heap[<span class="hljs-number">0</span>]:<span class="hljs-comment"># 大于堆顶，把堆顶挤掉并调整堆（注：只需要和堆顶比较,因堆顶就是最小数）</span><br>            heap[<span class="hljs-number">0</span>] = data[i]<br>            sift(heap, <span class="hljs-number">0</span>, k-<span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-comment"># 3.出数</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(k-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>        heap[<span class="hljs-number">0</span>], heap[i] = heap[i], heap[<span class="hljs-number">0</span>]<br>        sift(heap, <span class="hljs-number">0</span>, i-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> heap <span class="hljs-comment"># 小根堆，最后的堆是降序</span><br></code></pre></td></tr></table></figure><p>​    </p><p>6.归并排序</p><p>左右两个分区，假设分区有序，依次遍历两分区的指针，取出较小的数。</p><img src="/images/image-20210819080629122.png" alt="image-20210819080629122" style="zoom:80%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 一次归并</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span>(<span class="hljs-params">data, low, mid, high</span>):</span><span class="hljs-comment"># 左(low, mid)  右(mid+1, high)</span><br>    i = low<span class="hljs-comment"># 左区指针</span><br>    j = mid + <span class="hljs-number">1</span> <span class="hljs-comment"># 右区指针</span><br>    ltmp = []<br>    <span class="hljs-keyword">while</span> i &lt;= mid <span class="hljs-keyword">and</span> j &lt;= high:<span class="hljs-comment"># 只要两边都有数</span><br>        <span class="hljs-keyword">if</span> data[i] &lt; data[j]:<br>            ltmp.append(data[i])<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            ltmp.append(data[j])<br>            j += <span class="hljs-number">1</span><br>    <br>    <span class="hljs-comment"># while执行完，一定有一部分没数了</span><br>    <span class="hljs-keyword">while</span> i &lt;= mid:<span class="hljs-comment"># 左边还有，全部加进列表即可</span><br>        ltmp.append(data[i])<br>        i += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> j &lt;= high:<br>        ltmp.append(data[j])<br>        j += <span class="hljs-number">1</span><br>    data[low:high+<span class="hljs-number">1</span>] = ltmp<span class="hljs-comment"># 临时列表中的值必须写回去；因后面有递归调用</span><br>    <br><span class="hljs-comment"># 归并递归</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_sort</span>(<span class="hljs-params">data, low, high</span>):</span><br>    <span class="hljs-keyword">if</span> low &lt; high:<span class="hljs-comment"># 还有至少2个元素，没达到停止条件</span><br>        mid = (low + high) // <span class="hljs-number">2</span><br>        merge_sort(data, low, mid)<span class="hljs-comment"># 1.左边排好序</span><br>        merge_sort(data, mid+<span class="hljs-number">1</span>, high)<span class="hljs-comment"># 2.右边排好序</span><br>        <br>        merge(data, low, mid, high)<span class="hljs-comment"># 3.左右归并</span><br></code></pre></td></tr></table></figure><p>递归在代码上非常简单，但在理解上比较难</p><p>复杂度：O(nlogn)   空间复杂度：O(n)</p><p><img src="/images/image-20210819084201604.png" alt="image-20210819084201604"></p><p>稳定性：两元素值一样时，相对位置不变</p><p>python的内置排序<code>sort</code>是基于归并排序的，C++、Java的内置排序都是基于快速排序，但问题是快排不稳定。</p><p>7.希尔排序</p><p>每一趟都用插入排序</p><p>思想：每趟并不使某些元素有序，但会使整体数据越来越接近有序；最后一趟一定会使得所有数据有序。</p><p>代码：将插入排序的“1”全部改成分组大小“gap”即可实现每一趟的插入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_sort_gap</span>(<span class="hljs-params">data, gap</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(gap, <span class="hljs-built_in">len</span>(data)):<span class="hljs-comment"># i 表示取出数的index</span><br>        tmp = data[i]<br>        j = i-gap <span class="hljs-comment"># j 表示有序区最右边元素的index</span><br>        <span class="hljs-keyword">while</span> data[j] &gt; tmp <span class="hljs-keyword">and</span> j &gt;=<span class="hljs-number">0</span>:<span class="hljs-comment"># 比tmp大</span><br>            data[j+gap] = data[j]<span class="hljs-comment"># 右移</span><br>            j -= gap<br>        data[j+gap] = tmp<span class="hljs-comment"># 比tmp小，找到了合适的插入位置</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">shell_sort</span>(<span class="hljs-params">data</span>):</span><br>    d = <span class="hljs-built_in">len</span>(data) // <span class="hljs-number">2</span><br>    <span class="hljs-keyword">while</span> d &gt;= <span class="hljs-number">1</span>:<br>        insert_sort_gap(data, d)<br>        d //= <span class="hljs-number">2</span><span class="hljs-comment"># 每一趟分组数折半</span><br></code></pre></td></tr></table></figure><p>希尔排序的时间复杂度比较复杂，且和分组数gap的取法有关，不讨论。</p><p>8.计数排序</p><p>把所有数出现的次数统计出来，然后直接从小到大列出这些数即排序完成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">count_sort</span>(<span class="hljs-params">data, max_count=<span class="hljs-number">100</span></span>):</span><br>    count = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_count + <span class="hljs-number">1</span>)]<br>    <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> data:<br>        count[data] += <span class="hljs-number">1</span><br>    data.clear()<span class="hljs-comment"># 原列表清空，</span><br>    <span class="hljs-keyword">for</span> idx, val <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(count):<span class="hljs-comment"># 哪个数出现了几次？ index和value都要取</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(val):<br>            data.append(idx)<br></code></pre></td></tr></table></figure><p>计数排序非常快，时间复杂度使<code>O(n)</code></p><p>但使用计数排序有缺陷：</p><p>1）必须知道数据的范围，即max_count参数</p><p>2）如果数据的范围巨大（如10亿），则内存开销也巨大</p><p>9.桶排序</p><p>基于计数排序的改进</p><img src="/images/image-20210819091329243.png" alt="image-20210819091329243" style="zoom:67%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bucket_sort</span>(<span class="hljs-params">data, n, max_num</span>):</span><span class="hljs-comment"># n:桶个数  max_count：最大值</span><br>    buckets = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<span class="hljs-comment"># 创建n个桶（二维列表）</span><br>    <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> data:<br>        i = <span class="hljs-built_in">min</span>(var // (max_num // n), n-<span class="hljs-number">1</span>)<span class="hljs-comment"># i表示放到几号桶里； 取min：将最大数、可能超过最大数的数，都放到最后一个桶里</span><br>        buckets[i].append(var)<br>        <br>        <span class="hljs-comment"># 每放入一个值，都要保持桶内有序（用冒泡的思想排序）</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(buckets[i])-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> buckets[i][j] &lt; buckets[i][j-<span class="hljs-number">1</span>]:<br>                buckets[i][j], buckets[i][j-<span class="hljs-number">1</span>] = buckets[i][j-<span class="hljs-number">1</span>], buckets[i][j]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">break</span><br>                <br>    <span class="hljs-comment"># 至此所有桶都有序了,将桶合并为列表</span><br>    sorted_data=[]<br>    <span class="hljs-keyword">for</span> buc <span class="hljs-keyword">in</span> buckets:<br>        sorted_data.extend(buc)<br>    <span class="hljs-keyword">return</span> sorted_data<br></code></pre></td></tr></table></figure><p>桶排序的复杂度取决于数据的分布</p><p>10.基数排序</p><p>其实就是逐一比较每一位；</p><p>先按个位分桶，然后依次输出，<strong>保证个位小的先输出</strong>；然后按十位分桶，再依次输出，<strong>保证十位小的先输出</strong>；以此类推，完成排序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">radix_sort</span>(<span class="hljs-params">data</span>):</span><br>    max_num = <span class="hljs-built_in">max</span>(data)<span class="hljs-comment"># 取最大值，确定比较位数</span><br>    ite = <span class="hljs-number">0</span> <span class="hljs-comment"># 迭代次数，决定了当前应取哪一位</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-number">10</span> ** ite &lt;= max_num:<br>        buckets = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<span class="hljs-comment"># 桶, 每一位都是10个数，所以buckets列表中有10个子列表</span><br>        <span class="hljs-keyword">for</span> val <span class="hljs-keyword">in</span> data:<br>            digit = (var // <span class="hljs-number">10</span> ** ite) % <span class="hljs-number">10</span><span class="hljs-comment"># 取出相应位 </span><br>        buckets[digit].append(var)<br>    <span class="hljs-comment"># 分桶完成，清空data来存放新的顺序</span><br>        data.clear()<br>        <span class="hljs-keyword">for</span> buc <span class="hljs-keyword">in</span> buckets:<br>            data.extend(buc)<br>        <br>        <span class="hljs-comment"># 继续取下一位</span><br>        ite += <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>涉及一个知识点：取数字的某一位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">%<span class="hljs-number">10</span>：取出一个数的最后一位<br>//<span class="hljs-number">10</span>：去掉一个数的最后一位（//<span class="hljs-number">100</span>：去掉最后两位 ...）<br><br><span class="hljs-comment"># 例如987</span><br><span class="hljs-number">987</span> % <span class="hljs-number">10</span> = <span class="hljs-number">7</span><br><span class="hljs-number">987</span> // <span class="hljs-number">10</span> = <span class="hljs-number">98</span>   <span class="hljs-number">98</span> % <span class="hljs-number">10</span> = <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>与桶排序的区别：桶排序在装入桶后要进行排序；但基数排序没有这个过程，装入桶之后直接输出。</p><p>复杂度：<code>O(kn)</code>;    </p><p>辨析：快速排序O(nlogn)  <strong>log= log(2, n)</strong></p><p>​            基数排序O(kn)    <strong>k = logn =log(10, n)</strong></p><p>所以基数排序平均比快速排序快一点。</p><p>刷题！！！</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>重点关注——逻辑结构</p><p>1.列表</p><p>C++数组与python列表很相似，但有2点不同：</p><p>1）数组元素类型必须相同；    2）数组长度固定</p><p>python列表怎么解决上述两个约束？ 其实列表中存储的是<strong>数据的地址</strong>！所以元素类型可不同。</p><p>python列表：</p><p>查找、添加元素：<code>O(1)</code></p><p>插入、删除元素：<code>O(n)</code>因为插入/删除后，还要依次移动其它元素</p><p>2.栈</p><p>用python列表实现栈结构</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">stack</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.stack = []<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, element</span>):</span><span class="hljs-comment"># 入栈</span><br>        self.stack.append(element)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>):</span><span class="hljs-comment"># 出栈</span><br>        <span class="hljs-keyword">return</span> self.stack.pop()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_top</span>(<span class="hljs-params">self</span>):</span><span class="hljs-comment"># 查看栈顶</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(self.stack) &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> self.stack[-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span>(<span class="hljs-params">self</span>):</span><span class="hljs-comment"># 判断栈空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.stack) == <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>栈的应用——括号匹配问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">brace_match</span>(<span class="hljs-params">s</span>):</span><span class="hljs-comment"># s为string</span><br>    stack = Stack()<span class="hljs-comment"># 创建栈</span><br>    match = &#123;<span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-string">&#x27;(&#x27;</span>, <span class="hljs-string">&#x27;]&#x27;</span>:<span class="hljs-string">&#x27;[&#x27;</span>, <span class="hljs-string">&#x27;&#125;&#x27;</span>:<span class="hljs-string">&#x27;&#123;&#x27;</span>&#125;<span class="hljs-comment"># 匹配关系</span><br>    <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> s:<br>        <span class="hljs-keyword">if</span> ch <span class="hljs-keyword">in</span> &#123;<span class="hljs-string">&#x27;(&#x27;</span>,<span class="hljs-string">&#x27;[&#x27;</span>,<span class="hljs-string">&#x27;&#123;&#x27;</span>&#125;:<br>            stack.push(ch)<span class="hljs-comment"># 若左括号，进栈</span><br>        <span class="hljs-keyword">else</span>:<span class="hljs-comment"># 右括号，分三种情况</span><br>            <span class="hljs-keyword">if</span> stack.is_empty():<span class="hljs-comment"># 1.栈空</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">elif</span> stack.get_top == match[ch]:<span class="hljs-comment"># 2.和栈顶匹配成功</span><br>                stack.pop()<br>            <span class="hljs-keyword">else</span>:<span class="hljs-comment"># 3.不匹配</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <br>    <span class="hljs-keyword">if</span> stack.is_empty():<span class="hljs-comment"># 匹配完后栈空</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br>    <span class="hljs-keyword">else</span>:<span class="hljs-comment"># 栈不空，报错</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>3.队列</p><p>为了降低操作的复杂度，使用<code>环形队列</code></p><img src="/images/image-20210820102806738.png" alt="image-20210820102806738" style="zoom: 50%;"><p><code>rear</code>：队尾指针，进元素</p><p><code>front</code>：队首指针，出元素；跟着移动</p><p>问题：当<code>rear</code>循环一圈后，如何涉及计算方法，使11下一步跳到0。</p><p>（1）空队列：<code>rear == front</code></p><p>（2）队满：<code>(rear + 1) % n == front</code> ; 注意：队满时必须牺牲一个内存，否则rear和front重合无法和“队空”区分</p><p>（3）环形衔接处的跳跃：</p><p>​            进队时跳跃：<code>rear = (rear + 1) % n</code></p><p>​            出队时跳跃：<code>front = (front + 1) % n</code>         n为队列长度</p><p>实现环形队列：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Queue</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, size</span>):</span><br>        self.queue = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(size)]<span class="hljs-comment"># 环形队列须固定长度</span><br>        self.rear = <span class="hljs-number">0</span><br>        self.front = <span class="hljs-number">0</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push</span>(<span class="hljs-params">self, element</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.is_full():<br>    self.rear = (self.rear + <span class="hljs-number">1</span>) % self.size<br>        self.queue[self.rear] = element<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&quot;Queue is full.&quot;</span>)<span class="hljs-comment"># 抛异常</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop</span>(<span class="hljs-params">self</span>)</span><br><span class="hljs-function">    <span class="hljs-title">if</span> <span class="hljs-title">not</span> <span class="hljs-title">self</span>.<span class="hljs-title">is_empty</span>():</span><br>    self.front = (self.front + <span class="hljs-number">1</span>) % self.size<br>        <span class="hljs-keyword">return</span> self.queue[self.front]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> IndexError(<span class="hljs-string">&quot;Queue is empty.&quot;</span>)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_empty</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.rear == self.front<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_full</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> (self.rear + <span class="hljs-number">1</span>) % self.size == self.front<br></code></pre></td></tr></table></figure><p>python内置模块已有队列的实现，不用再造轮子~</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<span class="hljs-comment"># 双向队列</span><br><br>q = deque()<br><span class="hljs-comment">#q = deque([1,2,3], 5)最大长度5</span><br>q.append(<span class="hljs-number">1</span>)<span class="hljs-comment"># 队尾进队</span><br>q.popleft()<span class="hljs-comment"># 队首出队</span><br><br>q.appendleft(<span class="hljs-number">1</span>)<span class="hljs-comment"># 队首进队</span><br>q.pop()<span class="hljs-comment"># 队尾出队</span><br></code></pre></td></tr></table></figure><p>栈和队列的应用——<strong>迷宫问题</strong></p><p>栈——深度优先搜索 (回溯法)</p><p>队列——广度优先搜索</p><img src="/images/image-20210820111028241.png" alt="image-20210820111028241" style="zoom:80%;"><p>框起来的是队列中的元素，也即队列中存储的不是路径，而是当前可扩展的方向</p><p>由于最后要得到路径，所以需要额外的列表存储每次出队的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><br>maze=[[...]]    <span class="hljs-comment"># 迷宫矩阵；1表示墙，0表示路</span><br><br>dirs=[<br>    <span class="hljs-keyword">lambda</span> x,y:(x+<span class="hljs-number">1</span>,y),<br>    <span class="hljs-keyword">lambda</span> x,y:(x-<span class="hljs-number">1</span>,y),<br>    <span class="hljs-keyword">lambda</span> x,y:(x,y-<span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">lambda</span> x,y:(x,y+<span class="hljs-number">1</span>),<br>]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_r</span>(<span class="hljs-params">path</span>):</span><br>    curNode=path[-<span class="hljs-number">1</span>]    <span class="hljs-comment"># 终点</span><br>    realpath=[]  <span class="hljs-comment"># path列表中并不是真实路径，而是所有扩展的节点</span><br>                 <span class="hljs-comment"># 所以用realpath来存储真实路径</span><br><br>    <span class="hljs-keyword">while</span> curNode[<span class="hljs-number">2</span>] != -<span class="hljs-number">1</span>:  <span class="hljs-comment"># =-1时回到起点</span><br>        realpath.append(curNode[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>])<br>        curNode=path[curNode[<span class="hljs-number">2</span>]]    <span class="hljs-comment"># 找到上一个节点</span><br><br>    realpath.append(curNode[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>])<br>    realpath.reverse()  <span class="hljs-comment"># 倒序</span><br>    <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> realpath:<br>        <span class="hljs-built_in">print</span>(node)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maze_path_queue</span>(<span class="hljs-params">x1,y1,x2,y2</span>):</span><br>    queue=deque()<br>    <span class="hljs-comment"># 起点进队；用三元组，第三个数表示上一步</span><br>    queue.append((x1,y1,-<span class="hljs-number">1</span>))<br>    path=[]     <span class="hljs-comment"># 存储路径</span><br><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(queue)&gt;<span class="hljs-number">0</span>:<br>         curNode=queue.pop()    <span class="hljs-comment"># 队首出队</span><br>         path.append(curNode)<br><br>         <span class="hljs-comment"># 判断是否已经到终点</span><br>         <span class="hljs-keyword">if</span> curNode[<span class="hljs-number">0</span>]==x2 <span class="hljs-keyword">and</span> curNode[<span class="hljs-number">1</span>]==y2:<br>             print_r(path)  <span class="hljs-comment"># 打印路径</span><br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>         <span class="hljs-comment"># 走下一步</span><br>         <span class="hljs-keyword">for</span> <span class="hljs-built_in">dir</span> <span class="hljs-keyword">in</span> dirs:   <span class="hljs-comment"># 遍历四个方向</span><br>             nextNode=<span class="hljs-built_in">dir</span>(curNode[<span class="hljs-number">0</span>],curNode[<span class="hljs-number">1</span>])<br>             <span class="hljs-keyword">if</span> maze[nextNode[<span class="hljs-number">0</span>]][nextNode[<span class="hljs-number">1</span>]] == <span class="hljs-number">0</span>:    <span class="hljs-comment"># 能走</span><br>                 queue.append(nextNode[<span class="hljs-number">0</span>], nextNode[<span class="hljs-number">1</span>], <span class="hljs-built_in">len</span>(path)-<span class="hljs-number">1</span>)    <span class="hljs-comment"># 第三个值存储curNode在path列表中的位置;等于当前path长度-1</span><br>                 <span class="hljs-comment"># 标记已走过</span><br>                 maze[nextNode[<span class="hljs-number">0</span>]][nextNode[<span class="hljs-number">1</span>]] = <span class="hljs-number">2</span><br><br>    <span class="hljs-comment"># 队空还未到终点</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没有路径&quot;</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>4.链表</p><p>创建链表：</p><p>（1）头插法    （2）尾插法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, item</span>):</span><br>        self.item = item<br>        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br>        <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_linklist_head</span>(<span class="hljs-params">data</span>):</span><br>    head = Node(data[<span class="hljs-number">0</span>])<span class="hljs-comment"># 创建第一个节点，并指向head</span><br>    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> data[<span class="hljs-number">1</span>:]:<br>        node = Node(element)<br>        <span class="hljs-comment"># 在头部添加节点</span><br>        node.<span class="hljs-built_in">next</span> = head<br>        head = node<br>    <span class="hljs-keyword">return</span> head<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_linklist_tail</span>(<span class="hljs-params">data</span>):</span><br>    head = Node(data[<span class="hljs-number">0</span>])<span class="hljs-comment"># 创建第一个节点，维护两个指针：head、tail都指向它</span><br>    tail = head<br>    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> data[<span class="hljs-number">1</span>:]:<br>        node = Node(element)<br>        <span class="hljs-comment"># 在尾部添加节点</span><br>        tail.<span class="hljs-built_in">next</span> = node<br>        tail = node<br></code></pre></td></tr></table></figure><p>链表遍历：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_linklist</span>(<span class="hljs-params">lk</span>):</span><br>    <span class="hljs-keyword">while</span> lk:<span class="hljs-comment"># 循环，当链表不空</span><br>        <span class="hljs-built_in">print</span>(lk.item)<br>        lk = lk.<span class="hljs-built_in">next</span><br></code></pre></td></tr></table></figure><p>链表插入：</p><p>列表的插入，时间复杂度<code>O(n)</code></p><p>链表的插入，<code>O(1)</code></p><img src="/images/image-20210822153544767.png" alt="image-20210822153544767" style="zoom:67%;"><p>链表删除：</p><img src="/images/image-20210822153634040.png" alt="image-20210822153634040" style="zoom:67%;"><p>双链表</p><img src="/images/image-20210822153815283.png" alt="image-20210822153815283" style="zoom:80%;"><p>双链表的插入、删除等。</p><p>5.哈希表</p><p>python的字典是通过哈希表实现。</p><img src="/images/image-20210822154411207.png" alt="image-20210822154411207" style="zoom:67%;"><p>在了解哈希表之前，先理解直接寻址表：</p><p>开一个表，将地址与key一一对应，没有值的地方不填，有值的地方就填，这样可以通过key直接定位到地址</p><img src="/images/image-20210822154842577.png" alt="image-20210822154842577" style="zoom:80%;"><p>在直接寻址的基础上，用一个哈希函数，得到哈希表：</p><p><code>哈希表 = 直接寻址表 + 哈希函数</code></p><img src="/images/image-20210822155046514.png" alt="image-20210822155046514" style="zoom: 50%;"><p>哈希冲突：</p><img src="/images/image-20210822155416687.png" alt="image-20210822155416687" style="zoom: 50%;"><p>（1）解决哈希冲突——开放寻址法</p><img src="/images/image-20210822155648727.png" alt="image-20210822155648727" style="zoom:67%;"><p>依次往后探查，直到有空位，就把元素放入；查找时，也遵循线性探查。</p><p>（2）解决哈希冲突——拉链法</p><p><img src="/images/image-20210822155900443.png" alt="image-20210822155900443"></p><p>常见哈希函数：</p><img src="/images/image-20210822160146130.png" alt="image-20210822160146130" style="zoom: 80%;"><p>哈希表的应用：</p><p>（1）MD5算法</p><p><img src="/images/image-20210822161141184.png" alt="image-20210822161141184"></p><p>MD5 (SHA-1) 已经被山东大学 王小云破解</p><p>（2）SHA-2算法</p><p>目前尚未被破解</p><p>（3）比特币</p><p><img src="/images/image-20210822161804851.png" alt="image-20210822161804851"></p><p>没有反解哈希值的方法，所以只能暴力枚举，这个过程就是“挖矿”</p><p>6.树</p><p>（1）模拟Linux文件系统</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name, <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;dir&#x27;</span></span>):</span><br>        self.name = name<br>        self.<span class="hljs-built_in">type</span> = <span class="hljs-built_in">type</span><br>        self.children = []<br>        self.parent = <span class="hljs-literal">None</span><br><span class="hljs-comment"># 略</span><br></code></pre></td></tr></table></figure><p>（2）最常用的树——二叉树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BiTreeNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, data</span>):</span><br>        self.data = data<br>        self.lchild = <span class="hljs-literal">None</span><br>        self.rchild = <span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><p><strong>重要知识点——二叉树的遍历：4种方式（面试常问）</strong></p><img src="/images/image-20210822171454500.png" alt="image-20210822171454500" style="zoom:67%;"><p>递归实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 前序遍历：根-左子树-右子树</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pre_order</span>(<span class="hljs-params">root</span>):</span><br>    <span class="hljs-keyword">if</span> root:<br>        <span class="hljs-built_in">print</span>(root.data)<span class="hljs-comment"># 打印根节点</span><br>        pre_order(root.lchild)<span class="hljs-comment"># 遍历左子树</span><br>        pre_order(root.rchild)<span class="hljs-comment"># 遍历右子树</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 中序遍历：左子树-根-右子树</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">in_order</span>(<span class="hljs-params">root</span>):</span><br>    <span class="hljs-keyword">if</span> root:<br>        pre_order(root.lchild)<br>        <span class="hljs-built_in">print</span>(root.data)<br>        pre_order(root.rchild)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 后序遍历：左-右-根</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post_order</span>(<span class="hljs-params">root</span>):</span><br>    <span class="hljs-keyword">if</span> root:<br>        post_order(root.lchild)<br>        post_order(root.rchild)<br>        <span class="hljs-built_in">print</span>(root.data)<br></code></pre></td></tr></table></figure><p><strong>层次遍历</strong>需要用到队列实现：</p><p>有点类似于<code>open、close</code>表的节点扩展过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">level_order</span>(<span class="hljs-params">root</span>):</span><br>    q = deque()<span class="hljs-comment"># 创建队列</span><br>    q.append(root)<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(q) &gt; <span class="hljs-number">0</span>:<span class="hljs-comment"># 只要队不空</span><br>        <span class="hljs-comment"># 队首出队，并访问其孩子(进队)</span><br>        node = q.popleft()<br>        <span class="hljs-built_in">print</span>(node.data)<br>        <span class="hljs-keyword">if</span> node.lchild:<span class="hljs-comment"># 有左孩子</span><br>            q.append(node.lchild)<br>        <span class="hljs-keyword">if</span> node.rchild:<br>            q.append(node.rchild)      <br></code></pre></td></tr></table></figure><p>由遍历序列推导树的结构：只给一种遍历的结果，无法确定树的结构；必须至少给两种遍历方式的结果！</p><img src="/images/image-20210822172336003.png" alt="image-20210822172336003" style="zoom: 67%;"><p>（3）二叉树的应用——二叉搜索树<code>BST</code></p><img src="/images/image-20210822200013740.png" alt="image-20210822200013740" style="zoom:67%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BSTNode</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, data</span>):</span><br>        self.data = data<br>        self.lchild = <span class="hljs-literal">None</span><br>        self.rchild = <span class="hljs-literal">None</span><br>        self.parent = <span class="hljs-literal">None</span><br>        <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BST</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.root = <span class="hljs-literal">None</span><br>        <br>    <span class="hljs-comment"># 插入</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert</span>(<span class="hljs-params">self, node, val</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<span class="hljs-comment"># 如果node为空（递归停止），插进去</span><br>            node = BSTNode(val)<br>        <span class="hljs-keyword">elif</span> val &lt; node.data:<br>            node.lchild = self.insert(node.lchild, val)<span class="hljs-comment"># 往左插</span><br>            node.lchild.parent = node<br>        <span class="hljs-keyword">elif</span> val &gt; node.data:<br>            node.rchild = self.insert(node.rchild, val)<span class="hljs-comment"># 往右插</span><br>            node.rchild.parent = node<br>        <span class="hljs-keyword">return</span> node<span class="hljs-comment"># 最后一层递归将新插入的node返回</span><br>    <br>    <span class="hljs-comment"># 插入——非递归</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_no_rec</span>(<span class="hljs-params">self, val</span>):</span><br>        p = self.root<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> p:<span class="hljs-comment"># 根节点为空，直接插在根节点</span><br>            self.root = BSTNode(val)<br>            <span class="hljs-keyword">return</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">if</span> val &lt; p.data:<br>                <span class="hljs-keyword">if</span> p.lchild:<span class="hljs-comment"># 左子树存在</span><br>                    p = p.lchild <span class="hljs-comment"># 往左子树走一步</span><br>                <span class="hljs-keyword">else</span>：<br>                p.lchild = BSTNode(val)<span class="hljs-comment"># 插在这</span><br>                    p.lchild.parent = p<br>                    <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">elif</span> val &gt; p.data:<br>                <span class="hljs-keyword">if</span> p.rchild:<br>                    p = p.rchild<br>                <span class="hljs-keyword">else</span>:<br>                    p.rchild = BSTNode(val)<br>                    p.rchild.parent = p<br>                    <span class="hljs-keyword">return</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure><p>对于 二叉搜索树的中序遍历，是有序的序列！</p><p>以下的方法都属于<code>BST</code>类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 查询</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">query</span>(<span class="hljs-params">self, node, val</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> node.data &gt; val:<br>        <span class="hljs-keyword">return</span> self.query(node.lchild, val)<br>    <span class="hljs-keyword">elif</span> node.data &lt; val:<br>        <span class="hljs-keyword">return</span> self.query(node.rchild, val)<br>    <span class="hljs-keyword">else</span>:<span class="hljs-comment"># 相等，找到了</span><br>        <span class="hljs-keyword">return</span> node<br>    <br><span class="hljs-comment"># 查询——非递归</span><br><span class="hljs-comment"># 略</span><br></code></pre></td></tr></table></figure><p>BST节点的删除，由于删除后要填补上这个节点，所以分情况：</p><img src="/images/image-20210822220735007.png" alt="image-20210822220735007" style="zoom:67%;"><img src="/images/image-20210822220205908.png" alt="image-20210822220205908" style="zoom: 67%;"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 情况1：node是叶子节点，直接删</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__remove_node_1</span>(<span class="hljs-params">self, node</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.parent:<span class="hljs-comment"># 根节点</span><br>        self.root = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">if</span> node == node.parent.lchild:<br>        node.parent.lchild = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">else</span>:<br>        node.parent.rchild = <span class="hljs-literal">None</span><br>        <br><span class="hljs-comment"># 情况2：node只有一个孩子        </span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__remove_node_2l</span>(<span class="hljs-params">self, node</span>):</span><span class="hljs-comment"># 只有一个左孩子</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.parent:<br>        self.root = node.lchild<br>        node.lchild.parent = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">elif</span> node == node.parent.lchild:<br>        node.parent.lchild = node.lchild<span class="hljs-comment"># 将node父亲和node的左孩子相连</span><br>        node.lchild.parent = node.parent<br>    <span class="hljs-keyword">else</span>:<br>        node.parent.rchild = node.lchild<br>        node.lchild.parent = node.parent<br>        <br><span class="hljs-comment"># 情况2：node只有一个孩子        </span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__remove_node_2r</span>(<span class="hljs-params">self, node</span>):</span><span class="hljs-comment"># 只有一个右孩子</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.parent:<br>        self.root = node.lchild<br>        node.rchild.parent = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">elif</span> node == node.parent.lchild:<br>        node.parent.lchild = node.rchild<span class="hljs-comment"># 将node父亲和node的右孩子相连</span><br>        node.lchild.parent = node.parent<br>    <span class="hljs-keyword">else</span>:<br>        node.parent.rchild = node.rchild<br>        node.lchild.parent = node.parent <br>        <br><span class="hljs-comment"># 情况3：node有两个孩子，用到上面的函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">self, val</span>):</span><br>    <span class="hljs-keyword">if</span> self.root:<span class="hljs-comment"># 不是空树才操作</span><br>        node = self.query_no_rec(val)<span class="hljs-comment"># 先通过val找到要删除的node</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><span class="hljs-comment"># raise xx error</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> node.lchild <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> node.rchild:<span class="hljs-comment"># 叶子节点</span><br>            self.__remove_node_1(node)<br>        <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> node.rchild:<span class="hljs-comment"># 只有左孩子</span><br>            self._remove_node_2l(node)<br>        <span class="hljs-keyword">elif</span> <span class="hljs-keyword">not</span> node.lchild:<span class="hljs-comment"># 只有右孩子</span><br>            self._remove_node_2r(node)<br>            <br>        <span class="hljs-comment"># 情况3：两个孩子</span><br>        <span class="hljs-keyword">else</span>:<br>            min_node = node.rchild<span class="hljs-comment"># 找右子树的最小节点：一直找左子树</span><br>            <span class="hljs-keyword">while</span> min_node.lchild:<span class="hljs-comment"># 当左不为空时</span><br>                min_node = min_node.lchild<span class="hljs-comment"># 一直往左走</span><br>            node.data = min_node.data<br>            <span class="hljs-comment"># 删除min_node</span><br>            <span class="hljs-keyword">if</span> min_node.rchild:<span class="hljs-comment"># min_node一定没有左子树了，只剩2种可能</span><br>                self.__remove_node_2r(min_node)<br>            <span class="hljs-keyword">else</span>:<br>                self.__remove_node_1(min_node)<br></code></pre></td></tr></table></figure><p>二叉搜索树的效率：</p><img src="/images/image-20210823170315829.png" alt="image-20210823170315829" style="zoom: 67%;"><p>（4）二叉搜索树的改进——AVL树</p><p>AVL树是一棵自平衡的二叉搜索树；</p><p>平衡：任何节点的左右子树高度差不超过1！</p><p>AVL树的维护：旋转操作</p><p><img src="/images/image-20210823171032911.png" alt="image-20210823171032911"></p><p>1.不平衡由对于K的右孩子的右子树插入导致：左旋</p><p><img src="/images/image-20210823171135402.png" alt="image-20210823171135402" style="zoom:50%;"><img src="/images/image-20210823171303056.png" alt="image-20210823171303056" style="zoom:50%;"></p><p>2.不平衡由对于K的左孩子的左子树插入导致：右旋</p><img src="/images/image-20210823171415381.png" alt="image-20210823171415381" style="zoom: 50%;"><p>3.由右孩子的左子树插入导致：先右旋-再左旋</p><img src="/images/image-20210823171507631.png" alt="image-20210823171507631" style="zoom: 67%;"><p>4.左右：左右</p><p>AVL旋转的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 同样，节点类、树类要分别实现</span><br><span class="hljs-comment"># 由于AVL是平衡的二叉搜索树，所以直接继承</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVLNode</span>(<span class="hljs-params">BSTNode</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span> (<span class="hljs-params">self, data</span>):</span><br>        BSTNode.__init__(self, data)<br>        self.bf = <span class="hljs-number">0</span><span class="hljs-comment"># balence factor: 本节点左右子树的高度差</span><br>        <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVLTree</span>(<span class="hljs-params">BST</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, li=<span class="hljs-literal">None</span></span>):</span><br>        BST.__init__(self, li)<br>        <br>    <span class="hljs-comment"># 左旋    </span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotate_left</span>(<span class="hljs-params">self, p, c</span>):</span><br>        s2 = c.lchild<br>        p.rchild = s2<br>        <span class="hljs-keyword">if</span> s2:<br>            s2.parent = p<br>        c.lchild = p<br>        p.parent = c<br>        p.bf = <span class="hljs-number">0</span><br>        c.bf = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 右旋    </span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotate_right</span>(<span class="hljs-params">self, p, c</span>):</span><br>        s2 = c.rchild<br>        p.lchild = s2<br>        <span class="hljs-keyword">if</span> s2:<br>            s2.parent = p<br>        c.rchild = p<br>        p.parent = c<br>        p.bf = <span class="hljs-number">0</span><br>        c.bf = <span class="hljs-number">0</span><br>        <br>    <span class="hljs-comment"># 右旋-左旋    </span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotate_right_left</span>(<span class="hljs-params">self, p, c</span>):</span><br>        <span class="hljs-comment"># 以整体结果为过程写代码</span><br>        <span class="hljs-comment"># 不是简单的左右旋叠加</span><br>        g = c.lchild<br>        s3 = g.rchild<br>        c.lchild = s3<br>        <span class="hljs-keyword">if</span> s3:<br>            s3.parent = c<br>            <br>        g.rchild = c<br>        c.parent = g<br>        <br>        s2 = g.lchild<br>        p.rchild = s2<br>        <span class="hljs-keyword">if</span> s2:<br>            s2.parent = p<br>        <br>        g.rchild = p<br>        p.parent = g<br>        <br>        <span class="hljs-comment"># 更新bf</span><br>        <span class="hljs-comment"># 有2种插入可能：插g的左孩子，插g的右孩子</span><br>        <span class="hljs-comment"># 左：</span><br>        <span class="hljs-keyword">if</span> g.bf &lt; <span class="hljs-number">0</span>:<br>            p.bf = <span class="hljs-number">1</span><br>            c.bf = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> g.bf &gt; <span class="hljs-number">0</span>:<br>            p.bf = <span class="hljs-number">0</span><br>            c.bf = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            p.bf = <span class="hljs-number">0</span><br>            c.bf = <span class="hljs-number">0</span><br>            <br>    <span class="hljs-comment"># 左旋-右旋    </span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rotate_left_right</span>(<span class="hljs-params">self, p, c</span>):</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_no_rec</span>(<span class="hljs-params">self, val</span>):</span><br>        <span class="hljs-comment"># 略</span><br></code></pre></td></tr></table></figure><p>插入的实现，应用上述四个旋转函数实现，过程比较复杂，不做记录；</p><p>参考：<a href="https://www.bilibili.com/video/BV1uA411N7c5?p=78">清华大学博士讲解Python数据结构与算法（完整版）全套100节_哔哩哔哩_bilibili</a></p><h2 id="算法进阶"><a href="#算法进阶" class="headerlink" title="算法进阶"></a>算法进阶</h2><p>优化算法：</p><h3 id="一、贪心算法"><a href="#一、贪心算法" class="headerlink" title="一、贪心算法"></a>一、贪心算法</h3><img src="/images/image-20210824100743228.png" alt="image-20210824100743228" style="zoom: 67%;"><p>1.背包问题</p><img src="/images/image-20210824101106201.png" alt="image-20210824101106201" style="zoom: 80%;"><p>0-1背包：要么全拿，要么不拿；  分数背包：可以只拿一部分</p><p>贪心算法是分数背包的最优解！</p><p>分数背包的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">goods = [(<span class="hljs-number">60</span>,<span class="hljs-number">10</span>), (<span class="hljs-number">100</span>,<span class="hljs-number">20</span>), (<span class="hljs-number">120</span>,<span class="hljs-number">30</span>)]<span class="hljs-comment"># 商品(价值，重量)</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fenshu_backpack</span>(<span class="hljs-params">goods, w</span>):</span><span class="hljs-comment"># w:背包容量</span><br>    goods.sort(key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">0</span>]/x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)<span class="hljs-comment"># 按单位价值降序排列</span><br>    <br>    m = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(goods))] <span class="hljs-comment"># 记录每种商品取的数量</span><br>    <span class="hljs-keyword">for</span> i,(prize, weight) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(goods):<br>        m[i] = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> w &gt;= weight <span class="hljs-keyword">else</span> w / weight<br>        <br>        <span class="hljs-comment"># 略</span><br></code></pre></td></tr></table></figure><p>2.拼接最大数字问题：</p><img src="/images/image-20210824103922481.png" alt="image-20210824103922481" style="zoom:80%;"><p>整体使用贪心算法啊，但有一点需要考虑：</p><p><img src="/images/image-20210824104229156.png" alt="image-20210824104229156"></p><p>当出现128、1286时怎么拼接？</p><p>这种情况可以归类为“两数不等长，且短的是长的数的子集”，此时应该<strong>先合并再比较</strong>！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> cmp_to_key<span class="hljs-comment"># 传python2的cmp函数，转换为python3的key函数</span><br><br>data = [<span class="hljs-number">32</span>,<span class="hljs-number">94</span>,<span class="hljs-number">128</span>,<span class="hljs-number">1286</span>,<span class="hljs-number">6</span>,<span class="hljs-number">71</span>]<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">xy_cmp</span>(<span class="hljs-params">x, y</span>):</span><br>    <span class="hljs-keyword">if</span> x+y &lt; y+x:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">elif</span> x+y &gt; y+x:<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">number_concat</span>(<span class="hljs-params">data</span>):</span><br>    data = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, data)) <span class="hljs-comment"># 所有元素转为字符串，构造一个新的list</span><br>    <span class="hljs-comment"># 排序：</span><br>    <span class="hljs-comment"># 通过交换列表中的元素：</span><br>    <span class="hljs-comment"># 如果 x+y &lt; y+x，则交换</span><br>    <span class="hljs-comment"># data.sort(cmp=lambda x,y:x+y,y+x)# python2的写法，比较x、y两数</span><br>    data.sort(key=cmp_to_key(xy_cmp))<br>    <br>    <span class="hljs-comment">#注：这里的排序必须使用cmp策略，即根据x+y和y+x来交换元素。否则会把位数多的排前面，达不到目的</span><br></code></pre></td></tr></table></figure><p>3.活动选择问题</p><img src="/images/image-20210824105505070.png" alt="image-20210824105505070" style="zoom: 67%;"><p><img src="/images/image-20210824110011973.png" alt="image-20210824110011973"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">activities = [(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>), (<span class="hljs-number">3</span>,<span class="hljs-number">5</span>), (<span class="hljs-number">0</span>,<span class="hljs-number">6</span>)]<br><span class="hljs-comment"># 活动按照结束实践排序</span><br>activities.sort(key=<span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>])<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">activity_selection</span>(<span class="hljs-params">data</span>):</span><br>    res = [a[<span class="hljs-number">0</span>]]<span class="hljs-comment"># 结束最早的一定在答案里</span><br>    <br>    <span class="hljs-comment"># 再依次往后看，只要开始时间不冲突，就可以加到答案里</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(data)):<br>        <span class="hljs-keyword">if</span> data[i][<span class="hljs-number">0</span>] &gt;= res[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]: <span class="hljs-comment"># 不冲突</span><br>            res.append(a[i])<br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><p>贪心算法总结：</p><p>难点在于：意识到一个问题应用贪心算法解决；  代码部分并不难</p><h3 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h3><p>To be continued.</p>]]></content>
    
    
    <categories>
      
      <category>Data Structures and Algorithms</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何clone开源项目并在Pycharm提交更新</title>
    <link href="/2021/08/26/%E5%A6%82%E4%BD%95clone%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%B9%B6%E5%9C%A8Pycharm%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0/"/>
    <url>/2021/08/26/%E5%A6%82%E4%BD%95clone%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%B9%B6%E5%9C%A8Pycharm%E6%8F%90%E4%BA%A4%E6%9B%B4%E6%96%B0/</url>
    
    <content type="html"><![CDATA[<p>本文记录clone开源项目，并在pycharm完成commit与push的过程，方便后续查阅。</p><span id="more"></span><h2 id="如何clone开源项目并在Pycharm提交更新"><a href="#如何clone开源项目并在Pycharm提交更新" class="headerlink" title="如何clone开源项目并在Pycharm提交更新"></a>如何clone开源项目并在Pycharm提交更新</h2><h3 id="一、将别人的开源项目Fork到自己的github账号"><a href="#一、将别人的开源项目Fork到自己的github账号" class="headerlink" title="一、将别人的开源项目Fork到自己的github账号"></a>一、将别人的开源项目Fork到自己的github账号</h3><ol><li>显然，我们不能直接修改别人的代码仓库，所以需要先<code>fork</code>一个分支到自己的github仓库；</li><li>从自己的github仓库<code>git clone</code>到本地：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">git clone git@github.com:Ericccccc1022&#x2F;yolo3-pytorch.git# 使用ssh协议<br></code></pre></td></tr></table></figure><p>注意：这里使用<code>git clone https://github.com:Ericccccc1022/yolo3-pytorch.git</code>会报错，于是网上有方法说将<code>https</code>改成<code>git</code>即可，这是一个大坑！</p><p>因为这样使用的是http协议，会使本地无法<code>push</code>更新！</p><p>​    所以必须使用<code>git@</code>来保证后续能够正常的<code>push</code></p><h3 id="二、Pycharm中Add、Commit与Push"><a href="#二、Pycharm中Add、Commit与Push" class="headerlink" title="二、Pycharm中Add、Commit与Push"></a>二、Pycharm中Add、Commit与Push</h3><ol start="3"><li><p>在修改代码之前，最好创建新的分支，后续的修改、提交都在这个branch上进行；pycharm中右下角即可操作分支：</p><p><img src="/images/image-20210826112620060.png" alt="image-20210826112620060"></p></li><li><p>切换到指定分支后，pycharm中添加文件，会提示是否需要<code>Add</code>，表示是否加入版本控制；若不加入，则文件为红色；</p></li><li><p><code>Add</code>之后，通过<code>Commit</code>提交到本地仓库：在pycharm上方工具栏中选择<code>VCS</code>，选择<code>Commit</code></p></li></ol><p><img src="/images/image-20210826112219623.png" alt="image-20210826112219623"></p><p>然后勾选需要提交的文件，并添加<code>Commit message</code>，相当于版本说明，最后点击下方<code>Commit</code>：</p><img src="/images/image-20210826112405185.png" alt="image-20210826112405185" style="zoom: 80%;"><ol start="6"><li><p>最后，在右下角选择对应分支，点击<code>push</code>即可上传到远程库了~</p><p><img src="/images/image-20210826112949705.png" alt="image-20210826112949705"></p></li></ol><h3 id="三、Tip"><a href="#三、Tip" class="headerlink" title="三、Tip"></a>三、Tip</h3><p>不要add权重文件！！ 文件太大push不了，而且一旦commit处理起来比较麻烦。</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>总结-深度学习代码模板</title>
    <link href="/2021/08/22/%E6%80%BB%E7%BB%93-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/"/>
    <url>/2021/08/22/%E6%80%BB%E7%BB%93-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%BB%A3%E7%A0%81%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<p>在最近阅读源码的基础上，参考：<a href="https://zhuanlan.zhihu.com/p/396666255">深度学习pytorch训练代码模板(个人习惯) - 知乎 (zhihu.com)</a>，总结了一套pytorch的代码模板。 这套模板比较简易，不涉及cuda代码的编译，但一般量级的项目完全可参考。</p><span id="more"></span><h2 id="深度学习代码模板"><a href="#深度学习代码模板" class="headerlink" title="深度学习代码模板"></a>深度学习代码模板</h2><p>目录如下：</p><p>1.导入包及设置随机种子</p><p>2.以函数的方式获取超参数</p><p>3.定义自己的model</p><p>4.定义早停类(选)</p><p>5.定义自己的数据集类Dataset</p><p>6.实例化模型、设置loss、优化器等</p><p>7.开始训练以及调整lr</p><p>8.绘图</p><p>9.预测</p><h3 id="一、导入包以及设置随机种子"><a href="#一、导入包以及设置随机种子" class="headerlink" title="一、导入包以及设置随机种子"></a>一、导入包以及设置随机种子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader, Dataset<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> ...<br><br><br>random.seed(seed)<br>np.random.seed(seed)<br>torch.manual_seed(seed)<br>torch.cuda.manual_seed(seed)<span class="hljs-comment"># 可有可无：torch.manual_seed()已经包含了cuda</span><br>torch.backends.cudnn.deterministic = <span class="hljs-literal">True</span><span class="hljs-comment"># True: 固定一种卷积算法</span><br>torch.backends.cudnn.benchmark = <span class="hljs-literal">False</span>  <span class="hljs-comment"># False: 每次算法都一样</span><br></code></pre></td></tr></table></figure><h3 id="二、以函数的方式获取超参数"><a href="#二、以函数的方式获取超参数" class="headerlink" title="二、以函数的方式获取超参数"></a>二、以函数的方式获取超参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_args</span>():</span><br>    parser = argparse.ArgumentParser(description=<span class="hljs-string">&#x27;Train a Fast R-CNN network&#x27;</span>)<br>    parser.add_argument(<span class="hljs-string">&#x27;--dataset&#x27;</span>, dest=<span class="hljs-string">&#x27;dataset&#x27;</span>,<br>                       <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;training dataset&#x27;</span>,<br>                       default=<span class="hljs-string">&#x27;pascal_voc&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>)<br>    parser.add_argument(<span class="hljs-string">&#x27;--net&#x27;</span>, dest=<span class="hljs-string">&#x27;net&#x27;</span>,<br>                     <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;vgg16, vggm&#x27;</span>,<br>                     default=<span class="hljs-string">&#x27;vgg16&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>)<br>    parser.add_argument(<span class="hljs-string">&#x27;--start_epoch&#x27;</span>, dest=<span class="hljs-string">&#x27;start_epoch&#x27;</span>,<br>                       <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;starting epoch&#x27;</span>,<br>                       default=<span class="hljs-number">1</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>)<br>    parser.add_argument(<span class="hljs-string">&#x27;--epochs&#x27;</span>, dest=<span class="hljs-string">&#x27;max_epochs&#x27;</span>,<br>                       <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;number of epochs to train&#x27;</span>,<br>                       default=<span class="hljs-number">20</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>)<br>    parser.add_argument(<span class="hljs-string">&#x27;--disp_interval&#x27;</span>, dest=<span class="hljs-string">&#x27;disp_interval&#x27;</span>,<br>                       <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;number of iterations to display&#x27;</span>,<br>                       default=<span class="hljs-number">100</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>)<br>    parser.add_argument(<span class="hljs-string">&#x27;--checkpoint_interval&#x27;</span>, dest=<span class="hljs-string">&#x27;checkpoint_interval&#x27;</span>,<br>                       <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;number of iterations to display&#x27;</span>,<br>                       default=<span class="hljs-number">1000</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>)<br>    parser.add_argument(<span class="hljs-string">&#x27;--save_dir&#x27;</span>, dest=<span class="hljs-string">&#x27;save_dir&#x27;</span>,<br>                       <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;directory to save models&#x27;</span>, default=<span class="hljs-string">&quot;models&quot;</span>,<br>                       <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>)<br>    parser.add_argument(<span class="hljs-string">&#x27;--nw&#x27;</span>, dest=<span class="hljs-string">&#x27;num_workers&#x27;</span>,<br>                       <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;number of worker to load data&#x27;</span>,<br>                       default=<span class="hljs-number">0</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>)<br>    parser.add_argument(<span class="hljs-string">&#x27;--cuda&#x27;</span>, dest=<span class="hljs-string">&#x27;cuda&#x27;</span>,<br>                       <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;whether use CUDA&#x27;</span>,<br>                       action=<span class="hljs-string">&#x27;store_true&#x27;</span>)<br>    parser.add_argument(<span class="hljs-string">&#x27;--ls&#x27;</span>, dest=<span class="hljs-string">&#x27;large_scale&#x27;</span>,<br>                       <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;whether use large imag scale&#x27;</span>,<br>                       action=<span class="hljs-string">&#x27;store_true&#x27;</span>)                      <br>    parser.add_argument(<span class="hljs-string">&#x27;--mGPUs&#x27;</span>, dest=<span class="hljs-string">&#x27;mGPUs&#x27;</span>,<br>                       <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;whether use multiple GPUs&#x27;</span>,<br>                       action=<span class="hljs-string">&#x27;store_true&#x27;</span>)<br>    parser.add_argument(<span class="hljs-string">&#x27;--bs&#x27;</span>, dest=<span class="hljs-string">&#x27;batch_size&#x27;</span>,<br>                       <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;batch_size, this should be 2n&#x27;</span>,<br>                       default=<span class="hljs-number">1</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>)<br>    parser.add_argument(<span class="hljs-string">&#x27;--cag&#x27;</span>, dest=<span class="hljs-string">&#x27;class_agnostic&#x27;</span>,<br>                       <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;whether perform class_agnostic bbox regression&#x27;</span>,<br>                       action=<span class="hljs-string">&#x27;store_true&#x27;</span>)<br>    parser.add_argument(<span class="hljs-string">&#x27;--model&#x27;</span>, default=<span class="hljs-string">&#x27;oicr&#x27;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>)<br>    <br>    <span class="hljs-comment"># config optimization</span><br>    parser.add_argument(<span class="hljs-string">&#x27;--o&#x27;</span>, dest=<span class="hljs-string">&#x27;optimizer&#x27;</span>,<br>                       <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;training optimizer&#x27;</span>,<br>                       default=<span class="hljs-string">&quot;sgd&quot;</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>)<br>    parser.add_argument(<span class="hljs-string">&#x27;--lr&#x27;</span>, dest=<span class="hljs-string">&#x27;lr&#x27;</span>,<br>                       <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;starting learning rate&#x27;</span>,<br>                       default=<span class="hljs-number">0.001</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">float</span>)<br>    parser.add_argument(<span class="hljs-string">&#x27;--lr_decay_step&#x27;</span>, dest=<span class="hljs-string">&#x27;lr_decay_step&#x27;</span>,<br>                       <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;step to do learning rate decay, unit is epoch&#x27;</span>,<br>                       default=<span class="hljs-number">5</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>)<br>    parser.add_argument(<span class="hljs-string">&#x27;--lr_decay_gamma&#x27;</span>, dest=<span class="hljs-string">&#x27;lr_decay_gamma&#x27;</span>,<br>                       <span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;learning rate decay ratio&#x27;</span>,<br>                       default=<span class="hljs-number">0.1</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">float</span>)<br><br>    args = parser.parse_args()<br>    <span class="hljs-keyword">return</span> args<br><br><span class="hljs-comment"># 在train.py文件中的main函数中调用</span><br>args = parse_args()<br><span class="hljs-comment"># args.net、args.model等等</span><br></code></pre></td></tr></table></figure><h3 id="三、定义自己的模型"><a href="#三、定义自己的模型" class="headerlink" title="三、定义自己的模型"></a>三、定义自己的模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">YOUR_MODEL</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, base_net=<span class="hljs-string">&quot;vgg&quot;</span></span>):</span><br>        <span class="hljs-built_in">super</span>(YOUR_MODEL,self).__init__()<br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        assert base_net in &#123;&quot;alexnet&quot;, &quot;vgg&quot;&#125;, &quot;`base_net` should be in &#123;alexnet, vgg&#125;&quot;</span><br><span class="hljs-string"></span><br><span class="hljs-string">        self.base_net = base_net</span><br><span class="hljs-string"></span><br><span class="hljs-string">        if self.base_net == &quot;alexnet&quot;:</span><br><span class="hljs-string">            self.base = alexnet(pretrained=False)</span><br><span class="hljs-string">            state_path = os.path.join(BASE_DIR, &quot;states&quot;, &quot;alexnet-owt-4df8aa71.pth&quot;)</span><br><span class="hljs-string">            self.roi_output_size = (6, 6)</span><br><span class="hljs-string">        else:</span><br><span class="hljs-string">            self.base = vgg16(pretrained=False)</span><br><span class="hljs-string">            state_path = os.path.join(BASE_DIR, &quot;states&quot;, &quot;vgg16-397923af.pth&quot;)</span><br><span class="hljs-string">            self.roi_output_size = (7, 7)</span><br><span class="hljs-string"></span><br><span class="hljs-string">        self.base.load_state_dict(torch.load(state_path))</span><br><span class="hljs-string">        self.features = self.base.features[:-1]</span><br><span class="hljs-string"></span><br><span class="hljs-string">        self.fcs = self.base.classifier[:-1]</span><br><span class="hljs-string">        self.fc_c = nn.Linear(4096, 20)</span><br><span class="hljs-string">        self.fc_d = nn.Linear(4096, 20)</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, batch_imgs, batch_boxes, batch_scores</span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        # assume batch size is 1</span><br><span class="hljs-string">        batch_boxes = [batch_boxes[0]]</span><br><span class="hljs-string"></span><br><span class="hljs-string">        out = self.features(batch_imgs)  # [1, 256, 21, 29]</span><br><span class="hljs-string"></span><br><span class="hljs-string">        out = roi_pool(out, batch_boxes, self.roi_output_size, 1.0 / 16)</span><br><span class="hljs-string">        out = out.view(len(batch_boxes[0]), -1)</span><br><span class="hljs-string"></span><br><span class="hljs-string">        out = out * batch_scores[0]  # apply box scores</span><br><span class="hljs-string">        out = self.fcs(out)  # [4000, 4096]</span><br><span class="hljs-string"></span><br><span class="hljs-string">        classification_scores = F.softmax(self.fc_c(out), dim=1)</span><br><span class="hljs-string">        detection_scores = F.softmax(self.fc_d(out), dim=0)</span><br><span class="hljs-string">        combined_scores = classification_scores * detection_scores</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">return</span> combined_scores<br>        <br></code></pre></td></tr></table></figure><h3 id="四、定义早停类-可选"><a href="#四、定义早停类-可选" class="headerlink" title="四、定义早停类(可选)"></a>四、定义早停类(可选)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EarlyStopping</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,patience=<span class="hljs-number">7</span>,verbose=<span class="hljs-literal">False</span>,delta=<span class="hljs-number">0</span></span>):</span><br>        self.patience = patience<br>        self.verbose = verbose<br>        self.counter = <span class="hljs-number">0</span><br>        self.best_score = <span class="hljs-literal">None</span><br>        self.early_stop = <span class="hljs-literal">False</span><br>        self.val_loss_min = np.Inf<br>        self.delta = delta<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self,val_loss,model,path</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;val_loss=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(val_loss))<br>        score = -val_loss<br>        <span class="hljs-keyword">if</span> self.best_score <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.best_score = score<br>            self.save_checkpoint(val_loss,model,path)<br>        <span class="hljs-keyword">elif</span> score &lt; self.best_score+self.delta:<br>            self.counter+=<span class="hljs-number">1</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;EarlyStopping counter: <span class="hljs-subst">&#123;self.counter&#125;</span> out of <span class="hljs-subst">&#123;self.patience&#125;</span>&#x27;</span>)<br>            <span class="hljs-keyword">if</span> self.counter&gt;=self.patience:<br>                self.early_stop = <span class="hljs-literal">True</span><br>        <span class="hljs-keyword">else</span>:<br>            self.best_score = score<br>            self.save_checkpoint(val_loss,model,path)<br>            self.counter = <span class="hljs-number">0</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_checkpoint</span>(<span class="hljs-params">self,val_loss,model,path</span>):</span><br>        <span class="hljs-keyword">if</span> self.verbose:<br>            <span class="hljs-built_in">print</span>(<br>                <span class="hljs-string">f&#x27;Validation loss decreased (<span class="hljs-subst">&#123;self.val_loss_min:<span class="hljs-number">.6</span>f&#125;</span> --&gt; <span class="hljs-subst">&#123;val_loss:<span class="hljs-number">.6</span>f&#125;</span>).  Saving model ...&#x27;</span>)<br>        torch.save(model.state_dict(), path+<span class="hljs-string">&#x27;/&#x27;</span>+<span class="hljs-string">&#x27;model_checkpoint.pth&#x27;</span>)<br>        self.val_loss_min = val_loss<br></code></pre></td></tr></table></figure><h3 id="五、定义自己的数据集类Dataset"><a href="#五、定义自己的数据集类Dataset" class="headerlink" title="五、定义自己的数据集类Dataset"></a>五、定义自己的数据集类Dataset</h3><p>为了能使自定义的dataset类能够用<code>DataLoader</code>进行batch读取：</p><p>重点：</p><p>1）必须继承<code>torch.utils.data.Dataset</code></p><p>2）必须覆写其中的两个方法：<code>__len__</code>用于返回整个数据集大小、</p><p>​                                                <code>__getitem__</code>用于索引一些数据，使<code>dataset[i]</code>放回第i个样本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader,Dataset<br><span class="hljs-keyword">from</span> skimage <span class="hljs-keyword">import</span> io,transform<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnimalData</span>(<span class="hljs-params">Dataset</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, root_dir, transform=<span class="hljs-literal">None</span></span>):</span> <span class="hljs-comment">#__init__是初始化该类的一些基础参数</span><br>        self.root_dir = root_dir   <br>        self.transform = transform <br>        self.images = os.listdir(self.root_dir)<span class="hljs-comment"># 目录里的所有文件名</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.images) <span class="hljs-comment"># 返回整个数据集大小</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self,index</span>):</span><br>        image_index = self.images[index]<span class="hljs-comment"># 根据索引获取文件名</span><br>        img_path = os.path.join(self.root_dir, image_index)<span class="hljs-comment"># 获取索引为index的图片的路径名</span><br>        img = io.imread(img_path)<span class="hljs-comment"># 读取该图片；也可以用cv2.imread()</span><br>        label = img_path.split(<span class="hljs-string">&#x27;\\&#x27;</span>)[-<span class="hljs-number">1</span>].split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">0</span>]<span class="hljs-comment"># 根据该图片的路径名获取该图片的label，具体根据路径名进行分割。我这里是&quot;E:\\Python Project\\Pytorch\\dogs-vs-cats\\train\\cat.0.jpg&quot;，所以先用&quot;\\&quot;分割，选取最后一个为[&#x27;cat.0.jpg&#x27;]，然后使用&quot;.&quot;分割，选取[cat]作为该图片的标签</span><br>        sample = &#123;<span class="hljs-string">&#x27;image&#x27;</span>:img,<span class="hljs-string">&#x27;label&#x27;</span>:label&#125;<span class="hljs-comment"># 根据图片和标签创建字典</span><br>        <br>        <span class="hljs-string">&#x27;&#x27;&#x27;该步可以在DataLoader中完成</span><br><span class="hljs-string">        if self.transform:</span><br><span class="hljs-string">            sample = self.transform(sample)#对样本进行变换</span><br><span class="hljs-string">            &#x27;&#x27;&#x27;</span><br>        <span class="hljs-keyword">return</span> sample <span class="hljs-comment">#返回该样本</span><br></code></pre></td></tr></table></figure><p>综上，在自定义数据集类中，要完成对“如何读取数据”进行定义——这一步通常通过操纵路径完成！</p><p>注意理解：定义如何读取数据，不等于此时已经读取了数据；我的理解：是在后面<code>DataLoader</code>读取batch时才驱使数据集类调用<code>__getitem__</code>函数一个一个进行图片读取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    data = AnimalData(<span class="hljs-string">&#x27;E:/Python Project/PyTorch/dogs-vs-cats/train&#x27;</span>,transform=<span class="hljs-literal">None</span>)<br>    dataloader = DataLoader(data,batch_size=<span class="hljs-number">128</span>,shuffle=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">for</span> i_batch,batch_data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(dataloader):<br>        <span class="hljs-built_in">print</span>(i_batch)<span class="hljs-comment"># 打印batch编号</span><br>        <span class="hljs-built_in">print</span>(batch_data[<span class="hljs-string">&#x27;image&#x27;</span>].size())<span class="hljs-comment"># 打印该batch里面图片的大小</span><br>        <span class="hljs-built_in">print</span>(batch_data[<span class="hljs-string">&#x27;label&#x27;</span>])<span class="hljs-comment"># 打印该batch里面图片的标签</span><br></code></pre></td></tr></table></figure><p>最后可以打印什么内容，是由<code>__getitem__</code>的返回值所决定的，在本例中，返回了字典sample，key值有两个：image和label</p><h3 id="六、实例化模型，设置loss、优化器等"><a href="#六、实例化模型，设置loss、优化器等" class="headerlink" title="六、实例化模型，设置loss、优化器等"></a>六、实例化模型，设置loss、优化器等</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">model = YOUR_MODEL().to(args.device)<br>criterion = torch.nn.MSELoss()<br>optimizer = torch.optim.Adam(YOUR_MODEL.parameters(), lr=args.learning_rate)<br><span class="hljs-comment"># scheduler = lr_scheduler.MultiStepLR(optimizer,milestones=[20,80],gamma = 0.9)  学习率衰减策略</span><br><br>train_loss = []<br>valid_loss = []<br>train_epochs_loss = []<br>valid_epochs_loss = []<br><br><span class="hljs-comment"># early_stopping = EarlyStopping(patience=args.patience,verbose=True)</span><br></code></pre></td></tr></table></figure><h3 id="七、开始训练、调整lr"><a href="#七、开始训练、调整lr" class="headerlink" title="七、开始训练、调整lr"></a>七、开始训练、调整lr</h3><p>训练的代码可以直接放在main函数中，也可以定义为train函数使用，此处提供最基本的训练代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(args.epochs):<br>    Your_model.train()<br>    train_epoch_loss = []<br>    <span class="hljs-keyword">for</span> idx,(data_x,data_y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_dataloader,<span class="hljs-number">0</span>):<br>        data_x = data_x.to(torch.float32).to(args.device)<br>        data_y = data_y.to(torch.float32).to(args.device)<br>        outputs = Your_model(data_x)<br>        optimizer.zero_grad()<br>        loss = criterion(data_y,outputs)<br>        loss.backward()<br>        optimizer.step()<br>        train_epoch_loss.append(loss.item())<br>        train_loss.append(loss.item())<br>        <span class="hljs-keyword">if</span> idx%(<span class="hljs-built_in">len</span>(train_dataloader)//<span class="hljs-number">2</span>)==<span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;epoch=&#123;&#125;/&#123;&#125;,&#123;&#125;/&#123;&#125;of train, loss=&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>                epoch, args.epochs, idx, <span class="hljs-built_in">len</span>(train_dataloader),loss.item()))<br>    train_epochs_loss.append(np.average(train_epoch_loss))<span class="hljs-comment"># epoch的loss是按列表存储的，所以用np.average</span><br>    <span class="hljs-comment"># 如果使用train_epoch_loss += loss.item() 即用一个变量存储，则此处用train_epoch_loss / n</span><br></code></pre></td></tr></table></figure><p>测试集上进行测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">Your_model.<span class="hljs-built_in">eval</span>()<br>valid_epoch_loss = []<br><span class="hljs-keyword">for</span> idx,(data_x,data_y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(valid_dataloader,<span class="hljs-number">0</span>):<br>    data_x = data_x.to(torch.float32).to(args.device)<br>    data_y = data_y.to(torch.float32).to(args.device)<br>    outputs = Your_model(data_x)<br>    loss = criterion(outputs,data_y)<br>    valid_epoch_loss.append(loss.item())<br>    valid_loss.append(loss.item())<br>valid_epochs_loss.append(np.average(valid_epoch_loss))<br></code></pre></td></tr></table></figure><p>手动调整lr：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">lr_adjust = &#123;<br>           <span class="hljs-number">2</span>: <span class="hljs-number">5e-5</span>, <span class="hljs-number">4</span>: <span class="hljs-number">1e-5</span>, <span class="hljs-number">6</span>: <span class="hljs-number">5e-6</span>, <span class="hljs-number">8</span>: <span class="hljs-number">1e-6</span>,<br>           <span class="hljs-number">10</span>: <span class="hljs-number">5e-7</span>, <span class="hljs-number">15</span>: <span class="hljs-number">1e-7</span>, <span class="hljs-number">20</span>: <span class="hljs-number">5e-8</span><br>       &#125;<br>   <span class="hljs-keyword">if</span> epoch <span class="hljs-keyword">in</span> lr_adjust.keys():<br>       lr = lr_adjust[epoch]<br>       <span class="hljs-keyword">for</span> param_group <span class="hljs-keyword">in</span> optimizer.param_groups:<br>           param_group[<span class="hljs-string">&#x27;lr&#x27;</span>] = lr<br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Updating learning rate to &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(lr))<br></code></pre></td></tr></table></figure><h3 id="八、绘图"><a href="#八、绘图" class="headerlink" title="八、绘图"></a>八、绘图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.figure(figsize=(<span class="hljs-number">12</span>,<span class="hljs-number">4</span>))<br>plt.subplot(<span class="hljs-number">121</span>)<br>plt.plot(train_loss[:])<br>plt.title(<span class="hljs-string">&quot;train_loss&quot;</span>)<br>plt.subplot(<span class="hljs-number">122</span>)<br>plt.plot(train_epochs_loss[<span class="hljs-number">1</span>:],<span class="hljs-string">&#x27;-o&#x27;</span>,label=<span class="hljs-string">&quot;train_loss&quot;</span>)<br>plt.plot(valid_epochs_loss[<span class="hljs-number">1</span>:],<span class="hljs-string">&#x27;-o&#x27;</span>,label=<span class="hljs-string">&quot;valid_loss&quot;</span>)<br>plt.title(<span class="hljs-string">&quot;epochs_loss&quot;</span>)<br>plt.legend()<br>plt.show()<br></code></pre></td></tr></table></figure><h3 id="九、预测"><a href="#九、预测" class="headerlink" title="九、预测"></a>九、预测</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 此处可定义一个预测集的Dataloader。也可以直接将你的预测数据reshape,添加batch_size=1</span><br>Your_model.<span class="hljs-built_in">eval</span>()<br>predict = Your_model(data)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Deep Learning-Objects Detection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL基础-廖雪峰教程</title>
    <link href="/2021/08/21/SQL%E5%9F%BA%E7%A1%80-%E5%BB%96%E9%9B%AA%E5%B3%B0%E6%95%99%E7%A8%8B/"/>
    <url>/2021/08/21/SQL%E5%9F%BA%E7%A1%80-%E5%BB%96%E9%9B%AA%E5%B3%B0%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>本文记录很基础的SQL概念、基本语句。</p><p>教程参考<a href="https://www.liaoxuefeng.com/wiki/1177760294764384">SQL教程 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><span id="more"></span><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>1.数据库是什么？</p><p>一种专门管理数据的软件，应用程序不需要自己管理数据，而是通过数据库软件提供的接口来读写数据。至于数据本身如何存储到文件，那是数据库软件的事情，应用程序自己并不关心。</p><p>2.数据库模型有哪些？</p><p>层次模型、网状模型、关系模型。</p><p>随着时间的推移和市场竞争，最终，基于<strong>关系模型</strong>的<strong>关系数据库</strong>获得了绝对市场份额。</p><p>3.关系数据库</p><p>关系数据库就像一个二维表格，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等：</p><p><img src="/images/image-20210820151238143.png" alt="image-20210820151238143"></p><p>通常来说，<code>BIGINT</code>能满足整数存储的需求，<code>VARCHAR(N)</code>能满足字符串存储的需求，这两种类型是使用最广泛的。</p><p>4.主流关系数据库</p><p>目前，主流的关系数据库主要分为以下几类：</p><ol><li>商用数据库，例如：<a href="https://www.oracle.com/">Oracle</a>，<a href="https://www.microsoft.com/sql-server/">SQL Server</a>，<a href="https://www.ibm.com/db2/">DB2</a>等；</li><li>开源数据库，例如：<a href="https://www.mysql.com/">MySQL</a>，<a href="https://www.postgresql.org/">PostgreSQL</a>等；</li><li>桌面数据库，以微软<a href="https://products.office.com/access">Access</a>为代表，适合桌面应用程序使用；</li><li>嵌入式数据库，以<a href="https://sqlite.org/">Sqlite</a>为代表，适合手机应用和桌面程序。</li></ol><p>5.什么是SQL？</p><p>SQL是结构化查询语言的缩写，用来访问和操作数据库系统。SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。</p><p>SQL语言关键字不区分大小写！！！但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。</p><p>6.MySQL</p><p>MySQL是目前应用最广泛的开源关系数据库。MySQL本身实际上只是一个SQL接口，它的内部还包含了多种数据引擎，常用的包括：</p><ul><li>InnoDB：由Innobase Oy公司开发的一款支持事务的数据库引擎，2006年被Oracle收购；</li><li>MyISAM：MySQL早期集成的默认数据库引擎，不支持事务。</li></ul><p>使用MySQL时，不同的表还可以使用不同的数据库引擎。如果你不知道应该采用哪种引擎，记住总是选择<code>InnoDB</code>就好了。</p><h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><p>1.关系模型本质上就是<strong>若干个存储数据的二维表</strong>，可以把它们看作很多Excel表。</p><p>表的每一行称为记录（Record），记录是一个逻辑意义上的数据。</p><p>表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为<code>NULL</code>。</p><p><code>通常，字段应避免允许为NULL，可以加快查询速度</code></p><p>2.表与表之间的关系</p><p>通常有<code>一对一</code>、<code>一对多</code>、<code>多对一</code>，这些关系是通过主键、外键来维护的。</p><p><strong>3.主键</strong></p><p>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为<em>主键</em>。</p><p>选取主键的一个基本原则是：不使用任何业务相关的字段作为主键。</p><p>因此，身份证号、手机号、邮箱地址这些看上去可以唯一的字段，均<em>不可</em>用作主键。</p><p>作为主键最好是完全业务无关的字段，我们一般把这个字段命名为<code>id</code>。常见的可作为<code>id</code>字段的类型有：</p><ol><li>自增整数类型<code>BIGINT</code>：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；</li><li>全局唯一<code>GUID</code>类型：使用一种全局唯一的字符串作为主键，类似<code>8f55d96b-8acc-4636-8cb8-76bf8abc2f57</code>。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。</li></ol><p>对于大部分应用来说，通常自增类型的主键就能满足需求。我们在<code>students</code>表中定义的主键也是<code>BIGINT NOT NULL AUTO_INCREMENT</code>类型。</p><p>拓展：联合主键。关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。</p><p><strong>4.外键</strong></p><p>（1）一对多关系</p><p>在<code>students</code>表中，通过<code>class_id</code>的字段，可以<strong>把数据与另一张表关联起来</strong>，这种列称为<code>外键</code>。</p><p>外键的实现：通过定义“外键约束”来实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE students<br>ADD CONSTRAINT fk_class_id# 添加名为“fk_class_id”的外键约束<br>FOREIGN KEY (class_id) # 指定class_id列作为外键<br>REFERENCES classes (id);# 指定该外键关联到：classes表中的id列<br></code></pre></td></tr></table></figure><p>要删除一个外键约束，也是通过<code>ALTER TABLE</code>实现的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE students<br>DROP FOREIGN KEY fk_class_id;<br></code></pre></td></tr></table></figure><p>（2）多对多关系</p><p>多对多关系实际上是通过两个一对多关系实现的，即通过一个<strong>中间表</strong>，关联两个一对多关系，就形成了多对多关系。</p><p>（3）一对一关系</p><p>既然是一对一关系，那为啥不给<code>students</code>表增加一个<code>mobile</code>列，这样就能合二为一了？</p><p>如果业务允许，完全可以把两个表合为一个表。但是，有些时候，如果某个学生没有手机号，那么，<code>contacts</code>表就不存在对应的记录。实际上，一对一关系准确地说，是<code>contacts</code>表一对一对应<code>students</code>表。</p><p>还有一些应用会把一个大表拆成两个一对一的表，目的是把经常读取和不经常读取的字段分开，以获得更高的性能。例如，把一个大的用户表分拆为用户基本信息表<code>user_info</code>和用户详细信息表<code>user_profiles</code>，大部分时候，只需要查询<code>user_info</code>表，并不需要查询<code>user_profiles</code>表，这样就提高了查询速度。</p><p>拓展：由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。</p><p>5.索引</p><p>通过对数据库表创建索引，可以提高查询速度。</p><p>通过创建唯一索引，可以保证某一列的值具有唯一性。</p><p>数据库索引对于用户和应用程序来说都是透明的，即无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。</p><h2 id="数据库操作——查询"><a href="#数据库操作——查询" class="headerlink" title="数据库操作——查询"></a>数据库操作——查询</h2><p>数据库基本操作：增删改查</p><h3 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM &lt;表名&gt;<br></code></pre></td></tr></table></figure><p><code>SELECT</code>是关键字，表示将要执行一个查询，<code>*</code>表示“所有列”，<code>FROM</code>表示将要从哪个表查询，本例中是<code>students</code>表。</p><p><code>SELECT</code>也可以不使用FROM关键字，许多检测工具会执行一条<code>SELECT 1;</code>来测试数据库连接。</p><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><p>SELECT语句可以通过<code>WHERE</code>条件来设定查询条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM students WHERE score &gt;&#x3D; 80;<br></code></pre></td></tr></table></figure><p>条件表达式可以用AND, OR, NOT:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM students WHERE (score &lt; 80 OR score &gt; 90) AND gender &#x3D; &#39;M&#39;;<br></code></pre></td></tr></table></figure><p>如果不加括号，条件运算按照<code>NOT</code>、<code>AND</code>、<code>OR</code>的优先级进行，即<code>NOT</code>优先级最高，其次是<code>AND</code>，最后是<code>OR</code>。</p><p>常用条件表达式：</p><p><img src="/images/image-20210820173433363.png" alt="image-20210820173433363"></p><h3 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h3><p>使用<code>SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt;</code>选出的记录所有列与原表的所有列都一一对应。</p><p>如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用<code>SELECT 列1, 列2, 列3 FROM ...</code>，让结果集仅包含指定列。这种操作称为投影查询。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT id, score, name FROM students;<br></code></pre></td></tr></table></figure><p>还可以给每一列起个别名，它的语法是<code>SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...</code></p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>使用SELECT查询时，是根据主键排序的。</p><p>加上<code>ORDER BY</code>子句，通过其它列排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT id, name, gender, score FROM students ORDER BY score;<br></code></pre></td></tr></table></figure><p>可以加上<code>DESC</code>表示“倒序”：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT id, name, gender, score FROM students ORDER BY score DESC;<br></code></pre></td></tr></table></figure><p>如果<code>score</code>列有相同的数据，要进一步排序，可以继续添加列名。例如，使用<code>ORDER BY score DESC, gender</code>表示先按<code>score</code>列倒序，如果有相同分数的，再按<code>gender</code>列排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;<br></code></pre></td></tr></table></figure><p>如果有<code>WHERE</code>子句，那么<code>ORDER BY</code>子句要放到<code>WHERE</code>子句后面。例如，查询一班的学生成绩，并按照倒序排序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT id, name, gender, score<br>FROM students<br>WHERE class_id &#x3D; 1<br>ORDER BY score DESC;<br></code></pre></td></tr></table></figure><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。</p><p>通过<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>子句实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT id, name, gender, score<br>FROM students<br>ORDER BY score DESC<br>LIMIT 3 OFFSET 0;<br></code></pre></td></tr></table></figure><p>上述查询<code>LIMIT 3 OFFSET 0</code>表示，对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。</p><p>分页查询的关键在于，首先要确定每页需要显示的结果数量<code>pageSize</code>（这里是3），然后根据当前页的索引<code>pageIndex</code>（从1开始），确定<code>LIMIT</code>和<code>OFFSET</code>应该设定的值：</p><ul><li><code>LIMIT</code>总是设定为<code>pageSize</code>；</li><li><code>OFFSET</code>计算公式为<code>pageSize * (pageIndex - 1)</code>。</li></ul><p>也即：<code>LIMIT 3 OFFSET 3</code>显示第二页，<code>LIMIT 3 OFFSET 6</code>显示第三页</p><p>拓展：<code>LIMIT 15 OFFSET 30</code>还可以简写成<code>LIMIT 30, 15</code></p><h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><p>对于<strong>统计总数、平均数这类计算</strong>，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(*) FROM students;<br></code></pre></td></tr></table></figure><p>一般会给统计量一个别名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(*) num FROM students;<br></code></pre></td></tr></table></figure><p>此外，聚合函数还可以搭配<code>WHERE</code>条件。</p><p>除了<code>COUNT()</code>函数外，SQL还提供了如下聚合函数：</p><p><img src="/images/image-20210820180913993.png" alt="image-20210820180913993"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT AVG(score) average FROM students WHERE gender &#x3D; &#39;M&#39;;<br></code></pre></td></tr></table></figure><p>要特别注意：如果聚合查询的<code>WHERE</code>条件没有匹配到任何行，<code>COUNT()</code>会返回0，而<code>SUM()</code>、<code>AVG()</code>、<code>MAX()</code>和<code>MIN()</code>会返回<code>NULL</code>：</p><p>聚合拓展：<strong>分组聚合</strong></p><p>按照某一条件先分组，再进行相关统计量统计。比如：分别查询1、2、3班的人数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;<br></code></pre></td></tr></table></figure><p><code>GROUP BY</code>子句指定了按<code>class_id</code>分组，因此，执行该<code>SELECT</code>语句时，会把<code>class_id</code>相同的列先分组，再分别计算，因此，得到了3行结果。</p><p>同时，为了看出计数是哪个班级的，把class_id也选出来</p><p>例子：查每个班的平均分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT class_id, AVG(score) average FROM students GROUP BY class_id;<br></code></pre></td></tr></table></figure><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p>SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM students, classes;<br></code></pre></td></tr></table></figure><p>多表查询的结果集：结果集的列数是<code>students</code>表和<code>classes</code>表的列数之和，行数是<code>students</code>表和<code>classes</code>表的行数之积。</p><p>这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。</p><p>通过设置别名，可以来自不同表中名字相同的列得以区分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT<br>    s.id sid,<br>    s.name,<br>    s.gender,<br>    s.score,<br>    c.id cid,<br>    c.name cname<br>FROM students s, classes c;<br></code></pre></td></tr></table></figure><h3 id="多表查询——连接查询"><a href="#多表查询——连接查询" class="headerlink" title="多表查询——连接查询"></a>多表查询——连接查询</h3><p>连接查询对多个表进行JOIN运算，简单地说，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。</p><p>（1）最常用：内连接<code>INNER JOIN</code></p><p>根据<code>students</code>表的<code>class_id</code>，找到<code>classes</code>表对应的行，再取出<code>name</code>列，获得班级名称：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score<br>FROM students s<br>INNER JOIN classes c-- 连接<br>ON s.class_id &#x3D; c.id;-- 连接条件<br></code></pre></td></tr></table></figure><p>注意INNER JOIN查询的写法是：</p><ol><li>先确定主表，仍然使用<code>FROM &lt;表1&gt;</code>的语法；</li><li>再确定需要连接的表，使用<code>INNER JOIN &lt;表2&gt;</code>的语法；</li><li>然后确定连接条件，使用<code>ON &lt;条件...&gt;</code>，这里的条件是<code>s.class_id = c.id</code>，表示<code>students</code>表的<code>class_id</code>列与<code>classes</code>表的<code>id</code>列相同的行需要连接；</li><li>可选：加上<code>WHERE</code>子句、<code>ORDER BY</code>等子句。</li></ol><p>（2）外连接：<code>OUTER JOIN</code></p><p>分为：<code>RIGHT</code>、<code>LEFT</code>、<code>FULL</code></p><p>有RIGHT OUTER JOIN，就有LEFT OUTER JOIN，以及FULL OUTER JOIN。它们的区别是：</p><p>INNER JOIN只返回同时存在于两张表的行数据；</p><p>RIGHT OUTER JOIN返回右表都存在的行。如果某一行仅在右表存在，那么结果集就会以<code>NULL</code>填充剩下的字段；</p><p>LEFT OUTER JOIN则返回左表都存在的行。如果我们给students表增加一行，并添加class_id=5，由于classes表并不存在id=5的行，所以，LEFT OUTER JOIN的结果会增加一行，对应的<code>class_name</code>是<code>NULL</code>：</p><p>FULL OUTER JOIN，它会把两张表的所有记录全部选择出来，并且，自动把对方不存在的列填充为NULL</p><h2 id="数据库操作——增、删、改"><a href="#数据库操作——增、删、改" class="headerlink" title="数据库操作——增、删、改"></a>数据库操作——增、删、改</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>当我们需要向数据库表中插入一条新记录时，就必须使用<code>INSERT</code>语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO students (class_id, name, gender, score) VALUES (2, &#39;大牛&#39;, &#39;M&#39;, 80);<br><br>-- 一次性添加多条记录<br>INSERT INTO students (class_id, name, gender, score) VALUES<br>  (1, &#39;大宝&#39;, &#39;M&#39;, 87),<br>  (2, &#39;二宝&#39;, &#39;M&#39;, 81);<br></code></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>如果要更新数据库表中的记录，我们就必须使用<code>UPDATE</code>语句。</p><p>搭配<code>WHERE</code>子句中写出需要更新的行的筛选条件<code>id=1</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 更新id&#x3D;1的记录为： name&#x3D;大牛， score&#x3D;66<br>UPDATE students SET name&#x3D;&#39;大牛&#39;, score&#x3D;66 WHERE id&#x3D;1;<br></code></pre></td></tr></table></figure><p>在<code>UPDATE</code>语句中，更新字段时可以使用表达式。例如，把所有80分以下的同学的成绩加10分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">UPDATE students SET score&#x3D;score+10 WHERE score&lt;80;<br></code></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>如果要删除数据库表中的记录，我们可以使用<code>DELETE</code>语句。</p><p>和<code>UPDATE</code>用法非常类似，搭配<code>WHERE</code>使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM students WHERE id&gt;&#x3D;5 AND id&lt;&#x3D;7;<br></code></pre></td></tr></table></figure><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><p>前面讲的语法都是<code>SQL</code>，接下来简单介绍MySQL.</p><p>在一个运行MySQL的服务器上，实际上可以创建多个数据库（Database）</p><h3 id="管理MySQL"><a href="#管理MySQL" class="headerlink" title="管理MySQL"></a>管理MySQL</h3><p>1.列出所有数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW DATABASES;<br></code></pre></td></tr></table></figure><p>2.创建新数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; CREATE DATABASE test;<br></code></pre></td></tr></table></figure><p>3.删除数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; DROP DATABASE test;<br></code></pre></td></tr></table></figure><p>4.对一个数据库进行操作时，要首先将其切换为当前数据库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; USE test;<br></code></pre></td></tr></table></figure><p>5.列出当前数据库的所有表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; SHOW TABLES;<br></code></pre></td></tr></table></figure><p>6.查看表的结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql&gt; DESC students;<br></code></pre></td></tr></table></figure><p>7.创建表使用<code>CREATE TABLE</code>语句，而删除表使用<code>DROP TABLE</code>语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE statistics (<br>    id BIGINT NOT NULL AUTO_INCREMENT,-- id自增类型<br>    class_id BIGINT NOT NULL,<br>    average DOUBLE NOT NULL,<br>    PRIMARY KEY (id)-- 设置主键<br>);<br></code></pre></td></tr></table></figure><p>8.修改表</p><p>(1)新增一列<code>birth</code>，使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;<br></code></pre></td></tr></table></figure><p>(2)修改<code>birth</code>列，例如把列名改为<code>birthday</code>，类型改为<code>VARCHAR(20)</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;<br></code></pre></td></tr></table></figure><p>(3)删除列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE students DROP COLUMN birthday;<br></code></pre></td></tr></table></figure><h3 id="实用SQL语句"><a href="#实用SQL语句" class="headerlink" title="实用SQL语句"></a>实用SQL语句</h3><p>参考：<a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1246617682185952">实用SQL语句 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><h2 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h2><h3 id="事务概述"><a href="#事务概述" class="headerlink" title="事务概述"></a>事务概述</h3><p>在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。</p><p>例如，一个转账操作：从A转出后，必须从B转入，不能只执行其中一个；或者二者都失败也行。</p><p>这种把多条语句作为一个整体进行操作的功能，被称为数据库<em>事务</em>。</p><p>对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为<em>隐式事务</em>。</p><p>要手动把多条SQL语句作为一个事务执行，使用<code>BEGIN</code>开启一个事务，使用<code>COMMIT</code>提交一个事务，这种事务被称为<em>显式事务</em>，例如，把上述的转账操作作为一个显式事务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">BEGIN;<br>UPDATE accounts SET balance &#x3D; balance - 100 WHERE id &#x3D; 1;<br>UPDATE accounts SET balance &#x3D; balance + 100 WHERE id &#x3D; 2;<br>COMMIT;<br></code></pre></td></tr></table></figure><p>如果<code>COMMIT</code>语句执行失败了，整个事务也会失败。</p><p>数据库事务是由数据库系统保证的，我们只需要根据业务逻辑使用它就可以。</p><h3 id="SQL的隔离机制"><a href="#SQL的隔离机制" class="headerlink" title="SQL的隔离机制"></a>SQL的隔离机制</h3><p>对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。</p><p>数据库系统提供了4种隔离机制</p><p>1.<code>Read Uncommited</code></p><p>隔离级别最低的一种事务级别。在这种隔离级别下，一个事务会读到另一个事务更新后但未提交的数据，如果另一个事务回滚，那么当前事务读到的数据就是脏数据，这就是<strong>脏读</strong>（Dirty Read）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;<br></code></pre></td></tr></table></figure><p>2.<code>Read Commited</code></p><p>在Read Committed隔离级别下，一个事务可能会遇到不可重复读（Non Repeatable Read）的问题。</p><p>不可重复读是指，在一个事务内，多次读同一数据，在这个事务还没有结束时，如果另一个事务恰好修改了这个数据，那么，在第一个事务中，两次读取的数据就可能不一致。</p><p>3.<code>Repeatable Read</code></p><p>在Repeatable Read隔离级别下，一个事务可能会遇到幻读（Phantom Read）的问题。</p><p>幻读是指，在一个事务中，第一次查询某条记录，发现没有，但是，当试图更新这条不存在的记录时，竟然能成功，并且，再次读取同一条记录，它就神奇地出现了。</p><p>4.<code>Serializable</code></p><p>Serializable是最严格的隔离级别。在Serializable隔离级别下，所有事务按照次序依次执行，因此，脏读、不可重复读、幻读都不会出现。</p><p>虽然Serializable隔离级别下的事务具有最高的安全性，但是，由于事务是串行执行，所以效率会大大下降，应用程序的性能会急剧降低。如果没有特别重要的情景，一般都不会使用Serializable隔离级别。</p><p>如果没有指定隔离级别，数据库就会使用默认的隔离级别。在MySQL中，如果使用<code>InnoDB</code>，默认的隔离级别是<code>Repeatable Read</code>。</p>]]></content>
    
    
    <categories>
      
      <category>Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PyQt5学习笔记</title>
    <link href="/2021/08/20/PyQt5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/20/PyQt5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>b本文记录学习PyQt5过程中的笔记，界面开发工具并不难，了解基本的类间关系、布局关系后，重在实践！</p><p>系统课程参考：<a href="https://www.bilibili.com/video/BV154411n79k?p=1">PyQt5教程，来自网易云课堂_哔哩哔哩_bilibili</a></p><p>额外教程兼项目实战参考：<a href="https://zhuanlan.zhihu.com/p/48373518">PyQt5图形界面编程（目录） - 知乎 (zhihu.com)</a></p><span id="more"></span><h2 id="PyQt5"><a href="#PyQt5" class="headerlink" title="PyQt5"></a>PyQt5</h2><h3 id="一、学习内容与快速入门"><a href="#一、学习内容与快速入门" class="headerlink" title="一、学习内容与快速入门"></a>一、学习内容与快速入门</h3><p>1.</p><p><img src="/images/image-20210809092338029.png" alt="image-20210809092338029"></p><p>2.第一个小程序</p><p>必用两个类：<code>QApplication</code>和<code>Qwidget</code>，<strong>都在<code>PyQT5.QtWidgets</code>模块下</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 代码较简单，略</span><br></code></pre></td></tr></table></figure><h3 id="二、QtDesigner"><a href="#二、QtDesigner" class="headerlink" title="二、QtDesigner"></a>二、QtDesigner</h3><p>1.可视化界面生成的代码.ui转.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 方法一：</span><br>python -m PyQt5.uic.pyuic demo.ui -o demo.py<br><span class="hljs-comment"># 方法二：</span><br>pyuic5 demo.ui -o  demo.py<br></code></pre></td></tr></table></figure><p>在pycharm中创建pyuic的external tool，可以轻松实现上述功能</p><p>2.<strong>布局</strong></p><p>常规：水平布局、垂直布局、栅格布局以及它们的融合、表单布局</p><p>进阶：容器布局、绝对布局</p><p>可先创建布局–&gt;再拖动控件； 也可先拖动控件–&gt;再排列布局</p><p>3.间隔</p><p>布局一般默认会等分间隔，不需要使就要手动添加水平间隔 / 垂直间隔</p><p>4.尺寸策略sizePolicy</p><p>施加布局之后，控件的尺寸会被调整到统一大小，但有时不希望这样</p><p>此时需要用sizePolicy：<strong>一般都用<code>Expanding</code>，</strong>然后通过设置比例来调整大小</p><p>5.设置控件伙伴关系</p><p>后期可通过代码<code>setBuddy()</code>实现</p><p>6.修改控件的Tab顺序</p><p>7.设置信号与槽</p><p>QT的<strong>核心机制</strong>，也是pyqt的核心机制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">信号：是由对象或控件发射出去的消息。<br>按钮的单击事件<br>当单击按钮时，按钮就会向外部发送单击的消息，这些发送出去的信号需要一些代码来拦截，这些代码就是槽<br></code></pre></td></tr></table></figure><h3 id="三、代码开发——窗口"><a href="#三、代码开发——窗口" class="headerlink" title="三、代码开发——窗口"></a>三、代码开发——窗口</h3><p>1.主窗口有3种类型：<code>QMainWindow</code>、<code>QWidget</code>、<code>QDialog</code></p><p>QMainWindow：可以包含菜单栏、工具栏、状态栏和标题栏，是最常见的窗口形式</p><p>QDialog：是对话窗口的基类。没有菜单栏、工具栏、状态栏。</p><p>QWidget：<strong>不确定窗口的用途，就使用QWidget</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> PyQt5.QtWidgets <span class="hljs-keyword">import</span> QMainWindow,QApplication<br><span class="hljs-keyword">from</span> PyQt5.QtGui <span class="hljs-keyword">import</span> QIcon<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstMainWin</span>(<span class="hljs-params">QMainWindow</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(FirstMainWin,self).__init__()<span class="hljs-comment"># 调用父类初始化方法</span><br><br>        <span class="hljs-comment"># 设置主窗口的标题</span><br>        self.setWindowTitle(<span class="hljs-string">&#x27;第一个主窗口应用&#x27;</span>)<br><br>        <span class="hljs-comment"># 设置窗口的尺寸</span><br>        self.resize(<span class="hljs-number">400</span>,<span class="hljs-number">300</span>)<br>        self.status = self.statusBar()<br>        self.status.showMessage(<span class="hljs-string">&#x27;只存在5秒的消息&#x27;</span>,<span class="hljs-number">5000</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app = QApplication(sys.argv)<span class="hljs-comment"># sys.argv参数是来自命令行的参数列表</span><br>    app.setWindowIcon(QIcon(<span class="hljs-string">&#x27;./images/Dragon.ico&#x27;</span>))<span class="hljs-comment"># 设置窗口显示图片</span><br>    main = FirstMainWin()<br>    main.show()<br><br>    sys.exit(app.exec_())<span class="hljs-comment"># 进入应用程序的主循环，窗口的事件处理从此开始</span><br></code></pre></td></tr></table></figure><p>拓展：**常用<code>self.setGeometry(300,300,200,300)</code>**设置窗口的位置、大小</p><p>2.退出应用程序</p><p>以往通过关闭窗口来结束程序，本节通过<strong>窗口中的button</strong>实现。本节代码涉及很多知识点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> PyQt5.QtWidgets <span class="hljs-keyword">import</span> QHBoxLayout,QMainWindow,QApplication,QPushButton,QWidget  <span class="hljs-comment"># 很多模块基本都在QtWidgets下</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuitApplication</span>(<span class="hljs-params">QMainWindow</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(QuitApplication,self).__init__()<br>        self.resize(<span class="hljs-number">300</span>,<span class="hljs-number">120</span>)<br>        self.setWindowTitle(<span class="hljs-string">&#x27;退出应用程序&#x27;</span>)<br>        <span class="hljs-comment"># 添加Button</span><br>        self.button1 = QPushButton(<span class="hljs-string">&#x27;退出应用程序&#x27;</span>)<br>        <span class="hljs-comment"># 将信号与槽关联</span><br>        self.button1.clicked.connect(self.onClick_Button)<br>        <span class="hljs-comment"># self.button1.clicked是一个事件（“单击”事件），也即一个信号</span><br>        <span class="hljs-comment"># self.onClick_Button是一个方法，是下面定义的处理事件的方法，也即一个槽</span><br>        <span class="hljs-comment"># connect方法将 信号和槽 关联起来</span><br>        <br>        layout = QHBoxLayout()<span class="hljs-comment"># 加一个水平布局层</span><br>        layout.addWidget(self.button1)<span class="hljs-comment"># 将button加到该层上</span><br>        <br>        <br>        <span class="hljs-comment"># 一般，窗口都需要一个主框架，一般是QWidget()对象</span><br>        mainFrame = QWidget()<br>        mainFrame.setLayout(layout)<span class="hljs-comment"># 将水平布局放在主框架上</span><br><br>        self.setCentralWidget(mainFrame) <span class="hljs-comment"># 将主框架铺满整个窗口</span><br><br>    <span class="hljs-comment"># 按钮单击事件的方法（自定义的槽）</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">onClick_Button</span>(<span class="hljs-params">self</span>):</span><br>        sender = self.sender()<br>        <span class="hljs-built_in">print</span>(sender.text() + <span class="hljs-string">&#x27; 按钮被按下&#x27;</span>)<br>        app = QApplication.instance()<br>        <span class="hljs-comment"># 退出应用程序</span><br>        app.quit()<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app = QApplication(sys.argv)<br>    main = QuitApplication()<br>    main.show()<br>    sys.exit(app.exec_())<br></code></pre></td></tr></table></figure><p>3.屏幕坐标系</p><p>掌握如何获取相关的数据，在后续设计中会用到</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;1&quot;</span>)<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;widget.x() = %d&quot;</span> % widget.x())    <span class="hljs-comment"># 250 （窗口横坐标）</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;widget.y() = %d&quot;</span> % widget.y())    <span class="hljs-comment"># 200  （窗口纵坐标）</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;widget.width() = %d&quot;</span> % widget.width())   <span class="hljs-comment"># 300（工作区宽度）</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;widget.height() = %d&quot;</span> % widget.height()) <span class="hljs-comment"># 240 （工作区高度）</span><br><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;2&quot;</span>)<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;widget.geometry().x() = %d&quot;</span> % widget.geometry().x()) <span class="hljs-comment"># 250 （工作区横坐标）</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;widget.geometry().y() = %d&quot;</span> % widget.geometry().y()) <span class="hljs-comment"># 222  （工作区纵坐标）</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;widget.geometry().width() = %d&quot;</span> % widget.geometry().width() )  <span class="hljs-comment"># 300（工作区宽度）</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;widget.geometry().height() = %d&quot;</span> % widget.geometry().height()) <span class="hljs-comment"># 240 （工作区高度）</span><br><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;3&quot;</span>)<br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;widget.frameGeometry().x() = %d&quot;</span> % widget.frameGeometry().x())  <span class="hljs-comment"># 250 （窗口横坐标）</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;widget.frameGeometry().y() = %d&quot;</span> % widget.frameGeometry().y())  <span class="hljs-comment"># 200  （窗口纵坐标）</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;widget.frameGeometry().width() = %d&quot;</span> % widget.frameGeometry().width() )  <span class="hljs-comment"># 300（窗口宽度）</span><br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;widget.frameGeometry().height() = %d&quot;</span> % widget.frameGeometry().height()) <span class="hljs-comment"># 262（窗口高度）</span><br></code></pre></td></tr></table></figure><p>工作区：即不含标题栏的部分； 窗口指整个窗口</p><p>4.控件添加提示信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用PyQt5.QtWidgets.QToolTip</span><br>self.button1.setToolTip(<span class="hljs-string">&#x27;这是一个按钮，Are you ok？&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="四、代码开发——常用控件"><a href="#四、代码开发——常用控件" class="headerlink" title="四、代码开发——常用控件"></a>四、代码开发——常用控件</h3><p>1.QLabel</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">QLabel控件<br><br>setAlignment()：设置文本的对齐方式<br>setIndent()：设置文本缩进<br>text()：获取文本内容<br>setBuddy()：设置伙伴关系<br>setText()：设置文本内容<br>selectedText()：返回所选择的字符<br>setWordWrap()：设置是否允许换行<br><br>QLabel常用的信号（事件）：<br><span class="hljs-number">1.</span>  当鼠标滑过QLabel控件时触发：linkHovered<br><span class="hljs-number">2.</span>  当鼠标单击QLabel控件时触发：linkActivated<br><br><span class="hljs-comment"># 代码略</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># QLabel与伙伴控件</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QLabelBuddy</span>(<span class="hljs-params">QDialog</span>) :</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(QLabelBuddy,self).__init__()<br>        self.initUI()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.setWindowTitle(<span class="hljs-string">&#x27;QLabel与伙伴控件&#x27;</span>)<br><br>        nameLabel = QLabel(<span class="hljs-string">&#x27;&amp;Name&#x27;</span>,self)<span class="hljs-comment"># 热键&amp;</span><br>        nameLineEdit = QLineEdit(self)<br>        <span class="hljs-comment"># 设置伙伴控件</span><br>        nameLabel.setBuddy(nameLineEdit)<br><br>        passwordLabel = QLabel(<span class="hljs-string">&#x27;&amp;Password&#x27;</span>,self)<br>        passwordLineEdit = QLineEdit(self)<br>        <span class="hljs-comment"># 设置伙伴控件</span><br>        passwordLabel.setBuddy(passwordLineEdit)<br><br>        btnOK = QPushButton(<span class="hljs-string">&#x27;&amp;OK&#x27;</span>)<br>        btnCancel = QPushButton(<span class="hljs-string">&#x27;&amp;Cancel&#x27;</span>)<br><br>        mainLayout = QGridLayout(self)<span class="hljs-comment"># 栅格布局！</span><br>        mainLayout.addWidget(nameLabel,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>        mainLayout.addWidget(nameLineEdit,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<span class="hljs-comment"># 一般有5个参数，(name,row,column,占用rows，占用columns)</span><br><br>        mainLayout.addWidget(passwordLabel,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>        mainLayout.addWidget(passwordLineEdit,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br><br>        mainLayout.addWidget(btnOK,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)<br>        mainLayout.addWidget(btnCancel,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app = QApplication(sys.argv)<br>    main = QLabelBuddy()<br>    main.show()<br>    sys.exit(app.exec_())<br><br></code></pre></td></tr></table></figure><p><strong>2.QLineEdit控件</strong></p><p>2.1 重点了解<strong>回显模式EchoMode</strong>，有4种：</p><p>1）normal    2）noecho（不回显）    3）password(直接变成*号)    4）passwordEchoOnEdit(先显示，过一会后变password)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QLineEditEchoMode</span>(<span class="hljs-params">QWidget</span>) :</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(QLineEditEchoMode,self).__init__()<br>        self.initUI()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.setWindowTitle(<span class="hljs-string">&#x27;文本输入框的回显模式&#x27;</span>)<br><br>        formLayout = QFormLayout()<span class="hljs-comment"># 表单布局，后面要搭配addRow使用，不再是addWidget</span><br><br>        normalLineEdit = QLineEdit()<br>        noEchoLineEdit = QLineEdit()<br>        passwordLineEdit = QLineEdit()<br>        passwordEchoOnEditLineEdit = QLineEdit()<br><br>        formLayout.addRow(<span class="hljs-string">&quot;Normal&quot;</span>,normalLineEdit)<br>        formLayout.addRow(<span class="hljs-string">&quot;NoEcho&quot;</span>, noEchoLineEdit)<br>        formLayout.addRow(<span class="hljs-string">&quot;Password&quot;</span>,passwordLineEdit)<br>        formLayout.addRow(<span class="hljs-string">&quot;PasswordEchoOnEdit&quot;</span>,passwordEchoOnEditLineEdit)<br><br>        <span class="hljs-comment"># placeholdertext(在没有输入任何东西时，显示的灰色提示)</span><br>        normalLineEdit.setPlaceholderText(<span class="hljs-string">&quot;Normal&quot;</span>)<br>        noEchoLineEdit.setPlaceholderText(<span class="hljs-string">&quot;NoEcho&quot;</span>)<br>        passwordLineEdit.setPlaceholderText(<span class="hljs-string">&quot;Password&quot;</span>)<br>        passwordEchoOnEditLineEdit.setPlaceholderText(<span class="hljs-string">&quot;PasswordEchoOnEdit&quot;</span>)<br>        <br>        <span class="hljs-comment"># 设置回显模式</span><br>        normalLineEdit.setEchoMode(QLineEdit.Normal)<br>        noEchoLineEdit.setEchoMode(QLineEdit.NoEcho)<br>        passwordLineEdit.setEchoMode(QLineEdit.Password)<br>        passwordEchoOnEditLineEdit.setEchoMode(QLineEdit.PasswordEchoOnEdit)<br><br>        self.setLayout(formLayout)<span class="hljs-comment"># 看下文解释</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app = QApplication(sys.argv)<br>    main = QLineEditEchoMode()<br>    main.show()<br>    sys.exit(app.exec_())<br></code></pre></td></tr></table></figure><h4 id="关于setLayout和setCentralWidget的一点理解："><a href="#关于setLayout和setCentralWidget的一点理解：" class="headerlink" title="关于setLayout和setCentralWidget的一点理解："></a>关于<code>setLayout</code>和<code>setCentralWidget</code>的一点理解：</h4><p><code>setLayout</code>针对<strong>QWidget窗口</strong>使用，是将已经设置好的布局应用到控件中去；</p><p><code>setCentralWidget</code>针对<strong>QMainWindow窗口</strong>使用，它接受传参为一个QWidget对象，该QWidget对象是已经用<code>setLayout</code>布局好的窗口；相当于<code>setCentralWidget</code>是将设置好的QWidget窗口直接布局到QMainWindow中</p><p>2.2 限制QLineEdit控件的输入——校验器</p><p>限制输入数据的类型：整数、浮点数、满足一定条件的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PyQt5.QtWidgets <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> PyQt5.QtGui <span class="hljs-keyword">import</span> QIntValidator,QDoubleValidator, QRegExpValidator<br><span class="hljs-keyword">from</span> PyQt5.QtCore <span class="hljs-keyword">import</span> QRegExp<span class="hljs-comment"># 正则表达式</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QLineEditValidator</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(QLineEditValidator,self).__init__()<br>        self.initUI()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.setWindowTitle(<span class="hljs-string">&#x27;校验器&#x27;</span>)<br><br>        <span class="hljs-comment"># 创建表单布局</span><br>        formLayout = QFormLayout()<br><br>        intLineEdit = QLineEdit()<span class="hljs-comment"># 创建QLineEdit</span><br>        doubleLineEdit = QLineEdit()<br>        validatorLineEdit = QLineEdit()<br><br>        formLayout.addRow(<span class="hljs-string">&#x27;整数类型&#x27;</span>, intLineEdit)<span class="hljs-comment"># 设置布局</span><br>        formLayout.addRow(<span class="hljs-string">&#x27;浮点类型&#x27;</span>, doubleLineEdit)<br>        formLayout.addRow(<span class="hljs-string">&#x27;数字和字母&#x27;</span>,validatorLineEdit)<br><br>        intLineEdit.setPlaceholderText(<span class="hljs-string">&#x27;整型&#x27;</span>)<br>        doubleLineEdit.setPlaceholderText(<span class="hljs-string">&#x27;浮点型&#x27;</span>)<br>        validatorLineEdit.setPlaceholderText(<span class="hljs-string">&#x27;字母和数字&#x27;</span>)<br><br>        <span class="hljs-comment"># 整数校验器 [1,99]</span><br>        intValidator = QIntValidator(self)<br>        intValidator.setRange(<span class="hljs-number">1</span>,<span class="hljs-number">99</span>)<br><br>        <span class="hljs-comment"># 浮点校验器 [-360,360]，精度：小数点后2位</span><br>        doubleValidator = QDoubleValidator(self)<br>        doubleValidator.setRange(-<span class="hljs-number">360</span>,<span class="hljs-number">360</span>)<br>        doubleValidator.setNotation(QDoubleValidator.StandardNotation)<span class="hljs-comment"># 正常显示浮点数</span><br>        <span class="hljs-comment"># 设置精度，小数点2位</span><br>        doubleValidator.setDecimals(<span class="hljs-number">2</span>)<br><br>        <span class="hljs-comment"># 字符和数字</span><br>        reg = QRegExp(<span class="hljs-string">&#x27;[a-zA-Z0-9]+$&#x27;</span>)<span class="hljs-comment"># 构造正则表达式</span><br>        validator = QRegExpValidator(self)<span class="hljs-comment"># 创建正则表达式检验器</span><br>        validator.setRegExp(reg)<br><br>        <span class="hljs-comment"># 设置校验器（与控件绑定）</span><br>        intLineEdit.setValidator(intValidator)<br>        doubleLineEdit.setValidator(doubleValidator)<br>        validatorLineEdit.setValidator(validator)<br><br>        self.setLayout(formLayout)<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app = QApplication(sys.argv)<br>    main = QLineEditValidator()<br>    main.show()<br>    sys.exit(app.exec_())<br></code></pre></td></tr></table></figure><p>2.3 通过<strong>掩码</strong>限制QLineEdit控件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">A</span>    ASCII字母字符是必须输入的(<span class="hljs-selector-tag">A</span>-Z、<span class="hljs-selector-tag">a</span>-z)<br><span class="hljs-selector-tag">a</span>    ASCII字母字符是允许输入的,但不是必需的(<span class="hljs-selector-tag">A</span>-Z、<span class="hljs-selector-tag">a</span>-z)<br>N    ASCII字母字符是必须输入的(<span class="hljs-selector-tag">A</span>-Z、<span class="hljs-selector-tag">a</span>-z、<span class="hljs-number">0</span>-<span class="hljs-number">9</span>)<br>n    ASII字母字符是允许输入的,但不是必需的(<span class="hljs-selector-tag">A</span>-Z、<span class="hljs-selector-tag">a</span>-z、<span class="hljs-number">0</span>-<span class="hljs-number">9</span>)<br>X    任何字符都是必须输入的<br>x    任何字符都是允许输入的,但不是必需的<br><span class="hljs-number">9</span>    ASCII数字字符是必须输入的(<span class="hljs-number">0</span>-<span class="hljs-number">9</span>)<br><span class="hljs-number">0</span>    ASCII数字字符是允许输入的,但不是必需的(<span class="hljs-number">0</span>-<span class="hljs-number">9</span>)<br>D    ASCII数字字符是必须输入的(<span class="hljs-number">1</span>-<span class="hljs-number">9</span>)<br>d    ASCII数字字符是允许输入的,但不是必需的(<span class="hljs-number">1</span>-<span class="hljs-number">9</span>)<br>#    ASCI数字字符或加减符号是允许输入的,但不是必需的<br>H    十六进制格式字符是必须输入的(<span class="hljs-selector-tag">A</span>-F、<span class="hljs-selector-tag">a</span>-f、<span class="hljs-number">0</span>-<span class="hljs-number">9</span>)<br>h    十六进制格式字符是允许输入的,但不是必需的(<span class="hljs-selector-tag">A</span>-F、<span class="hljs-selector-tag">a</span>-f、<span class="hljs-number">0</span>-<span class="hljs-number">9</span>)<br><span class="hljs-selector-tag">B</span>    二进制格式字符是必须输入的(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br><span class="hljs-selector-tag">b</span>    二进制格式字符是允许输入的,但不是必需的(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>&gt;    所有的字母字符都大写<br>&lt;    所有的字母字符都小写<br>!    关闭大小写转换<br>\    使用&quot;\&quot;转义上面列出的字符<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">ipLineEdit = QLineEdit()<br>macLineEdit = QLineEdit()<br>dateLineEdit = QLineEdit()<br>licenseLineEdit = QLineEdit()<br><span class="hljs-comment"># 192.168.21.45</span><br>ipLineEdit.setInputMask(<span class="hljs-string">&#x27;000.000.000.000;_&#x27;</span>)<span class="hljs-comment"># 没有输入的用_代替</span><br>macLineEdit.setInputMask(<span class="hljs-string">&#x27;HH:HH:HH:HH:HH:HH;_&#x27;</span>)<br>dateLineEdit.setInputMask(<span class="hljs-string">&#x27;0000-00-00&#x27;</span>)<br>licenseLineEdit.setInputMask(<span class="hljs-string">&#x27;&gt;AAAAA-AAAAA-AAAAA-AAAAA-AAAAA;#&#x27;</span>)<span class="hljs-comment"># 用#代替</span><br></code></pre></td></tr></table></figure><p>2.4 使用QTextEdit控件输入多行文字</p><p>3.按钮控件<strong>QPushbutton</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QPushButtonDemo</span>(<span class="hljs-params">QDialog</span>) :</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(QPushButtonDemo,self).__init__()<br>        self.initUI()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.setWindowTitle(<span class="hljs-string">&#x27;QPushButton Demo&#x27;</span>)<br><br>        layout = QVBoxLayout()<br><br>        self.button1 = QPushButton(<span class="hljs-string">&#x27;第1个按钮&#x27;</span>)<br>        self.button1.setText(<span class="hljs-string">&#x27;First Button1&#x27;</span>)<br>        <span class="hljs-comment"># 按钮被按下后，要再按才会弹起</span><br>        self.button1.setCheckable(<span class="hljs-literal">True</span>)<br>        self.button1.toggle()<br>        <br>        self.button1.clicked.connect(self.buttonState)<br>        self.button1.clicked.connect(<span class="hljs-keyword">lambda</span> :self.whichButton(self.button1))<br>        <span class="hljs-comment"># 这里在绑定的时候，由于槽方法有传参btn，所以使用lambda函数；否则不能正常地传参</span><br><br>        layout.addWidget(self.button1)<br><br>        <span class="hljs-comment"># 在文本前面显示图像</span><br>        self.button2 = QPushButton(<span class="hljs-string">&#x27;图像按钮&#x27;</span>)<br>        self.button2.setIcon(QIcon(QPixmap(<span class="hljs-string">&#x27;./images/python.png&#x27;</span>)))<br>        self.button2.clicked.connect(<span class="hljs-keyword">lambda</span>:self.whichButton(self.button2))<br>        layout.addWidget(self.button2)<br><br>        self.button3 = QPushButton(<span class="hljs-string">&#x27;不可用的按钮&#x27;</span>)<br>        self.button3.setEnabled(<span class="hljs-literal">False</span>)<br>        layout.addWidget(self.button3)<br><br>        self.button4 = QPushButton(<span class="hljs-string">&#x27;&amp;MyButton&#x27;</span>)<br>        self.button4.setDefault(<span class="hljs-literal">True</span>)<br>        self.button4.clicked.connect(<span class="hljs-keyword">lambda</span>:self.whichButton(self.button4))<br>        layout.addWidget(self.button4)<br><br>        self.setLayout(layout)<br>        self.resize(<span class="hljs-number">400</span>,<span class="hljs-number">300</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buttonState</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self.button1.isChecked():<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;按钮1已经被选中&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;按钮1未被选中&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">whichButton</span>(<span class="hljs-params">self,btn</span>):</span><span class="hljs-comment"># 有额外传参btn，作为槽进行绑定时，需要用lambda</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;被单击的按钮是&lt;&#x27;</span> + btn.text() + <span class="hljs-string">&#x27;&gt;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>4.单选按钮控件QRadioButton</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QRadioButtonDemo</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(QRadioButtonDemo,self).__init__()<br>        self.initUI()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.setWindowTitle(<span class="hljs-string">&#x27;QRadioButton&#x27;</span>)<br>        layout = QHBoxLayout()<br>        <br>        self.button1 = QRadioButton(<span class="hljs-string">&#x27;单选按钮1&#x27;</span>)<br>        self.button1.setChecked(<span class="hljs-literal">True</span>)<br>        self.button1.toggled.connect(self.buttonState)<br>        layout.addWidget(self.button1)<br><br>        self.button2 = QRadioButton(<span class="hljs-string">&#x27;单选按钮2&#x27;</span>)<br>        self.button2.toggled.connect(self.buttonState)<br>        layout.addWidget(self.button2)<br>        self.setLayout(layout)<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buttonState</span>(<span class="hljs-params">self</span>):</span><br>        radioButton = self.sender()<span class="hljs-comment">#sender()解释见下文</span><br><br>        <span class="hljs-keyword">if</span> radioButton.isChecked() == <span class="hljs-literal">True</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&lt;&#x27;</span> + radioButton.text() + <span class="hljs-string">&#x27;&gt; 被选中&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&lt;&#x27;</span> + radioButton.text() + <span class="hljs-string">&#x27;&gt; 被取消选中状态&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">self.sender()一般在槽函数中使用，用于获取到信号的发送者。当一个槽函数连接到多个按钮事件时，self.sender()就非常有用了！<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">self.button.setCheckable()方法，“<span class="hljs-literal">True</span>”设置该button为可选属性，及存在“开”和“关”两种状态。<br>self.button.setChecked()方法，设置button的状态为为选中的状态（即初始状态设为选中状态）。<br><br>self.button.toggle.connect(xxx) toggle为状态切换事件<br></code></pre></td></tr></table></figure><p>何谓单选按钮？如图：</p><p><img src="/images/image-20210809175110351.png" alt="image-20210809175110351"></p><p>类似这种，只能选一个的按钮；如何实现“单选”功能：</p><p>所有按钮<strong>都用QRadioButton创建</strong>，然后都放在<strong>同一个布局中</strong>，即可自动实现“单选”功能；</p><p>至于如果要对button被按下时做操作，则要用**<code>toggle</code>事件，**因为单选按钮中按下这个，另一个就会熄灭，只涉及“切换”的概念。</p><p>5.复选框<strong>QCheckBox</strong></p><p>复选框有3种状态：未选中0、半选中1、选中2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QCheckBoxDemo</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(QCheckBoxDemo,self).__init__()<br>        self.initUI()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.setWindowTitle(<span class="hljs-string">&#x27;复选框控件演示&#x27;</span>)<br><br>        layout = QHBoxLayout()<br><br>        self.checkBox1 = QCheckBox(<span class="hljs-string">&#x27;复选框控件1&#x27;</span>)<br>        self.checkBox1.setChecked(<span class="hljs-literal">True</span>)<span class="hljs-comment"># 将初始状态设为选中状态</span><br>        self.checkBox1.stateChanged.connect(<span class="hljs-keyword">lambda</span>:self.checkboxState(self.checkBox1))<br>        layout.addWidget(self.checkBox1)<br><br>        self.checkBox2 = QCheckBox(<span class="hljs-string">&#x27;复选框控件2&#x27;</span>)<br>        self.checkBox2.stateChanged.connect(<span class="hljs-keyword">lambda</span>:self.checkboxState(self.checkBox2))<br>        layout.addWidget(self.checkBox2)<br><br>        self.checkBox3 = QCheckBox(<span class="hljs-string">&#x27;半选中&#x27;</span>)<br>        self.checkBox3.stateChanged.connect(<span class="hljs-keyword">lambda</span>:self.checkboxState(self.checkBox3))<br>        <span class="hljs-comment"># setTristate + setCheckState 搭配，设置为半选中状态</span><br>        self.checkBox3.setTristate(<span class="hljs-literal">True</span>)<br>        self.checkBox3.setCheckState(Qt.PartiallyChecked)<span class="hljs-comment"># 常量都位于Qt库中</span><br>        layout.addWidget(self.checkBox3)<br><br>        self.setLayout(layout)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">checkboxState</span>(<span class="hljs-params">self,cb</span>):</span><br>        check1Status = self.checkBox1.text() + <span class="hljs-string">&#x27;,= isChecked&#x27;</span> + <span class="hljs-built_in">str</span>(self.checkBox1.isChecked()) + <span class="hljs-string">&#x27;,checkState=&#x27;</span> + <span class="hljs-built_in">str</span>(self.checkBox1.checkState()) + <span class="hljs-string">&#x27;\n&#x27;</span><br>        check2Status = self.checkBox2.text() + <span class="hljs-string">&#x27;, isChecked=&#x27;</span> + <span class="hljs-built_in">str</span>(self.checkBox2.isChecked()) + <span class="hljs-string">&#x27;,checkState=&#x27;</span> + <span class="hljs-built_in">str</span>(self.checkBox2.checkState()) + <span class="hljs-string">&#x27;\n&#x27;</span><br>        check3Status = self.checkBox3.text() + <span class="hljs-string">&#x27;, isChecked=&#x27;</span> + <span class="hljs-built_in">str</span>(self.checkBox3.isChecked()) + <span class="hljs-string">&#x27;,checkState=&#x27;</span> + <span class="hljs-built_in">str</span>(self.checkBox3.checkState()) + <span class="hljs-string">&#x27;\n&#x27;</span><br>        <span class="hljs-built_in">print</span>(check1Status + check2Status + check3Status)<br></code></pre></td></tr></table></figure><p><code>isChecked()</code>是否被选中，返回bool；</p><p><code>checkState()</code>是复选框特有的属性，返回0、1、2，代表选中的3种状态。</p><p>6.下拉列表控件<strong>QComboBox</strong></p><p>学习两个要点：1. 如何将列表项添加到QComboBox控件中    2. 如何获取选中的列表项</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QComboBoxDemo</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(QComboBoxDemo,self).__init__()<br>        self.initUI()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.setWindowTitle(<span class="hljs-string">&#x27;下拉列表控件演示&#x27;</span>)<br>        self.resize(<span class="hljs-number">300</span>,<span class="hljs-number">100</span>)<br><br>        layout = QVBoxLayout()<br><br>        self.label = QLabel(<span class="hljs-string">&#x27;请选择编程语言&#x27;</span>)<br><br>        self.cb = QComboBox()<br>        <span class="hljs-comment"># 添加列表项</span><br>        self.cb.addItem(<span class="hljs-string">&#x27;C++&#x27;</span>)<br>        self.cb.addItem(<span class="hljs-string">&#x27;Python&#x27;</span>)<br>        self.cb.addItems([<span class="hljs-string">&#x27;Java&#x27;</span>,<span class="hljs-string">&#x27;C#&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>])<br>        <br>        <span class="hljs-comment"># 列表控件的信号为currentIndexChanged</span><br>        self.cb.currentIndexChanged.connect(self.selectionChange)<br><br>        layout.addWidget(self.label)<br>        layout.addWidget(self.cb)<br><br>        self.setLayout(layout)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selectionChange</span>(<span class="hljs-params">self,i</span>):</span><br>        self.label.setText(self.cb.currentText())<br>        self.label.adjustSize()<br>        <span class="hljs-keyword">for</span> count <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.cb.count()):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;item&#x27;</span> + <span class="hljs-built_in">str</span>(count) + <span class="hljs-string">&#x27;=&#x27;</span> + self.cb.itemText(count))<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;current index&#x27;</span>,i,<span class="hljs-string">&#x27;selection changed&#x27;</span>, self.cb.currentText())<br></code></pre></td></tr></table></figure><p>7.滑块控件<strong>QSlider</strong></p><p>滑块控件自身有数值，用<code>.value()</code>方法获取，在槽函数中通常搭配<code>self.sender().value()</code>获取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QSliderDemo</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(QSliderDemo,self).__init__()<br>        self.initUI()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.setWindowTitle(<span class="hljs-string">&#x27;滑块控件演示&#x27;</span>)<br>        self.resize(<span class="hljs-number">300</span>,<span class="hljs-number">700</span>)<br><br>        layout = QVBoxLayout()<br>        self.label = QLabel(<span class="hljs-string">&#x27;你好 PyQt5&#x27;</span>)<br>        self.label.setAlignment(Qt.AlignCenter)<span class="hljs-comment"># label居中显示，常量在Qt中</span><br>        layout.addWidget(self.label)<br><br>        self.slider = QSlider(Qt.Horizontal)<br>        self.slider.setMinimum(<span class="hljs-number">12</span>)<span class="hljs-comment"># 设置最小值</span><br>        self.slider.setMaximum(<span class="hljs-number">48</span>)<span class="hljs-comment"># 设置最大值</span><br>        self.slider.setSingleStep(<span class="hljs-number">3</span>)<span class="hljs-comment"># 步长</span><br>        self.slider.setValue(<span class="hljs-number">18</span>)<span class="hljs-comment"># 设置当前值</span><br>        self.slider.setTickPosition(QSlider.TicksBelow)<span class="hljs-comment"># 设置刻度的位置，刻度在下方</span><br>        self.slider.setTickInterval(<span class="hljs-number">6</span>)<span class="hljs-comment"># 设置刻度的间隔</span><br>        layout.addWidget(self.slider)<br>        self.slider.valueChanged.connect(self.valueChange)<br><br>        self.slider1 = QSlider(Qt.Vertical)<br>        self.slider1.setMinimum(<span class="hljs-number">10</span>)<span class="hljs-comment"># 设置最小值</span><br>        self.slider1.setMaximum(<span class="hljs-number">60</span>)<span class="hljs-comment"># 设置最大值</span><br>        self.slider1.setSingleStep(<span class="hljs-number">5</span>)<span class="hljs-comment"># 步长</span><br>        self.slider1.setValue(<span class="hljs-number">30</span>)<span class="hljs-comment"># 设置当前值</span><br>        self.slider1.setTickPosition(QSlider.TicksLeft)<span class="hljs-comment"># 设置刻度的位置，刻度在下方</span><br>        self.slider1.setTickInterval(<span class="hljs-number">2</span>)<span class="hljs-comment"># 设置刻度的间隔</span><br>        layout.addWidget(self.slider1)<br>        self.slider1.valueChanged.connect(self.valueChange)<br>        <br>        self.setLayout(layout)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">valueChange</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前值：%s&#x27;</span> % self.sender().value())<br>        size = self.sender().value()<span class="hljs-comment"># 获取滑块的当前值</span><br>        self.label.setFont(QFont(<span class="hljs-string">&#x27;Arial&#x27;</span>,size))<br></code></pre></td></tr></table></figure><p>8.计数器控件<strong>QSpinBox</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QSpinBoxDemo</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(QSpinBoxDemo,self).__init__()<br>        self.initUI()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.setWindowTitle(<span class="hljs-string">&#x27;QSpinBox演示&#x27;</span>)<br>        self.resize(<span class="hljs-number">300</span>,<span class="hljs-number">100</span>)<br><br>        layout = QVBoxLayout()<br>        self.label = QLabel(<span class="hljs-string">&#x27;当前值&#x27;</span>)<br>        self.label.setAlignment(Qt.AlignCenter)<br><br>        layout.addWidget(self.label)<br><br>        self.sb = QSpinBox()<br>        self.sb.setValue(<span class="hljs-number">18</span>)<br>        self.sb.setRange(<span class="hljs-number">10</span>,<span class="hljs-number">38</span>)<br>        self.sb.setSingleStep(<span class="hljs-number">3</span>)<span class="hljs-comment"># 步长</span><br>        self.sb.valueChanged.connect(self.valueChange)<span class="hljs-comment"># 计数器的信号：valueChanged</span><br>        <br>        layout.addWidget(self.sb)<br>        self.setLayout(layout)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">valueChange</span>(<span class="hljs-params">self</span>):</span><br>        self.label.setText(<span class="hljs-string">&#x27;当前值：&#x27;</span> + <span class="hljs-built_in">str</span>(self.sb.value()))<span class="hljs-comment"># 改变计数器，label文本也改变</span><br></code></pre></td></tr></table></figure><h3 id="五、代码开发——对话框QDialog"><a href="#五、代码开发——对话框QDialog" class="headerlink" title="五、代码开发——对话框QDialog"></a>五、代码开发——对话框QDialog</h3><p>对话框的基类为<code>QDialog</code>，相关的派生类：QMessageBox、QColorDialog、QFileDialog、QFontDialog、QInputDialog</p><p>这些对话框都是封装完好的，里面的内容非常丰富，<strong>了解熟知它们的返回值</strong>！直接调用即可</p><p>1.<strong>QDialog</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QDialogDemo</span>(<span class="hljs-params">QMainWindow</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(QDialogDemo,self).__init__()<br>        self.initUI()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.setWindowTitle(<span class="hljs-string">&#x27;QDialog案例&#x27;</span>)<br>        self.resize(<span class="hljs-number">300</span>,<span class="hljs-number">200</span>)<br><br>        self.button = QPushButton(self)<span class="hljs-comment"># 为什么传参self？见下文解释</span><br>        self.button.setText(<span class="hljs-string">&#x27;弹出对话框&#x27;</span>)<br>        self.button.move(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>)<br>        self.button.clicked.connect(self.showDialog)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">showDialog</span>(<span class="hljs-params">self</span>):</span><br>        dialog = QDialog()<br>        button = QPushButton(<span class="hljs-string">&#x27;确定&#x27;</span>,dialog)<span class="hljs-comment"># 在对话框中添加button</span><br>        button.clicked.connect(dialog.close)<span class="hljs-comment"># button按下时调用dialog的close函数</span><br>        button.move(<span class="hljs-number">50</span>,<span class="hljs-number">50</span>)<br>        dialog.setWindowTitle(<span class="hljs-string">&#x27;对话框&#x27;</span>)<br>        dialog.setWindowModality(Qt.ApplicationModal)<span class="hljs-comment"># 设置“模式”显示，即对话框弹出后，不得再操作窗口</span><br>        <span class="hljs-comment"># 显示对话框的语句</span><br>        dialog.<span class="hljs-built_in">exec</span>()<br></code></pre></td></tr></table></figure><p>2.消息对话框<strong>QMessageBox</strong></p><p>消息对话框有5种类型：</p><p>关于对话框、错误对话框、警告对话框、提问对话框、消息对话框</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QMessageBoxDemo</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(QMessageBoxDemo,self).__init__()<br>        self.initUI()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.setWindowTitle(<span class="hljs-string">&#x27;QMessageBox案例&#x27;</span>)<br>        self.resize(<span class="hljs-number">300</span>,<span class="hljs-number">400</span>)<br><br>        layout = QVBoxLayout()<br>        self.button1 = QPushButton()<br>        self.button1.setText(<span class="hljs-string">&#x27;显示关于对话框&#x27;</span>)<br>        self.button1.clicked.connect(self.showDialog)<br><br>        self.button2 = QPushButton()<br>        self.button2.setText(<span class="hljs-string">&#x27;显示消息对话框&#x27;</span>)<br>        self.button2.clicked.connect(self.showDialog)<br><br>        self.button3 = QPushButton()<br>        self.button3.setText(<span class="hljs-string">&#x27;显示警告对话框&#x27;</span>)<br>        self.button3.clicked.connect(self.showDialog)<br><br>        self.button4 = QPushButton()<br>        self.button4.setText(<span class="hljs-string">&#x27;显示错误对话框&#x27;</span>)<br>        self.button4.clicked.connect(self.showDialog)<br><br>        self.button5 = QPushButton()<br>        self.button5.setText(<span class="hljs-string">&#x27;显示提问对话框&#x27;</span>)<br>        self.button5.clicked.connect(self.showDialog)<br><br>        layout.addWidget(self.button1)<br>        layout.addWidget(self.button2)<br>        layout.addWidget(self.button3)<br>        layout.addWidget(self.button4)<br>        layout.addWidget(self.button5)<br>        self.setLayout(layout)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">showDialog</span>(<span class="hljs-params">self</span>):</span><br>        text = self.sender().text()<br>        <span class="hljs-keyword">if</span> text == <span class="hljs-string">&#x27;显示关于对话框&#x27;</span>:<br>            QMessageBox.about(self,<span class="hljs-string">&#x27;关于&#x27;</span>,<span class="hljs-string">&#x27;这是一个关于对话框&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> text == <span class="hljs-string">&#x27;显示消息对话框&#x27;</span>:<br>            reply = QMessageBox.information(self,<span class="hljs-string">&#x27;消息&#x27;</span>,<span class="hljs-string">&#x27;这是一个消息对话框&#x27;</span>, QMessageBox.Yes | QMessageBox.No,QMessageBox.Yes)<br>            <span class="hljs-built_in">print</span>(reply == QMessageBox.Yes)<br>        <span class="hljs-keyword">elif</span> text == <span class="hljs-string">&#x27;显示警告对话框&#x27;</span>:<br>            QMessageBox.warning(self,<span class="hljs-string">&#x27;警告&#x27;</span>,<span class="hljs-string">&#x27;这是一个警告对话框&#x27;</span>,QMessageBox.Yes | QMessageBox.No,QMessageBox.Yes)<br>        <span class="hljs-keyword">elif</span> text == <span class="hljs-string">&#x27;显示错误对话框&#x27;</span>:<br>            QMessageBox.critical(self,<span class="hljs-string">&#x27;警告&#x27;</span>,<span class="hljs-string">&#x27;这是一个错误对话框&#x27;</span>,QMessageBox.Yes | QMessageBox.No,QMessageBox.Yes)<br>        <span class="hljs-keyword">elif</span> text == <span class="hljs-string">&#x27;显示提问对话框&#x27;</span>:<br>            QMessageBox.question(self,<span class="hljs-string">&#x27;警告&#x27;</span>,<span class="hljs-string">&#x27;这是一个提问对话框&#x27;</span>,QMessageBox.Yes | QMessageBox.No,QMessageBox.Yes)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">reply = QMessageBox.information(self,<span class="hljs-string">&#x27;消息&#x27;</span>,<span class="hljs-string">&#x27;这是一个消息对话框&#x27;</span>, QMessageBox.Yes | QMessageBox.No,QMessageBox.Yes)<br><span class="hljs-comment"># 参数：(self, 对话框名字，对话框显示内容， button1 | button2， 默认按回车时选择哪个button)</span><br></code></pre></td></tr></table></figure><p>3.输入对话框<strong>QIputDialog</strong></p><p>在对话框内显示“可输入内容”的控件，提供了若干静态方法用于弹出此类对话框：</p><p>QInputDialog.getItem、QInputDialog.getText、QInputDialog.getInt</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QInputDialogDemo</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(QInputDialogDemo,self).__init__()<br>        self.initUI()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.setWindowTitle(<span class="hljs-string">&#x27;输入对话框&#x27;</span>)<br>        layout = QFormLayout()<span class="hljs-comment"># 表单布局</span><br><br>        self.button1 = QPushButton(<span class="hljs-string">&#x27;获取列表中的选项&#x27;</span>)<br>        self.button1.clicked.connect(self.getItem)<br>        self.lineEdit1 = QLineEdit()<span class="hljs-comment"># 输入框</span><br>        layout.addRow(self.button1, self.lineEdit1) <span class="hljs-comment"># 添加一行，两个控件</span><br><br>        self.button2 = QPushButton(<span class="hljs-string">&#x27;获取字符串&#x27;</span>)<br>        self.button2.clicked.connect(self.getText)<br>        self.lineEdit2 = QLineEdit()<br>        layout.addRow(self.button2, self.lineEdit2)<br><br>        self.button3 = QPushButton(<span class="hljs-string">&#x27;获取整数&#x27;</span>)<br>        self.button3.clicked.connect(self.getInt)<br>        self.lineEdit3 = QLineEdit()<br>        layout.addRow(self.button3, self.lineEdit3)<br><br>        self.setLayout(layout)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getItem</span>(<span class="hljs-params">self</span>):</span><br>        items = [<span class="hljs-string">&#x27;C&#x27;</span>,<span class="hljs-string">&#x27;C++&#x27;</span>,<span class="hljs-string">&#x27;Ruby&#x27;</span>,<span class="hljs-string">&#x27;Python&#x27;</span>,<span class="hljs-string">&#x27;Java&#x27;</span>]<br>        <span class="hljs-comment"># item为选择的值，ok为是否按了ok键的bool值</span><br>        item, ok =QInputDialog.getItem(self,<span class="hljs-string">&#x27;请选择编程语言&#x27;</span>,<span class="hljs-string">&#x27;语言列表&#x27;</span>,items)<br>        <span class="hljs-keyword">if</span> ok <span class="hljs-keyword">and</span> item:<br>            self.lineEdit1.setText(item)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getText</span>(<span class="hljs-params">self</span>):</span><br>        text, ok =QInputDialog.getText(self,<span class="hljs-string">&#x27;文本输入框&#x27;</span>,<span class="hljs-string">&#x27;输入姓名&#x27;</span>)<br>        <span class="hljs-keyword">if</span> ok <span class="hljs-keyword">and</span> text:<br>            self.lineEdit2.setText(text)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getInt</span>(<span class="hljs-params">self</span>):</span><br>        num, ok =QInputDialog.getInt(self,<span class="hljs-string">&#x27;整数输入框&#x27;</span>,<span class="hljs-string">&#x27;输入数字&#x27;</span>)<br>        <span class="hljs-keyword">if</span> ok <span class="hljs-keyword">and</span> num:<br>            self.lineEdit3.setText(<span class="hljs-built_in">str</span>(num))<br></code></pre></td></tr></table></figure><p><code>QInputDialog.getItem</code>这类方法相当于已经封装完好了：</p><p><strong>传参：(self, 对话框名称，label控件名称，元组 / 列表)</strong></p><p>第三个参数label的来源：方法内已经封装好了，弹出的对话框内已经创建了新的label，用于提示用户，所以调用时，直接传参即可，具体效果如图：<code>QInputDialog.getItem(self,&#39;请选择编程语言&#39;,&#39;语言列表&#39;,items)</code></p><p><img src="/images/image-20210810104236618.png" alt="image-20210810104236618"></p><p><strong>返回值：(用户选择的值，是否按了ok按钮)</strong></p><p>4.字体对话框<strong>QFontDialog</strong></p><p>用于设置字体</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QFontDialogDemo</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(QFontDialogDemo,self).__init__()<br>        self.initUI()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.setWindowTitle(<span class="hljs-string">&#x27;Font Dialog例子&#x27;</span>)<br>        layout = QVBoxLayout()<br>        self.fontButton = QPushButton(<span class="hljs-string">&#x27;选择字体&#x27;</span>)<br>        self.fontButton.clicked.connect(self.getFont)<br>        layout.addWidget(self.fontButton)<br><br>        self.fontLabel = QLabel(<span class="hljs-string">&#x27;Hello，测试字体例子&#x27;</span>)<span class="hljs-comment"># 创建用于测试的label</span><br>        layout.addWidget(self.fontLabel)<br><br>        self.setLayout(layout)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getFont</span>(<span class="hljs-params">self</span>):</span><br>        font, ok = QFontDialog.getFont()<span class="hljs-comment"># 返回值和上面同理；QFontDialog.getFont()都是封装好的对话框，里面内容丰富，直接调用即可</span><br>        <span class="hljs-keyword">if</span> ok :<br>            self.fontLabel.setFont(font)<span class="hljs-comment"># 修改label的字体</span><br>            <br>    <span class="hljs-comment"># 显然 如果要修改某一label的字体，则将指定的label用setFont()方法进行修改即可</span><br></code></pre></td></tr></table></figure><p>5.颜色对话框<strong>QColorDialog</strong></p><p>用于设置颜色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QColorDialogDemo</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(QColorDialogDemo,self).__init__()<br>        self.initUI()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.setWindowTitle(<span class="hljs-string">&#x27;Color Dialog例子&#x27;</span>)<br>        layout = QVBoxLayout()<br>        self.colorButton = QPushButton(<span class="hljs-string">&#x27;设置颜色&#x27;</span>)<br>        self.colorButton.clicked.connect(self.getColor)<br>        layout.addWidget(self.colorButton)<br><br>        self.colorButton1 = QPushButton(<span class="hljs-string">&#x27;设置背景颜色&#x27;</span>)<br>        self.colorButton1.clicked.connect(self.getBGColor)<br>        layout.addWidget(self.colorButton1)<br><br>        self.colorLabel = QLabel(<span class="hljs-string">&#x27;Hello，测试颜色例子&#x27;</span>)<br>        layout.addWidget(self.colorLabel)<br><br>        self.setLayout(layout)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getColor</span>(<span class="hljs-params">self</span>):</span><br>        color = QColorDialog.getColor()<span class="hljs-comment"># 该函数返回值没有ok，和上面不同！返回调好的颜色（用于后面配置调色板）</span><br>        p = QPalette()<span class="hljs-comment"># 创建调色板</span><br>        p.setColor(QPalette.WindowText,color)<span class="hljs-comment"># ”配置“调色板；第一个传参指定给哪里上色</span><br>        <span class="hljs-comment"># WindowText给文本上色，Window给背景上色</span><br>            <span class="hljs-comment"># 第二个传参指定上什么颜色</span><br>        self.colorLabel.setPalette(p)<span class="hljs-comment"># 实际给label上色</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getBGColor</span>(<span class="hljs-params">self</span>):</span><br>        color = QColorDialog.getColor()<br>        p = QPalette()<br>        p.setColor(QPalette.Window,color)<br>        self.colorLabel.setAutoFillBackground(<span class="hljs-literal">True</span>)<br>        self.colorLabel.setPalette(p)<br></code></pre></td></tr></table></figure><p>启发：调色基本流程：</p><p>创建调色板**<code>p = QPalette()</code>** –&gt; 配置调色板，这里要搭配前面获取的颜色，并且要指定给哪里上色**<code>p.setColor()</code>** –&gt; 实际上色**<code>self.label.setPalette(p)</code>**传参为刚配置好的调色板</p><p>6.文件对话框<strong>QFileDialog</strong></p><p>可显示多种类型对话框，常用的有<strong>”保存“、”打开“文件</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QFileDialogDemo</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(QFileDialogDemo,self).__init__()<br>        self.initUI()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        layout = QVBoxLayout()<br>        self.button1 = QPushButton(<span class="hljs-string">&#x27;加载图片&#x27;</span>)<br>        self.button1.clicked.connect(self.loadImage)<br>        layout.addWidget(self.button1)<br><br>        self.imageLabel = QLabel()<span class="hljs-comment"># 显示加载的图片内容</span><br>        layout.addWidget(self.imageLabel)<br><br>        self.button2 = QPushButton(<span class="hljs-string">&#x27;加载文本文件&#x27;</span>)<br>        self.button2.clicked.connect(self.loadText)<br>        layout.addWidget(self.button2)<br><br>        self.contents = QTextEdit()<span class="hljs-comment"># 显示加载的文本内容</span><br>        layout.addWidget(self.contents)<br><br>        self.setLayout(layout)<br>        self.setWindowTitle(<span class="hljs-string">&#x27;文件对话框演示 &#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loadImage</span>(<span class="hljs-params">self</span>):</span><br>        fname,_ = QFileDialog.getOpenFileName(self,<span class="hljs-string">&#x27;打开文件&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;图像文件(*.jpg *.png)&#x27;</span>)<span class="hljs-comment"># 静态方法</span><br>        self.imageLabel.setPixmap(QPixmap(fname))<span class="hljs-comment"># label显示图片</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loadText</span>(<span class="hljs-params">self</span>):</span><br>        dialog = QFileDialog()<br>        dialog.setFileMode(QFileDialog.AnyFile)<br>        dialog.setFilter(QDir.Files)<br><br>        <span class="hljs-keyword">if</span> dialog.<span class="hljs-built_in">exec</span>():<br>            filenames = dialog.selectedFiles()<br>            f = <span class="hljs-built_in">open</span>(filenames[<span class="hljs-number">0</span>],encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>,mode=<span class="hljs-string">&#x27;r&#x27;</span>)<br>            <span class="hljs-keyword">with</span> f:<br>                data = f.read()<br>                self.contents.setText(data)<br></code></pre></td></tr></table></figure><p>和其他类型对话框一样，QFileDialog也有很多的静态方法，这里只介绍上面的两个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">fname,_ = QFileDialog.getOpenFileName(self,<span class="hljs-string">&#x27;打开文件&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-string">&#x27;图像文件(*.jpg *.png)&#x27;</span>)<br><span class="hljs-comment"># 传参：(self, 提示，默认路径，过滤出来的文件后缀名)</span><br></code></pre></td></tr></table></figure><p>对于第二个槽函数，使用了<code>QFileDialog.selectedFiles()</code>方法，该方法比较特殊，必须先创建QFileDialog对象，然后在<code>dialog.exec()</code>下执行相关操作。</p><p>经过测试，第二个方法同样可以用<code>QFileDialog.getOpenFileName()</code>实现，代码修改如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loadText</span>(<span class="hljs-params">self</span>):</span><br>    filenames = QFileDialog.getOpenFileName(self)<span class="hljs-comment"># 用QFileDialog.getOpenFileName()实现</span><br>    f = <span class="hljs-built_in">open</span>(filenames[<span class="hljs-number">0</span>],encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>,mode=<span class="hljs-string">&#x27;r&#x27;</span>)<br>    <span class="hljs-keyword">with</span> f:<br>        data = f.read()<br>        self.contents.setText(data)<br></code></pre></td></tr></table></figure><h3 id="六、代码开发——绘图QPainter"><a href="#六、代码开发——绘图QPainter" class="headerlink" title="六、代码开发——绘图QPainter"></a>六、代码开发——绘图QPainter</h3><p>常见可绘制：文本、各种图形、图像</p><p>基本的绘制框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">painter = QPainter()<br>painter.begin()<br><span class="hljs-comment"># ...</span><br>painter.ennd()<br></code></pre></td></tr></table></figure><p>注意：PyQT5种画图操作不是提供一个直接使用的方法，而是要<strong>重载一个方法</strong>，名为<code>paintEvent</code>，其背后的原理可先不用管，大致知道：当窗口大小改变时，就会调用此方法。</p><p><strong>基本所有和QPainter有关的绘制操作，都在放在<code>paintEvent</code>方法下实现。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DrawText</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(DrawText,self).__init__()<br>        self.setWindowTitle(<span class="hljs-string">&#x27;在窗口上绘制文本&#x27;</span>)<br>        self.resize(<span class="hljs-number">300</span>,<span class="hljs-number">200</span>)<br>        self.text = <span class="hljs-string">&quot;Python从菜鸟到高手&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">paintEvent</span>(<span class="hljs-params">self, event</span>):</span><br>        painter = QPainter(self)<br>        painter.begin(self)<br>        painter.setPen(QColor(<span class="hljs-number">150</span>,<span class="hljs-number">43</span>,<span class="hljs-number">5</span>))<span class="hljs-comment"># 设置画笔</span><br>        painter.setFont(QFont(<span class="hljs-string">&#x27;SimSun&#x27;</span>,<span class="hljs-number">25</span>))<span class="hljs-comment"># 设置字体</span><br><br>        painter.drawText(event.rect(),Qt.AlignCenter,self.text)<span class="hljs-comment"># drawText方法绘制文本</span><br>        painter.end()<br></code></pre></td></tr></table></figure><p>其他绘制不再做详细笔记，需要时百度</p><h3 id="七、代码开发——零散控件介绍"><a href="#七、代码开发——零散控件介绍" class="headerlink" title="七、代码开发——零散控件介绍"></a>七、代码开发——零散控件介绍</h3><p>1.剪贴板</p><p>2.日历控件<code>QCalendarWidget</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCalendar</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(MyCalendar, self).__init__()<br>        self.initUI()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.cal = QCalendarWidget(self)<br>        self.cal.setMinimumDate(QDate(<span class="hljs-number">1988</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<br>        self.cal.setMaximumDate(QDate(<span class="hljs-number">2088</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<br><br>        self.cal.setGridVisible(<span class="hljs-literal">True</span>)<br>        self.cal.move(<span class="hljs-number">20</span>,<span class="hljs-number">20</span>)<br>        self.cal.clicked.connect(self.showDate)<br>        <span class="hljs-comment"># 创建label显示选中的日期</span><br>        self.label = QLabel(self)<br>        date = self.cal.selectedDate()<br>        self.label.setText(date.toString(<span class="hljs-string">&quot;yyyy-MM-dd dddd&quot;</span>))<span class="hljs-comment"># 设置日期格式</span><br>        self.label.move(<span class="hljs-number">20</span>,<span class="hljs-number">300</span>)<br><br>        self.resize(<span class="hljs-number">400</span>,<span class="hljs-number">350</span>)<br>        self.setWindowTitle(<span class="hljs-string">&quot;日历演示&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">showDate</span>(<span class="hljs-params">self,date</span>):</span><br>        <span class="hljs-comment">#self.label.setText((date.toString(&quot;yyyy-MM-dd dddd&quot;)))</span><br>        self.label.setText((self.cal.selectedDate().toString(<span class="hljs-string">&quot;yyyy-MM-dd dddd&quot;</span>)))<br></code></pre></td></tr></table></figure><p>设置不同风格的日期、时间，以及时间控件的高级操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateTimeEdit</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(DateTimeEdit, self).__init__()<br>        self.initUI()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        vlayout = QVBoxLayout()<br>        dateTimeEdit1 = QDateTimeEdit()<br>        dateTimeEdit2 = QDateTimeEdit(QDateTime.currentDateTime())<br>        dateTimeEdit1.setMinimumDate(QDate.currentDate().addDays(-<span class="hljs-number">365</span>))<span class="hljs-comment"># 设置最值</span><br>        dateTimeEdit1.setMaximumDate(QDate.currentDate().addDays(<span class="hljs-number">365</span>))<br>        self.dateTimeEdit = dateTimeEdit1<br>        dateTimeEdit2.setCalendarPopup(<span class="hljs-literal">True</span>)<span class="hljs-comment"># 将控件改为“下拉”模式</span><br><br>        dateEdit = QDateTimeEdit(QDate.currentDate())<br>        timeEdit = QDateTimeEdit(QTime.currentTime())<br><br>        dateTimeEdit1.setDisplayFormat(<span class="hljs-string">&quot;yyyy-MM-dd  HH:mm:ss&quot;</span>)<br>        dateTimeEdit2.setDisplayFormat(<span class="hljs-string">&quot;yyyy/MM/dd HH-mm-ss&quot;</span>)<br><br>        dateEdit.setDisplayFormat(<span class="hljs-string">&quot;yyyy.MM.dd&quot;</span>)<br>        timeEdit.setDisplayFormat(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>)<br><br>        dateTimeEdit1.dateChanged.connect(self.onDateChanged)<br>        dateTimeEdit1.timeChanged.connect(self.onTimeChanged)<br>        dateTimeEdit1.dateTimeChanged.connect(self.onDateTimeChanged)<br><br>        vlayout.addWidget(dateTimeEdit1)<br>        vlayout.addWidget(dateTimeEdit2)<br>        vlayout.addWidget(dateEdit)<br>        vlayout.addWidget(timeEdit)<br><br>        self.btn = QPushButton(<span class="hljs-string">&#x27;获取日期和时间&#x27;</span>)<br>        self.btn.clicked.connect(self.onButtonClick)<br>        vlayout.addWidget(self.btn)<br>        self.setLayout(vlayout)<br><br>        self.resize(<span class="hljs-number">300</span>,<span class="hljs-number">90</span>)<br>        self.setWindowTitle(<span class="hljs-string">&quot;设置不同风格的日期和时间&quot;</span>)<br><br>    <span class="hljs-comment"># 日期变化</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">onDateChanged</span>(<span class="hljs-params">self,date</span>):</span><br>        <span class="hljs-built_in">print</span>(date)<br><br>    <span class="hljs-comment"># 时间变化</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">onTimeChanged</span>(<span class="hljs-params">self,time</span>):</span><br>        <span class="hljs-built_in">print</span>(time)<br><br>    <span class="hljs-comment"># 日期和时间变化</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">onDateTimeChanged</span>(<span class="hljs-params">self,datetime</span>):</span><br>        <span class="hljs-built_in">print</span>(datetime)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">onButtonClick</span>(<span class="hljs-params">self</span>):</span><br>        datetime = self.dateTimeEdit.dateTime()<br>        <span class="hljs-built_in">print</span>(datetime)<br>        <span class="hljs-comment"># 最大日期</span><br>        <span class="hljs-built_in">print</span>(self.dateTimeEdit.maximumDate())<br>        <span class="hljs-comment"># 最大日期和时间</span><br>        <span class="hljs-built_in">print</span>(self.dateTimeEdit.maximumDateTime())<br>        <span class="hljs-comment"># 最小日期</span><br>        <span class="hljs-built_in">print</span>(self.dateTimeEdit.minimumDateTime())<br></code></pre></td></tr></table></figure><h3 id="八、代码开发——创建和使用菜单、工具栏、状态栏"><a href="#八、代码开发——创建和使用菜单、工具栏、状态栏" class="headerlink" title="八、代码开发——创建和使用菜单、工具栏、状态栏"></a>八、代码开发——创建和使用菜单、工具栏、状态栏</h3><p>1.菜单 基本代码 <code>addMenu</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Menu</span>(<span class="hljs-params">QMainWindow</span>) :</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(Menu,self).__init__()<br>        bar = self.menuBar()  <span class="hljs-comment"># 获取菜单栏</span><br><br>        file = bar.addMenu(<span class="hljs-string">&quot;文件&quot;</span>)<span class="hljs-comment"># 第一级菜单 .addMenu</span><br>        file.addAction(<span class="hljs-string">&quot;新建&quot;</span>)<span class="hljs-comment"># 第二级菜单 .addAction (相当于添加了一个匿名的QAction对象)</span><br> <br>        save = QAction(<span class="hljs-string">&quot;保存&quot;</span>,self)<span class="hljs-comment"># save是一个QAction对象，通过实名创建，可以用setShortcut方法创建快捷键</span><br>        save.setShortcut(<span class="hljs-string">&quot;Ctrl + S&quot;</span>)<br>        file.addAction(save)<br><br>        save.triggered.connect(self.process)<span class="hljs-comment"># QAction对象的信号是triggered</span><br><br>        edit = bar.addMenu(<span class="hljs-string">&quot;Edit&quot;</span>)<span class="hljs-comment"># 另一个第一级菜单</span><br>        edit.addAction(<span class="hljs-string">&quot;copy&quot;</span>)<br>        edit.addAction(<span class="hljs-string">&quot;paste&quot;</span>)<br>        quit = QAction(<span class="hljs-string">&quot;退出&quot;</span>,self)<br>        file.addAction(quit)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span>(<span class="hljs-params">self,a</span>):</span><br>        <span class="hljs-built_in">print</span>(self.sender().text())<br></code></pre></td></tr></table></figure><p>2.工具栏 基本代码 <code>addToolBar</code></p><p>工具栏默认按钮：只显示图标，将文本作为悬停提示展示；在创建QAction对象时，就要传图像</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Toolbar</span>(<span class="hljs-params">QMainWindow</span>) :</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(Toolbar,self).__init__()<br>        self.initUI()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.setWindowTitle(<span class="hljs-string">&quot;工具栏例子&quot;</span>)<br>        self.resize(<span class="hljs-number">300</span>,<span class="hljs-number">200</span>)<br><br>        tb1 = self.addToolBar(<span class="hljs-string">&quot;File&quot;</span>)<br>        new = QAction(QIcon(<span class="hljs-string">&#x27;./images/new.png&#x27;</span>),<span class="hljs-string">&quot;new&quot;</span>,self)<span class="hljs-comment"># 同样创建QAction对象</span><br>        tb1.addAction(new)<br>        <br>        <span class="hljs-built_in">open</span> = QAction(QIcon(<span class="hljs-string">&#x27;./images/open.png&#x27;</span>),<span class="hljs-string">&quot;open&quot;</span>,self)<br>        tb1.addAction(<span class="hljs-built_in">open</span>)<br>        <br>        save = QAction(QIcon(<span class="hljs-string">&#x27;./images/save.png&#x27;</span>),<span class="hljs-string">&quot;save&quot;</span>,self)<br>        tb1.addAction(save)<br><br><br>        tb2 = self.addToolBar(<span class="hljs-string">&quot;File1&quot;</span>)<br>        new1 = QAction(QIcon(<span class="hljs-string">&#x27;./images/new.png&#x27;</span>),<span class="hljs-string">&quot;新建&quot;</span>,self)<br>        tb2.addAction(new1)<br><br>        tb2.setToolButtonStyle(Qt.ToolButtonTextUnderIcon)<span class="hljs-comment"># 设置图片和文字同时显示</span><br><br>        tb1.actionTriggered.connect(self.toolbtnpressed)<br>        tb2.actionTriggered.connect(self.toolbtnpressed)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toolbtnpressed</span>(<span class="hljs-params">self,a</span>):</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;按下的工具栏按钮是&quot;</span>,a.text())<br></code></pre></td></tr></table></figure><p>3.状态栏 基本代码</p><p>一般位于窗口底部</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatusBar</span>(<span class="hljs-params">QMainWindow</span>) :</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(StatusBar,self).__init__()<br>        self.initUI()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.setWindowTitle(<span class="hljs-string">&quot;状态栏演示&quot;</span>)<br>        self.resize(<span class="hljs-number">300</span>,<span class="hljs-number">200</span>)<br><br>        bar = self.menuBar()<br>        file = bar.addMenu(<span class="hljs-string">&quot;File&quot;</span>)<br>        file.addAction(<span class="hljs-string">&quot;show&quot;</span>)<br>        file.triggered.connect(self.processTrigger)<br>        self.setCentralWidget(QTextEdit())<br>        <span class="hljs-comment"># 创建状态栏</span><br>        self.statusBar = QStatusBar()<br>        self.setStatusBar(self.statusBar)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">processTrigger</span>(<span class="hljs-params">self,q</span>):</span><br>        <span class="hljs-keyword">if</span> q.text() == <span class="hljs-string">&quot;show&quot;</span> :<br>            self.statusBar.showMessage(q.text() + <span class="hljs-string">&quot; 菜单被点击了&quot;</span>,<span class="hljs-number">5000</span>)<br></code></pre></td></tr></table></figure><h3 id="九、代码开发——复杂控件"><a href="#九、代码开发——复杂控件" class="headerlink" title="九、代码开发——复杂控件"></a>九、代码开发——复杂控件</h3><h4 id="一、表格控件"><a href="#一、表格控件" class="headerlink" title="一、表格控件"></a>一、表格控件</h4><p>1.<code>QTableView</code>控件</p><p>二维表数据，采用<strong>MVC模式</strong>：Model(数据源)、Viewer、Controller(连接前两者)；</p><p>MVC模式的目的，将前端ui和后端数据的耦合度尽可能降低</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TableView</span>(<span class="hljs-params">QWidget</span>):</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, arg=<span class="hljs-literal">None</span></span>):</span><br><span class="hljs-built_in">super</span>(TableView, self).__init__(arg)<br>self.setWindowTitle(<span class="hljs-string">&quot;QTableView表格视图控件演示&quot;</span>)<br>self.resize(<span class="hljs-number">500</span>,<span class="hljs-number">300</span>);<br><br>self.model = QStandardItemModel(<span class="hljs-number">4</span>,<span class="hljs-number">3</span>)<span class="hljs-comment"># 创建4行3列的标准model</span><br>self.model.setHorizontalHeaderLabels([<span class="hljs-string">&#x27;id&#x27;</span>,<span class="hljs-string">&#x27;姓名&#x27;</span>,<span class="hljs-string">&#x27;年龄&#x27;</span>])<span class="hljs-comment"># 设置列索引</span><br><br>self.tableview = QTableView()<br>self.tableview.setModel(self.model)<span class="hljs-comment"># 关联QTableView控件和Model</span><br><br><span class="hljs-comment"># 添加数据</span><br>item11 = QStandardItem(<span class="hljs-string">&#x27;10&#x27;</span>)<br>item12 = QStandardItem(<span class="hljs-string">&#x27;雷神&#x27;</span>)<br>item13 = QStandardItem(<span class="hljs-string">&#x27;2000&#x27;</span>)<br>self.model.setItem(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,item11)<br>self.model.setItem(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>, item12)<br>self.model.setItem(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>, item13)<br><br>item31 = QStandardItem(<span class="hljs-string">&#x27;30&#x27;</span>)<br>item32 = QStandardItem(<span class="hljs-string">&#x27;死亡女神&#x27;</span>)<br>item33 = QStandardItem(<span class="hljs-string">&#x27;3000&#x27;</span>)<br>self.model.setItem(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,item31)<br>self.model.setItem(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>, item32)<br>self.model.setItem(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>, item33)<br><br>layout = QVBoxLayout()<br>layout.addWidget(self.tableview)<br>self.setLayout(layout)<br></code></pre></td></tr></table></figure><p>2.扩展的表格控件<code>QTableWidget</code></p><p>3.<code>QListView</code>控件</p><p>列表数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListViewDemo</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, parent=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>(ListViewDemo, self).__init__(parent)<br>        self.setWindowTitle(<span class="hljs-string">&quot;QListView 例子&quot;</span>)<br>        self.resize(<span class="hljs-number">300</span>, <span class="hljs-number">270</span>)<br>        layout = QVBoxLayout()<br><br>        listview = QListView()<br>        listModel = QStringListModel()<span class="hljs-comment"># 创建字符串model</span><br>        self.<span class="hljs-built_in">list</span> = [<span class="hljs-string">&quot;列表项1&quot;</span>,<span class="hljs-string">&quot;列表项2&quot;</span>, <span class="hljs-string">&quot;列表项3&quot;</span>]<br><br>        listModel.setStringList(self.<span class="hljs-built_in">list</span>)<br><br>        listview.setModel(listModel)<br>        listview.clicked.connect(self.clicked)<br>        layout.addWidget(listview)<br><br>        self.setLayout(layout)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clicked</span>(<span class="hljs-params">self,item</span>):</span><br>        QMessageBox.information(self,<span class="hljs-string">&quot;QListView&quot;</span>,<span class="hljs-string">&quot;您选择了：&quot;</span> + self.<span class="hljs-built_in">list</span>[item.row()])<span class="hljs-comment"># 单击时弹出对话框</span><br></code></pre></td></tr></table></figure><p>4.扩展的列表控件<code>QListWidget</code></p><p>5.在上述表格/列表的单元格中 放置控件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">setItem：将文本放到单元格中<br>setCellWidget：将控件放到单元格中<br>setStyleSheet：设置控件的样式（QSS）<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PlaceControlInCell</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(PlaceControlInCell,self).__init__()<br>        self.initUI()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.setWindowTitle(<span class="hljs-string">&quot;在单元格中放置控件&quot;</span>)<br>        self.resize(<span class="hljs-number">430</span>, <span class="hljs-number">300</span>);<br>        layout = QHBoxLayout()<br>        tableWidget = QTableWidget()<br>        tableWidget.setRowCount(<span class="hljs-number">4</span>)<br>        tableWidget.setColumnCount(<span class="hljs-number">3</span>)<span class="hljs-comment"># 创建4行3列的QTableWidget对象</span><br><br>        layout.addWidget(tableWidget)<span class="hljs-comment"># 把4*3表格放到水平布局中</span><br><br>        <br>        tableWidget.setHorizontalHeaderLabels([<span class="hljs-string">&#x27;姓名&#x27;</span>,<span class="hljs-string">&#x27;性别&#x27;</span>,<span class="hljs-string">&#x27;体重（kg）&#x27;</span>])<br>        textItem = QTableWidgetItem(<span class="hljs-string">&#x27;小明&#x27;</span>)<br>        tableWidget.setItem(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,textItem)<span class="hljs-comment"># 将文本放到单元格中</span><br><br>        combox = QComboBox()<br>        combox.addItem(<span class="hljs-string">&#x27;男&#x27;</span>)<br>        combox.addItem(<span class="hljs-string">&#x27;女&#x27;</span>)<br>        <span class="hljs-comment"># QSS Qt StyleSheet</span><br>        combox.setStyleSheet(<span class="hljs-string">&#x27;QComboBox&#123;margin:3px&#125;;&#x27;</span>)<br>        tableWidget.setCellWidget(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,combox)<span class="hljs-comment"># 将控件放到单元格中</span><br><br>        modifyButton = QPushButton(<span class="hljs-string">&#x27;修改&#x27;</span>)<br>        modifyButton.setDown(<span class="hljs-literal">True</span>)<br>        modifyButton.setStyleSheet(<span class="hljs-string">&#x27;QPushButton&#123;margin:3px&#125;;&#x27;</span>)<br>        tableWidget.setCellWidget(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,modifyButton)<br><br>        self.setLayout(layout)<br></code></pre></td></tr></table></figure><p>6.在表格中搜索数据、数据的定位</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 数据的查找：findItems  返回一个列表<br><span class="hljs-bullet">2.</span> 如果找到了满足条件的单元格，会定位到单元格所在的行：setSliderPosition(row)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataLocation</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(DataLocation,self).__init__()<br>        self.initUI()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        self.setWindowTitle(<span class="hljs-string">&quot;QTableWidget 例子&quot;</span>)<br>        self.resize(<span class="hljs-number">600</span>, <span class="hljs-number">800</span>);<br><br>        layout = QHBoxLayout()<br>        tableWidget = QTableWidget()<br>        tableWidget.setRowCount(<span class="hljs-number">40</span>)<br>        tableWidget.setColumnCount(<span class="hljs-number">4</span>)<br><br>        layout.addWidget(tableWidget)<br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">40</span>):<br>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>                itemContent = <span class="hljs-string">&#x27;(%d,%d)&#x27;</span> %(i,j)<br>                tableWidget.setItem(i,j,QTableWidgetItem(itemContent))<br>        self.setLayout(layout)<br><br>        <span class="hljs-comment"># 搜索满足条件的Cell</span><br>        text = <span class="hljs-string">&#x27;(13,1)&#x27;</span><br>        items = tableWidget.findItems(text,QtCore.Qt.MatchExactly) <span class="hljs-comment"># 精确搜索，用Qt中的常量</span><br>        <span class="hljs-comment"># 还有很多种搜索方式</span><br>            <span class="hljs-comment"># 如Qt.MatchStartsWith</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(items) &gt; <span class="hljs-number">0</span>:<br>            item = items[<span class="hljs-number">0</span>]<br>            item.setBackground(QBrush(QColor(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>)))<br>            item.setForeground(QBrush(QColor(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)))<br><br>            row = item.row()<br><br>            <span class="hljs-comment"># 定位到指定的行</span><br>            tableWidget.verticalScrollBar().setSliderPosition(row)<br></code></pre></td></tr></table></figure><p>7.表格还有诸多功能，如：<strong>按某一列排序、单元格文本对齐方式、合并单元格、设置单元格尺寸</strong>等等，需要时百度</p><h4 id="二、树控件"><a href="#二、树控件" class="headerlink" title="二、树控件"></a>二、树控件</h4><p><code>QTreeWidget</code>控件</p><p>1.大概效果如下：</p><p><img src="/images/image-20210811200514446.png" alt="image-20210811200514446"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicTreeWidget</span>(<span class="hljs-params">QMainWindow</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, parent=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>(BasicTreeWidget, self).__init__(parent)<br>        self.setWindowTitle(<span class="hljs-string">&#x27;树控件（QTreeWidget）的基本用法&#x27;</span>)<br><br>        self.tree = QTreeWidget()<br>        <span class="hljs-comment"># 为树控件指定列数</span><br>        self.tree.setColumnCount(<span class="hljs-number">2</span>)<br><br>        <span class="hljs-comment"># 指定列标签</span><br>        self.tree.setHeaderLabels([<span class="hljs-string">&#x27;Key&#x27;</span>,<span class="hljs-string">&#x27;Value&#x27;</span>])<br><br>        root = QTreeWidgetItem(self.tree)<span class="hljs-comment"># 根节点直接添加到self.tree上</span><br>        root.setText(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;根节点&#x27;</span>)<br>        root.setIcon(<span class="hljs-number">0</span>,QIcon(<span class="hljs-string">&#x27;./images/root.png&#x27;</span>))<br>        self.tree.setColumnWidth(<span class="hljs-number">0</span>,<span class="hljs-number">160</span>)<br><br>        <span class="hljs-comment"># 添加子节点1</span><br>        child1 = QTreeWidgetItem(root)<span class="hljs-comment"># 添加到root节点上</span><br>        child1.setText(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;子节点1&#x27;</span>)<br>        child1.setText(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;子节点1的数据&#x27;</span>)<br>        child1.setIcon(<span class="hljs-number">0</span>,QIcon(<span class="hljs-string">&#x27;./images/bao3.png&#x27;</span>))<br>        child1.setCheckState(<span class="hljs-number">0</span>,Qt.Checked)<br><br>        <span class="hljs-comment"># 添加子节点2</span><br>        child2 = QTreeWidgetItem(root)<br>        child2.setText(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;子节点2&#x27;</span>)<br>        child2.setIcon(<span class="hljs-number">0</span>,QIcon(<span class="hljs-string">&#x27;./images/bao6.png&#x27;</span>))<br></code></pre></td></tr></table></figure><p>2.树节点响应事件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">self.tree.clicked.connect(self.onTreeClicked)<span class="hljs-comment"># 关联整棵树即可</span><br>   <br>   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">onTreeClicked</span>(<span class="hljs-params">self,index</span>):</span><br>       item = self.tree.currentItem()<span class="hljs-comment"># 获取当前所在的节点</span><br>       <span class="hljs-built_in">print</span>(index.row())<br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;key=%s,value=%s&#x27;</span> % (item.text(<span class="hljs-number">0</span>),item.text(<span class="hljs-number">1</span>)))<br></code></pre></td></tr></table></figure><p>3.添加、删除、修改节点等操作，百度</p><p><code>QTreeView</code>控件，百度</p><h4 id="三、容器控件"><a href="#三、容器控件" class="headerlink" title="三、容器控件"></a>三、容器控件</h4><p>1.选项卡控件<code>QTabWidget</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TabWidgetDemo</span>(<span class="hljs-params">QTabWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, parent=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>(TabWidgetDemo, self).__init__(parent)<br><br>        self.setWindowTitle(<span class="hljs-string">&quot;选项卡控件：QTabWidget&quot;</span>)<br>        <span class="hljs-comment"># 创建用于显示控件的窗口</span><br>        self.tab1 = QWidget()<br>        self.tab2 = QWidget()<br>        self.tab3 = QWidget()<br><br>        self.addTab(self.tab1,<span class="hljs-string">&#x27;选项卡1&#x27;</span>)<span class="hljs-comment"># 添加选项卡 .addTab</span><br>        self.addTab(self.tab2,<span class="hljs-string">&#x27;选项卡2&#x27;</span>)<br>        self.addTab(self.tab3,<span class="hljs-string">&#x27;选项卡3&#x27;</span>)<br><br>        self.tab1UI()<br>        self.tab2UI()<br>        self.tab3UI()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tab1UI</span>(<span class="hljs-params">self</span>):</span><br>        layout = QFormLayout()<span class="hljs-comment"># 第一个选项卡下，表单布局</span><br>        layout.addRow(<span class="hljs-string">&#x27;姓名&#x27;</span>,QLineEdit())<br>        layout.addRow(<span class="hljs-string">&#x27;地址&#x27;</span>,QLineEdit())<br>        self.setTabText(<span class="hljs-number">0</span>,<span class="hljs-string">&#x27;联系方式&#x27;</span>)<br>        self.tab1.setLayout(layout)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tab2UI</span>(<span class="hljs-params">self</span>):</span><br>        layout = QFormLayout()<span class="hljs-comment"># 第二个选项卡下</span><br>        sex = QHBoxLayout()<br>        sex.addWidget(QRadioButton(<span class="hljs-string">&#x27;男&#x27;</span>))<br>        sex.addWidget(QRadioButton(<span class="hljs-string">&#x27;女&#x27;</span>))<br>        layout.addRow(QLabel(<span class="hljs-string">&#x27;性别&#x27;</span>),sex)<br>        layout.addRow(<span class="hljs-string">&#x27;生日&#x27;</span>,QLineEdit())<br>        self.setTabText(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;个人详细信息&#x27;</span>)<br>        self.tab2.setLayout(layout)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tab3UI</span>(<span class="hljs-params">self</span>):</span><br>        layout = QHBoxLayout()<br>        layout.addWidget(QLabel(<span class="hljs-string">&#x27;科目&#x27;</span>))<br>        layout.addWidget(QCheckBox(<span class="hljs-string">&#x27;物理&#x27;</span>))<br>        layout.addWidget(QCheckBox(<span class="hljs-string">&#x27;高数&#x27;</span>))<br>        self.setTabText(<span class="hljs-number">2</span>,<span class="hljs-string">&#x27;教育程度&#x27;</span>)<br>        self.tab3.setLayout(layout)<br></code></pre></td></tr></table></figure><p>2.堆栈窗口控件<code>QStackedWidget</code></p><p>作用？选项卡控件把选项的模式固定了，用堆栈窗口可以自定义选项的显示方式，例如可以通过列表、下拉列表等显示</p><p>3.停靠控件<code>QDockWidget</code></p><p>4.多文档窗口</p><p>5.滚动条控件<code>QScrollBar</code></p><pre><code>常用：通过滚动条值得变化控制其他控件状态、位置变化</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScrollBar</span>(<span class="hljs-params">QWidget</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(ScrollBar, self).__init__()<br>        self.initUI()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initUI</span>(<span class="hljs-params">self</span>):</span><br>        hbox = QHBoxLayout()<br>        self.label = QLabel(<span class="hljs-string">&#x27;拖动滚动条去改变文字颜色&#x27;</span>)<br><br>        hbox.addWidget(self.label)<br><br>        self.scrollbar1 = QScrollBar()<span class="hljs-comment"># 创建滚动条</span><br>        self.scrollbar1.setMaximum(<span class="hljs-number">255</span>)<br>        self.scrollbar1.sliderMoved.connect(self.sliderMoved)<span class="hljs-comment"># 滚动条移动信号</span><br><br>        self.scrollbar2 = QScrollBar()<br>        self.scrollbar2.setMaximum(<span class="hljs-number">255</span>)<br>        self.scrollbar2.sliderMoved.connect(self.sliderMoved)<br><br>        self.scrollbar3 = QScrollBar()<br>        self.scrollbar3.setMaximum(<span class="hljs-number">255</span>)<br>        self.scrollbar3.sliderMoved.connect(self.sliderMoved)<br><br>        self.scrollbar4 = QScrollBar()<br>        self.scrollbar4.setMaximum(<span class="hljs-number">255</span>)<br>        self.scrollbar4.sliderMoved.connect(self.sliderMoved1)<br>        hbox.addWidget(self.scrollbar1)<br>        hbox.addWidget(self.scrollbar2)<br>        hbox.addWidget(self.scrollbar3)<br>        hbox.addWidget(self.scrollbar4)<br>        self.setGeometry(<span class="hljs-number">300</span>,<span class="hljs-number">300</span>,<span class="hljs-number">300</span>,<span class="hljs-number">200</span>)<span class="hljs-comment"># 设置当前窗口的位置、大小; 融合了resize和move方法</span><br><br>        self.setLayout(hbox)<br><br>        self.y = self.label.pos().y()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sliderMoved</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">print</span>(self.scrollbar1.value(),self.scrollbar2.value(),self.scrollbar3.value())<span class="hljs-comment"># .value()获得滚动条当前值</span><br>        palette = QPalette()<br>        c = QColor(self.scrollbar1.value(),self.scrollbar2.value(),self.scrollbar3.value(),<span class="hljs-number">255</span>)<br>        palette.setColor(QPalette.Foreground,c)<span class="hljs-comment"># 配置调色板</span><br>        self.label.setPalette(palette)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sliderMoved1</span>(<span class="hljs-params">self</span>):</span><br>        self.label.move(self.label.x(),self.y + self.scrollbar4.value())<span class="hljs-comment"># 移动label(x不变，通过滚动条设置y)</span><br></code></pre></td></tr></table></figure><h3 id="十、代码开发——多线程"><a href="#十、代码开发——多线程" class="headerlink" title="十、代码开发——多线程"></a>十、代码开发——多线程</h3><p>多线程：并发地完成任务；通常当任务比较耗时的时候，需要将其放在另外的线程中进行，防止主线程崩溃。</p><p><strong>多线程在单cpu上</strong>进行时，仍然是顺序完成的，但是由于cpu和系统的调度，将任务分成多个片段，不断切换进行，所以从宏观上看还是同时完成的。</p><p>多线程在多cpu上进行时，能实现真正的并发完成任务。</p><p>具体如何实现，是由底层的<strong>操作系统算法</strong>完成调度的，不用过于关心。</p><h4 id="1-定时器QTimer"><a href="#1-定时器QTimer" class="headerlink" title="1.定时器QTimer"></a>1.定时器<code>QTimer</code></h4><p>定时器的意义：每隔一段时间调用一次；</p><p><strong>应用一：动态显示当前时间。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设计开始、结束按钮，用于控制开始、停止计时器，原理即为：启用、杀死定时器</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowTime</span>(<span class="hljs-params">QWidget</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, parent=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>(ShowTime, self).__init__(parent)<br>        self.setWindowTitle(<span class="hljs-string">&quot;动态显示当前时间&quot;</span>)<br><br>        self.label = QLabel(<span class="hljs-string">&#x27;显示当前时间&#x27;</span>)<br>        self.startBtn = QPushButton(<span class="hljs-string">&#x27;开始&#x27;</span>)<br>        self.endBtn = QPushButton(<span class="hljs-string">&#x27;结束&#x27;</span>)<br>        layout= QGridLayout()<br><br>        self.timer = QTimer()<span class="hljs-comment"># 创建QTimer</span><br>        self.timer.timeout.connect(self.showTime)<span class="hljs-comment"># timeout信号</span><br><br>        layout.addWidget(self.label,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<br>        layout.addWidget(self.startBtn,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<br>        layout.addWidget(self.endBtn,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br><br>        self.startBtn.clicked.connect(self.startTimer)<br>        self.endBtn.clicked.connect(self.endTimer)<br><br>        self.setLayout(layout)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">showTime</span>(<span class="hljs-params">self</span>):</span><br>        time = QDateTime.currentDateTime()<span class="hljs-comment"># 获取当前时间</span><br><br>        timeDisplay = time.toString(<span class="hljs-string">&quot;yyyy-MM-dd hh:mm:ss dddd&quot;</span>)<span class="hljs-comment"># 格式化显示</span><br>        self.label.setText(timeDisplay)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">startTimer</span>(<span class="hljs-params">self</span>):</span><br>        self.timer.start(<span class="hljs-number">1000</span>)<span class="hljs-comment"># 设置定时器QTimer的时间间隔</span><br>        self.startBtn.setEnabled(<span class="hljs-literal">False</span>)<br>        self.endBtn.setEnabled(<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">endTimer</span>(<span class="hljs-params">self</span>):</span><br>        self.timer.stop()<span class="hljs-comment"># 停止计时器</span><br>        self.startBtn.setEnabled(<span class="hljs-literal">True</span>)<br>        self.endBtn.setEnabled(<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>理解：</p><p><code>**timer.start(1000)**</code>其实就在触发<code>QTimer</code>的<code>timeout</code>信号，一般定义在button的槽函数内；</p><p><code>timeout</code>信号的槽方法即为计时器触发后执行的操作，通常是获取时间并显示在label中。</p><p><strong>应用二：让窗口定时关闭——<code>QTimer.singleShot()</code></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    app = QApplication(sys.argv)<br>    label = QLabel(<span class="hljs-string">&#x27;&lt;font color=red size=140&gt;&lt;b&gt;Hello World，窗口在5秒后自动关闭!&lt;/b&gt;&lt;/font&gt;&#x27;</span>)<br>    label.setWindowFlags(Qt.SplashScreen | Qt.FramelessWindowHint)<br>    label.show()<br>    QTimer.singleShot(<span class="hljs-number">5000</span>,app.quit)<span class="hljs-comment"># 定时关闭</span><br><br>    sys.exit(app.exec_())<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 程序不断调用</span><br>QTimer.start()<br><span class="hljs-comment"># 程序只调用一次</span><br>QTimer.singleShot()<br></code></pre></td></tr></table></figure><h4 id="2-线程类QThread"><a href="#2-线程类QThread" class="headerlink" title="2.线程类QThread"></a>2.线程类<code>QThread</code></h4><p>相比于<code>QTimer</code>，更底层；以应用举例：编写一个计数器</p><p>该实例涉及新的知识点：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span> 自定义信号,用pyqtSignal()类； .emit()方法相当于发送自定义信号，调用槽函数<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python">sec = <span class="hljs-number">0</span><span class="hljs-comment"># 计时，全局变量</span><br><br><span class="hljs-comment"># 工作线程，继承QThread</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkThread</span>(<span class="hljs-params">QThread</span>):</span><br>    timer = pyqtSignal()   <span class="hljs-comment"># 每隔1秒发送一次信号（自定义信号）</span><br>    end = pyqtSignal()     <span class="hljs-comment"># 计数完成后发送一次信号（自定义信号）</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<span class="hljs-comment"># “死循环”</span><br>            self.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 休眠1秒</span><br>              <span class="hljs-comment"># 为什么要休眠1s？ 因为这是死循环，不断地调用，屏幕刷新会有问题，所以休眠1s</span><br>            <span class="hljs-keyword">if</span> sec == <span class="hljs-number">5</span>:<br>                self.end.emit()   <span class="hljs-comment"># 发送end信号（相当于调用与end相关的槽方法）</span><br>                <span class="hljs-keyword">break</span><br>            self.timer.emit()   <span class="hljs-comment"># 发送timer信号（相当于调用与timer相关的槽方法）</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span>(<span class="hljs-params">QWidget</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, parent=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-built_in">super</span>(Counter, self).__init__(parent)<br><br>        self.setWindowTitle(<span class="hljs-string">&quot;使用线程类（QThread）编写计数器&quot;</span>)<br>        self.resize(<span class="hljs-number">300</span>, <span class="hljs-number">120</span>)<br><br>        layout = QVBoxLayout()<br>        self.lcdNumber = QLCDNumber()<span class="hljs-comment"># 模拟LED效果的显示控件</span><br>        layout.addWidget(self.lcdNumber)<br><br>        button = QPushButton(<span class="hljs-string">&#x27;开始计数&#x27;</span>)<br>        layout.addWidget(button)<br><br>        self.workThread = WorkThread()<span class="hljs-comment"># 实例化上面定义的线程对象</span><br><br>        self.workThread.timer.connect(self.countTime)<span class="hljs-comment"># 为自定义的timer信号绑定槽</span><br>        self.workThread.end.connect(self.end)<br>        button.clicked.connect(self.work)<br><br>        self.setLayout(layout)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">countTime</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">global</span> sec<br>        sec += <span class="hljs-number">1</span><br>        self.lcdNumber.display(sec)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">end</span>(<span class="hljs-params">self</span>):</span><br>        QMessageBox.information(self,<span class="hljs-string">&#x27;消息&#x27;</span>,<span class="hljs-string">&#x27;计数结束&#x27;</span>,QMessageBox.Ok)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">work</span>(<span class="hljs-params">self</span>):</span><br>        self.workThread.start()<br></code></pre></td></tr></table></figure><h3 id="十一、PyQT5和Web的交互技术"><a href="#十一、PyQT5和Web的交互技术" class="headerlink" title="十一、PyQT5和Web的交互技术"></a>十一、PyQT5和Web的交互技术</h3><p>同时使用python和web开发程序（混合编程），Python + JavaScript + HTML5 + CSS</p><p><code>Web</code>:开发漂亮的UI界面  <code>PyQT5</code>：开发相对底层的功能</p><p>1.<code>QWebEngineView</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebEngineView</span>(<span class="hljs-params">QMainWindow</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self </span>):</span><br>        <span class="hljs-built_in">super</span>(WebEngineView, self).__init__()<br>        self.setWindowTitle(<span class="hljs-string">&#x27;打开外部网页例子&#x27;</span>)<br>        self.setGeometry(<span class="hljs-number">5</span>, <span class="hljs-number">30</span>, <span class="hljs-number">1355</span>, <span class="hljs-number">730</span>)<br>        self.browser = QWebEngineView()<br>        self.browser.load(QUrl(<span class="hljs-string">&#x27;https://www.jd.com&#x27;</span>))<span class="hljs-comment"># 显示url页面</span><br>        self.setCentralWidget(self.browser)<br></code></pre></td></tr></table></figure><p>此外，还可以：1）显示本地的web页面，前提是本地有<code>.html</code>文件； 2）直接在代码中编辑html页面</p><p>2.<code>pyqt5</code>调用<code>JavaScript</code>代码</p><p>略</p>]]></content>
    
    
    <categories>
      
      <category>Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OICR源码收获</title>
    <link href="/2021/08/19/OICR%E6%BA%90%E7%A0%81%E6%94%B6%E8%8E%B7/"/>
    <url>/2021/08/19/OICR%E6%BA%90%E7%A0%81%E6%94%B6%E8%8E%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="OICR源码收获"><a href="#OICR源码收获" class="headerlink" title="OICR源码收获"></a>OICR源码收获</h2><p>整篇代码的架构梳理在<code>notability</code>上有笔记，这里只对一些python、pytorch中的知识漏洞进行讲解。</p><p>包含<code>stack</code>、<code>vstack</code>、<code>hstack</code>讲解。</p><span id="more"></span><p>1.对pytorch中<code>dim</code>的理解</p><p>参考：<a href="https://blog.csdn.net/qq_41375609/article/details/106078474">Pytorch笔记：维度dim的定义及其理解使用_Activewaste-CSDN博客</a></p><p>举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">z = torch.ones(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>则有 z.size(0) = 2，z.size(1) = 3，z.size(2) = 4；第0维度为2，第1维度为3，第2维度为4，即维度的标号是以0开始的；</p><p>在<code>.sum()</code>、<code>.mean()</code>等方法中涉及<code>dim</code>参数，指对特定维度进行操作，</p><p><strong><code>dim=x</code>即对第x维进行操作，操作完之后，只有第x维的维数改变了！</strong></p><p>因此，<code>dim=0</code>表示对列求和，求完后只有第0维(行数)发生了变化；</p><p>对于<code>dim=0</code>和<code>dim=1</code>经常混淆的问题，用弹簧帮助记忆：</p><p>dim=0：</p><img src="/.com//blog\source\images\dsfadsf" alt="在这里插入图片描述" style="zoom:33%;"><p>dim=1：</p><img src="/.com//blog\source\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTI4MTk0OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:33%;"><p>拓展：</p><p>1）在oicr源码中，涉及到了<code>loss.sum(dim=2)</code>的代码，其实<code>dim=2</code>在弱监督目标检测中应该是比较常见的：</p><p>因为通常张量会有一个额外的维度<code>proposal</code>，因此会涉及三个维度：proposal、class、batch_size。</p><p>2）如果<code>.sum()</code>不传dim参数，则表示对所有元素进行求和，结果是一个标量。</p><p>2.pytorch中的<code>.numel()</code>方法</p><p><code>numel</code>= number of elements，返回一个张量中所有元素的个数</p><p>综合上述两点，来看一下oicr的一段源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">WeightedSoftmaxWithLoss</span>(<span class="hljs-params">prob, labels_ic, cls_loss_weights, eps = <span class="hljs-number">1e-6</span></span>):</span><br>    loss = (labels_ic * torch.log(prob + eps))  <span class="hljs-comment"># labels_ic是refine阶段的标签，是由proposal的类别置信度经过阈值筛选得到的</span><br>    loss = loss.<span class="hljs-built_in">sum</span>(dim=<span class="hljs-number">2</span>)<br>    loss = -cls_loss_weights * loss<br>    ret = loss.<span class="hljs-built_in">sum</span>() / loss.numel()<br>    <span class="hljs-keyword">if</span> torch.isnan(ret.<span class="hljs-built_in">sum</span>()) :<br>        pdb.set_trace()<br>    <span class="hljs-keyword">return</span> ret<br></code></pre></td></tr></table></figure><p>该源码完成了下述loss的计算：</p><p><img src="/.com//blog\source\images\image-20210815220233076.png" alt="image-20210815220233076"></p><p>这也是oicr中<code>refined classifer</code>阶段的损失函数。</p><p>3.<code>Pytorch</code>知识漏洞之<code>autograd</code>包</p><p><a href="https://pytorch.org/docs/stable/autograd.html">autograd</a>包能够根据输入和前向传播过程自动构建计算图，并执行反向传播。</p><p><code>pytorch0.4</code>之后的版本，<code>tensor</code>就已经支持<code>autograd</code>了。</p><p>1）<code>Tensor</code>是这个包的核心类，如果将其属性<code>.requires_grad</code>设置为<code>True</code>，它将开始追踪(track)在其上的所有操作（这样就可以利用链式法则进行梯度传播了）。完成计算后，可以调用<code>.backward()</code>来完成所有梯度计算。此<code>Tensor</code>的梯度将累积到<code>.grad</code>属性中。</p><p>如果不想要被继续追踪，可以调用<code>.detach()</code>将其从追踪记录中分离出来，这样就可以防止将来的计算被追踪，这样梯度就传不过去了。此外，还可以用<code>with torch.no_grad()</code>将不想被追踪的操作代码块包裹起来，这种方法在评估模型的时候很常用，因为在评估模型时，我们并不需要计算可训练参数（<code>requires_grad=True</code>）的梯度。</p><p>2）<code>Function</code>是另外一个很重要的类。<code>Tensor</code>和<code>Function</code>互相结合就可以构建一个记录有整个计算过程的有向无环图（DAG）。每个<code>Tensor</code>都有一个<code>.grad_fn</code>属性，该属性即创建该<code>Tensor</code>的<code>Function</code>, 就是说该<code>Tensor</code>是不是通过某些运算得到的，若是，则<code>grad_fn</code>返回一个与这些运算相关的对象，否则是None。</p><p>当函数的自变量、因变量都是向量时，梯度就是一个雅可比矩阵，而<code>torch.autograd</code>这个包就是用来计算一些雅克比矩阵的乘积的。同时，grad在反向传播过程中是**累加的(accumulated)**，这意味着每一次运行反向传播，梯度都会累加之前的梯度，所以一般在反向传播之前需把梯度清零。</p><p>拓展：很多源码中出现了<code>torch.autograd.Variable</code>，因为在老版本的pytorch中，tensor必须放在Variable中才能记录梯度和计算图，才能进而执行反向传播。Varibale包含三个属性：</p><p>​        data：存储了Tensor，是本体的数据<br>​        grad：保存了data的梯度，本事是个Variable而非Tensor，与data形状一致<br>​        grad_fn：指向Function对象，用于反向传播的梯度计算之用</p><p><strong>但是从<code>pytorch0.4</code>开始，variable就已经不再需要了！！！ tensor就支持autograd了！</strong></p><p><img src="/.com//blog\source\images\image-20210816171532297.png" alt="image-20210816171532297"></p><p>4.对不同维度做Softmax操作</p><p>只需要传参数<code>dim</code>即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">ic_score = self.ic_score(fc7).view(batch_size,num_boxes,self.n_classes+<span class="hljs-number">1</span>)<br>   ic_score1 = self.ic_score1(fc7).view(batch_size,num_boxes,self.n_classes+<span class="hljs-number">1</span>)<br>   ic_score2 = self.ic_score2(fc7).view(batch_size,num_boxes,self.n_classes+<span class="hljs-number">1</span>)<br>   self.ic_prob = F.softmax(ic_score, dim=<span class="hljs-number">2</span>)<span class="hljs-comment"># dim=2</span><br>   self.ic_prob1 = F.softmax(ic_score1, dim=<span class="hljs-number">2</span>)<br>   self.ic_prob2 = F.softmax(ic_score2, dim=<span class="hljs-number">2</span>)<br>   loss_midn=loss_oicr=loss_oicr1=loss_oicr2=<span class="hljs-number">0</span><br>   <br>   self.midn_prob0 = self.midn_score0(fc7).view(batch_size, num_boxes, self.n_classes)<br>   self.midn_prob1 = self.midn_score1(fc7).view(batch_size, num_boxes, self.n_classes)<br>   self.midn_prob0 = F.softmax(self.midn_prob0,dim=<span class="hljs-number">1</span>) <span class="hljs-comment"># dim=1 ; rois</span><br>   self.midn_prob1 = F.softmax(self.midn_prob1,dim=<span class="hljs-number">2</span>) <span class="hljs-comment"># dim=2 ; class</span><br></code></pre></td></tr></table></figure><p>5.stack操作: torch和numpy的</p><p>通过下面这个例子，基本可以了解<code>stack()、vstack()、hstack()</code>的用法：</p><img src="/.com//blog\source\images\image-20210819111359832.png" alt="image-20210819111359832" style="zoom: 67%;"><p>简单理解，就是：</p><p>1）<code>stack</code>会增加维度，有axis来确定；</p><p>​        <code>vstack</code>、<code>hstack</code>就像“合并”，不会增加维度；</p><p>2）<code>numpy.vstack</code>等价于<code>axis=0</code>时的<code>numpy.concatenate</code></p><p>​      <code>numpy.hstack</code>等价于<code>axis=1</code>时的<code>numpy.concatenate</code></p><p>注：numpy和pytorch的stack、vstack、hstack是一样的！</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning-Objects Detection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch_Related（四）</title>
    <link href="/2021/08/16/Pytorch-Related%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2021/08/16/Pytorch-Related%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="项目三：基于Pytorch搭建Faster-RCNN实现飞机目标检测任务"><a href="#项目三：基于Pytorch搭建Faster-RCNN实现飞机目标检测任务" class="headerlink" title="项目三：基于Pytorch搭建Faster RCNN实现飞机目标检测任务"></a>项目三：基于Pytorch搭建Faster RCNN实现飞机目标检测任务</h2><span id="more"></span><h3 id="一、目标检测算法常用的评估指标——-mAP"><a href="#一、目标检测算法常用的评估指标——-mAP" class="headerlink" title="一、目标检测算法常用的评估指标—— mAP"></a>一、目标检测算法常用的评估指标—— mAP</h3><p>mAP指各类别AP的平均值，AP指PR曲线下面积，其计算比较复杂；PR曲线和<code>Precision</code>、<code>Recall</code>有关，涉及PR曲线面积时会使用<strong>“11点插值法”</strong>，</p><p>具体方法见：<a href="https://work.datafountain.cn/forum?id=90&type=2&source=1">个人工作平台 (datafountain.cn)</a></p><p>mAP计算方法github原文：<a href="https://github.com/rafaelpadilla/Object-Detection-Metrics">rafaelpadilla/Object-Detection-Metrics: Most popular metrics used to evaluate object detection algorithms. (github.com)</a></p><h3 id="二、COCO数据集标注格式——-json"><a href="#二、COCO数据集标注格式——-json" class="headerlink" title="二、COCO数据集标注格式—— json"></a>二、COCO数据集标注格式—— json</h3><p>1.COCO的标注文件为json格式，共有三个字段：</p><p>1）images  代表图片信息，包括图片id，图片名file_name, 图片的宽高<br>2）annotations 代表bbox的坐标信息，包括bbox id，所属图片的image_id， bbox格式为:[[x,y,w,h]]， 以及类别id<br>3）categories 代表类别信息，包括类别id，类别名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;datasets/mini_airplane/annotations/mini_airplane_train.json&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    labels = json.load(f)<br>    <br><span class="hljs-comment"># labels[&quot;images&quot;]代表了所有图片的信息，labels[&quot;images&quot;][0]指第一张图片</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;images:&quot;</span>)<br><span class="hljs-built_in">print</span>(labels[<span class="hljs-string">&quot;images&quot;</span>][<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;annotations:&quot;</span>)<br><span class="hljs-built_in">print</span>(labels[<span class="hljs-string">&quot;annotations&quot;</span>][<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;categories:&quot;</span>)<br><span class="hljs-built_in">print</span>(labels[<span class="hljs-string">&quot;categories&quot;</span>])<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">images:<br>&#123;<span class="hljs-string">&#x27;license&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;file_name&#x27;</span>: <span class="hljs-string">&#x27;COCO_val2014_000000253223.jpg&#x27;</span>, <span class="hljs-string">&#x27;coco_url&#x27;</span>: <span class="hljs-string">&#x27;http://images.cocodataset.org/val2014/COCO_val2014_000000253223.jpg&#x27;</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">480</span>, <span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">640</span>, <span class="hljs-string">&#x27;date_captured&#x27;</span>: <span class="hljs-string">&#x27;2013-11-15 13:20:30&#x27;</span>, <span class="hljs-string">&#x27;flickr_url&#x27;</span>: <span class="hljs-string">&#x27;http://farm1.staticflickr.com/81/214855814_0da704e0f6_z.jpg&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-number">1</span>&#125;<br>annotations:<br>&#123;<span class="hljs-string">&#x27;segmentation&#x27;</span>: [[<span class="hljs-number">83.76</span>, <span class="hljs-number">185.62</span>, <span class="hljs-number">88.9</span>, <span class="hljs-number">192.63</span>, <span class="hljs-number">87.97</span>, <span class="hljs-number">197.77</span>, <span class="hljs-number">92.64</span>, <span class="hljs-number">194.5</span>, <span class="hljs-number">103.39</span>, <span class="hljs-number">195.9</span>, <span class="hljs-number">108.54</span>, <span class="hljs-number">196.84</span>, <span class="hljs-number">110.87</span>, <span class="hljs-number">200.11</span>, <span class="hljs-number">110.87</span>, <span class="hljs-number">206.65</span>, <span class="hljs-number">111.81</span>, <span class="hljs-number">208.06</span>, <span class="hljs-number">115.55</span>, <span class="hljs-number">200.58</span>, <span class="hljs-number">121.62</span>, <span class="hljs-number">201.98</span>, <span class="hljs-number">121.62</span>, <span class="hljs-number">198.71</span>, <span class="hljs-number">116.95</span>, <span class="hljs-number">197.77</span>, <span class="hljs-number">120.69</span>, <span class="hljs-number">195.44</span>, <span class="hljs-number">129.1</span>, <span class="hljs-number">196.37</span>, <span class="hljs-number">128.17</span>, <span class="hljs-number">198.24</span>, <span class="hljs-number">134.24</span>, <span class="hljs-number">192.63</span>, <span class="hljs-number">133.78</span>, <span class="hljs-number">191.7</span>, <span class="hljs-number">126.3</span>, <span class="hljs-number">189.83</span>, <span class="hljs-number">123.49</span>, <span class="hljs-number">189.83</span>, <span class="hljs-number">116.48</span>, <span class="hljs-number">188.42</span>, <span class="hljs-number">113.68</span>, <span class="hljs-number">188.89</span>, <span class="hljs-number">102.93</span>, <span class="hljs-number">178.61</span>, <span class="hljs-number">101.52</span>, <span class="hljs-number">177.67</span>, <span class="hljs-number">100.12</span>, <span class="hljs-number">178.61</span>, <span class="hljs-number">102.93</span>, <span class="hljs-number">182.82</span>, <span class="hljs-number">101.99</span>, <span class="hljs-number">184.22</span>, <span class="hljs-number">107.13</span>, <span class="hljs-number">190.29</span>, <span class="hljs-number">98.25</span>, <span class="hljs-number">189.83</span>, <span class="hljs-number">94.05</span>, <span class="hljs-number">185.15</span>, <span class="hljs-number">89.37</span>, <span class="hljs-number">181.88</span>, <span class="hljs-number">88.44</span>, <span class="hljs-number">183.28</span>, <span class="hljs-number">88.9</span>, <span class="hljs-number">186.09</span>, <span class="hljs-number">88.9</span>, <span class="hljs-number">187.96</span>, <span class="hljs-number">88.44</span>, <span class="hljs-number">188.42</span>, <span class="hljs-number">84.7</span>, <span class="hljs-number">185.15</span>, <span class="hljs-number">83.76</span>, <span class="hljs-number">185.62</span>]],<span class="hljs-string">&#x27;area&#x27;</span>:<span class="hljs-number">460.263049996</span>, <span class="hljs-string">&#x27;iscrowd&#x27;</span>:<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;image_id&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;bbox&#x27;</span>:[<span class="hljs-number">83.76</span>,<span class="hljs-number">177.67</span>,<span class="hljs-number">50.48</span>,<span class="hljs-number">30.39</span>], <span class="hljs-string">&#x27;category_id&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;id&#x27;</span>:<span class="hljs-number">1</span>&#125;<br>categories:<br>[&#123;<span class="hljs-string">&#x27;id&#x27;</span>:<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;airplane&#x27;</span>&#125;]<br></code></pre></td></tr></table></figure><p>分析上述输出可总结coco标注 json文件的特点：</p><p>(1) 三个大的字段<code>images</code>、<code>annotations</code>、<code>categories</code>，每个字段都是一个<code>list[dict]</code>：例如，取<code>labels[&quot;categories&quot;]</code>，则它是一个列表，取<code>labels[&quot;categories&quot;][0]</code>，则它是一个字典</p><p>(2) 三个大字段下的键值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># images字段下keys有：</span><br>license、file_name、coco_url、height、width、data_captured、flickr_url、<span class="hljs-built_in">id</span><br><span class="hljs-comment"># annotations字段下keys有：</span><br>segmentation、area、iscrowd、image_id、bbox、category_id、<span class="hljs-built_in">id</span><br><span class="hljs-comment"># categories字段下keys有：</span><br><span class="hljs-built_in">id</span>、name<br></code></pre></td></tr></table></figure><p><strong>2.预获取一些变量，方便后续操作：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># “映射字典”</span><br>imagename2id = &#123;&#125;<br>imageid2bbox = &#123;&#125;<br>imageid2anno = &#123;&#125;<br>imagename2imageinfo = &#123;&#125;<br><span class="hljs-keyword">for</span> image <span class="hljs-keyword">in</span> labels[<span class="hljs-string">&quot;images&quot;</span>]:  <span class="hljs-comment"># 遍历每张图片</span><br>    imagename2id[image[<span class="hljs-string">&quot;file_name&quot;</span>]] = image[<span class="hljs-string">&quot;id&quot;</span>]<span class="hljs-comment"># file_name映射为id</span><br>    imagename2imageinfo[image[<span class="hljs-string">&quot;file_name&quot;</span>]] = image  <span class="hljs-comment"># file_name映射为整个该图片的整个images字段</span><br><span class="hljs-keyword">for</span> anno <span class="hljs-keyword">in</span> labels[<span class="hljs-string">&quot;annotations&quot;</span>]:<span class="hljs-comment"># 遍历所有标注（由于每张图片不一定只有1个标注，所有处理有些不同）</span><br>    <span class="hljs-keyword">if</span> anno[<span class="hljs-string">&quot;image_id&quot;</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> imageid2bbox:  <span class="hljs-comment"># 判断id没有出现过（即该图片没出现过）</span><br>        imageid2bbox[anno[<span class="hljs-string">&quot;image_id&quot;</span>]] = []<span class="hljs-comment"># 则为该图片新建一个列表，用来存放所有属于该图片的annotation</span><br>    imageid2bbox[anno[<span class="hljs-string">&quot;image_id&quot;</span>]].append(anno[<span class="hljs-string">&quot;bbox&quot;</span>])<br>    <span class="hljs-keyword">if</span> anno[<span class="hljs-string">&quot;image_id&quot;</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> imageid2anno:<br>        imageid2anno[anno[<span class="hljs-string">&quot;image_id&quot;</span>]] = []<br>    imageid2anno[anno[<span class="hljs-string">&quot;image_id&quot;</span>]].append(anno)<br></code></pre></td></tr></table></figure><p>这一步其实在预处理阶段很重要，有了这些<strong>映射字典</strong>，后面的处理会方便很多</p><p>3.可视化一张图片</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>%matplotlib inline<br>plt.rcParams[<span class="hljs-string">&#x27;figure.figsize&#x27;</span>] = (<span class="hljs-number">12.0</span>, <span class="hljs-number">12.0</span>) <br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>img = cv2.imread(<span class="hljs-string">&#x27;datasets/mini_airplane/images/COCO_val2014_000000253223.jpg&#x27;</span>)<br>bboxes = imageid2bbox[imagename2id[<span class="hljs-string">&#x27;COCO_val2014_000000253223.jpg&#x27;</span>]]<br><span class="hljs-keyword">for</span> det <span class="hljs-keyword">in</span> bboxes:<br>    bbox = np.array(det[:<span class="hljs-number">4</span>]).astype(<span class="hljs-built_in">int</span>)<br>    <span class="hljs-comment"># 用openv在图片上画矩形</span><br>    <span class="hljs-comment"># coco的bbox格式为(x,y,w,h)</span><br>    cv2.rectangle(img, (bbox[<span class="hljs-number">0</span>],bbox[<span class="hljs-number">1</span>]), (bbox[<span class="hljs-number">0</span>]+bbox[<span class="hljs-number">2</span>], bbox[<span class="hljs-number">1</span>]+bbox[<span class="hljs-number">3</span>]), (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>), <span class="hljs-number">1</span>)<br>    label_text = <span class="hljs-built_in">str</span>(<span class="hljs-string">&quot;airplane&quot;</span>)<br>    cv2.putText(img, label_text, (bbox[<span class="hljs-number">0</span>], bbox[<span class="hljs-number">1</span>] - <span class="hljs-number">2</span>),<br>            cv2.FONT_HERSHEY_COMPLEX, <span class="hljs-number">0.5</span>, (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">255</span>))<br>im2 = img[:,:,::-<span class="hljs-number">1</span>] <br>plt.imshow(im2)<br>plt.show()<br></code></pre></td></tr></table></figure><h3 id="三、划分数据集方法总结"><a href="#三、划分数据集方法总结" class="headerlink" title="三、划分数据集方法总结"></a>三、划分数据集方法总结</h3><p>1.利用<code>pytorch</code>的<code>random_split()</code>方法</p><p>用此方法的前提：数据用<code>ImageFolder</code>读取的对象(PIL Image对象)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> random_split<br>dataset=ImageFolder(<span class="hljs-string">&quot;Img2021&quot;</span>,transform=trans)<br><br><span class="hljs-comment"># 划分训练集、测试集</span><br>n_test = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(dataset) * <span class="hljs-number">0.2</span>)  <span class="hljs-comment"># 测试集占20%，训练集80%</span><br>n_train = <span class="hljs-built_in">len</span>(dataset) - n_test<br>train, test = random_split(dataset, [n_train, n_test])<br></code></pre></td></tr></table></figure><p>2.利用<code>sklearn</code>的<code>train_test_split()</code>方法</p><p>用此方法的前提：数据是numpy数组形式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br>Xtrain, Xtest, Ytrain, Ytest = train_test_split(data_np, label_np, test_size=<span class="hljs-number">0.3</span>, random_state=<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>3.利用<code>numpy</code>的<code>random.choice()</code>方法</p><p>此方法的逻辑：实质是对图片的id / 索引 进行随机划分，而不是直接对数据本身的划分；</p><p>因此这种方法通常可用于标准数据集如VOC、COCO等，容易获取图片id的数据集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>np.random.seed(<span class="hljs-number">123</span>)<br>train_image_names = np.random.choice(<span class="hljs-built_in">list</span>(imagename2id.keys()), <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(imagename2id.keys())*<span class="hljs-number">0.8</span>), <span class="hljs-literal">False</span>)<span class="hljs-comment"># train的图片names</span><br>val_image_names = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">set</span>(imagename2id.keys()) - <span class="hljs-built_in">set</span>(train_image_names))<span class="hljs-comment"># test的图片names</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;train_image_names length: &quot;</span>, <span class="hljs-built_in">len</span>(train_image_names))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;val_image_names length: &quot;</span>, <span class="hljs-built_in">len</span>(val_image_names))<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 本项目是目标检测，所以先会对labels进行划分</span><br><span class="hljs-comment"># 上面得到了划分完后的索引，还要继续划分到更具体的图片labels上</span><br><span class="hljs-keyword">import</span> os<br>train_images = []<br>train_annotations = []<br><span class="hljs-keyword">for</span> imgname <span class="hljs-keyword">in</span> train_image_names:<span class="hljs-comment"># 遍历训练集所有names</span><br>    train_images.append(imagename2imageinfo[imgname])<span class="hljs-comment"># 将所有图片info加入train_images中</span><br>    image_id = imagename2id[imgname]<span class="hljs-comment"># 依次获得图片id，为下一行语句使用</span><br>    train_annotations.extend(imageid2anno[image_id])<span class="hljs-comment"># 将该图片所有anno放入train_annotations中</span><br>train_instance = &#123;<br>    <span class="hljs-string">&quot;images&quot;</span>: train_images,<span class="hljs-comment"># list</span><br>    <span class="hljs-string">&quot;annotations&quot;</span>: train_annotations,<span class="hljs-comment"># list</span><br>    <span class="hljs-string">&quot;categories&quot;</span>: labels[<span class="hljs-string">&quot;categories&quot;</span>]<br>&#125;<br>dirs = <span class="hljs-string">r&#x27;temp/mini_airplane/annotations&#x27;</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(dirs):<br>    os.makedirs(dirs)<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;temp/mini_airplane/annotations/train.json&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<span class="hljs-comment"># 写方式打开文件</span><br>    json.dump(train_instance, f, indent=<span class="hljs-number">2</span>)<span class="hljs-comment"># 把训练集写入train.json文件</span><br>    <span class="hljs-comment"># 综上，写入的内容有：图片info(整个images字段)、图片anno</span><br>    <br><span class="hljs-comment"># 测试集完全同理</span><br>val_images = []<br>val_annotations = []<br><span class="hljs-keyword">for</span> imgname <span class="hljs-keyword">in</span> val_image_names:<br>    val_images.append(imagename2imageinfo[imgname])<br>    image_id = imagename2id[imgname]<br>    val_annotations.extend(imageid2anno[image_id])<br>val_instance = &#123;<br>    <span class="hljs-string">&quot;images&quot;</span>: val_images,<br>    <span class="hljs-string">&quot;annotations&quot;</span>: val_annotations,<br>    <span class="hljs-string">&quot;categories&quot;</span>: labels[<span class="hljs-string">&quot;categories&quot;</span>]<br>&#125;<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;temp/mini_airplane/annotations/val.json&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    json.dump(val_instance, f, indent=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>综上，写入的内容有：图片info(整个images字段)、图片anno</p><p>知识漏洞之<code>list.extend()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 用于在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表)</span><br>aList = [<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;xyz&#x27;</span>, <span class="hljs-string">&#x27;zara&#x27;</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">123</span>];<br>bList = [<span class="hljs-number">2009</span>, <span class="hljs-string">&#x27;manni&#x27;</span>];<br>aList.extend(bList)<br><br><span class="hljs-comment"># 避免了append一次只能添加一个值的窘境</span><br></code></pre></td></tr></table></figure><h3 id="四、定义数据类"><a href="#四、定义数据类" class="headerlink" title="四、定义数据类"></a>四、定义数据类</h3><p>通过继承torch的Dataset类来定义自己的数据类，从而用于训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.utils.data<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> skimage <span class="hljs-keyword">import</span> io<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AirplaneDetDataset</span>(<span class="hljs-params">torch.utils.data.Dataset</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, root, anno_file, transforms=<span class="hljs-literal">None</span></span>):</span><br>        self.root = root<br>        self.transforms = transforms<br>        self.imgs = []<br>        <span class="hljs-comment"># 从label文件中载入所有的图片，并且预先生成图片名称和图片label的对应，便于__getitem__使用</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(os.path.join(root, <span class="hljs-string">&quot;annotations&quot;</span>, anno_file), <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            labels = json.load(f)<span class="hljs-comment"># anno_file: &quot;train.json&quot; / &quot;val.json&quot;</span><br>        self.imagename2id = &#123;&#125;<br>        self.imageid2anno = &#123;&#125;<br>        <span class="hljs-keyword">for</span> image <span class="hljs-keyword">in</span> labels[<span class="hljs-string">&quot;images&quot;</span>]:<span class="hljs-comment"># 遍历图片info</span><br>            self.imgs.append(image[<span class="hljs-string">&quot;file_name&quot;</span>])<br>            self.imagename2id[image[<span class="hljs-string">&quot;file_name&quot;</span>]] = image[<span class="hljs-string">&quot;id&quot;</span>]<br>        <span class="hljs-keyword">for</span> anno <span class="hljs-keyword">in</span> labels[<span class="hljs-string">&quot;annotations&quot;</span>]:<span class="hljs-comment"># 遍历图片anno</span><br>            <span class="hljs-keyword">if</span> anno[<span class="hljs-string">&quot;image_id&quot;</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self.imageid2anno:<br>                self.imageid2anno[anno[<span class="hljs-string">&quot;image_id&quot;</span>]] = []<br>            self.imageid2anno[anno[<span class="hljs-string">&quot;image_id&quot;</span>]].append(anno[<span class="hljs-string">&quot;bbox&quot;</span>])<br>    <br>    <span class="hljs-comment"># 读取实际的图片!</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, idx</span>):</span><br>        img_path = os.path.join(self.root, <span class="hljs-string">&quot;images&quot;</span>, self.imgs[idx])<br>        img_path = os.path.abspath(img_path)<br>        <span class="hljs-comment"># 载入图片并转换为pytorch所需格式</span><br>        img = cv2.imread(img_path, cv2.IMREAD_COLOR)<br>    <span class="hljs-comment"># img = io.imread(img_path)</span><br>        img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB).astype(np.float32)<br>        img = img / <span class="hljs-number">255.0</span><br>        img = img.transpose(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<span class="hljs-comment"># 将通道数提前</span><br>        img = torch.tensor(img)<br>        img_id = self.imagename2id[self.imgs[idx]]<br>        boxes = []<br>        <span class="hljs-comment"># 读取该图片对应的bbox label</span><br>        <span class="hljs-keyword">for</span> bbox <span class="hljs-keyword">in</span> self.imageid2anno[img_id]:<br>            xmin = bbox[<span class="hljs-number">0</span>]<br>            ymin = bbox[<span class="hljs-number">1</span>]<br>            xmax = bbox[<span class="hljs-number">0</span>] + bbox[<span class="hljs-number">2</span>]<br>            ymax = bbox[<span class="hljs-number">1</span>] + bbox[<span class="hljs-number">3</span>]<br>            boxes.append([xmin, ymin, xmax, ymax])<br>        num_objs = <span class="hljs-built_in">len</span>(self.imageid2anno[img_id])<br>        boxes = torch.as_tensor(boxes, dtype=torch.float32)<br>        <span class="hljs-comment"># 只有飞机这一类，所以所有类别label都给1</span><br>        labels = torch.ones((num_objs,), dtype=torch.int64)<br>        <br>        image_id = torch.tensor([idx])<br>        area = (boxes[:, <span class="hljs-number">3</span>] - boxes[:, <span class="hljs-number">1</span>]) * (boxes[:, <span class="hljs-number">2</span>] - boxes[:, <span class="hljs-number">0</span>])<br>        <span class="hljs-comment"># 这里我们假设所有的目标label都是不互相严重遮挡的</span><br>        iscrowd = torch.zeros((num_objs,), dtype=torch.int64)<br>        <span class="hljs-comment"># 最终我们输出的label是一个dict的格式，里面包括以下的字段用于训练</span><br>        target = &#123;&#125;<br>        target[<span class="hljs-string">&quot;boxes&quot;</span>] = boxes<br>        target[<span class="hljs-string">&quot;labels&quot;</span>] = labels<br>        target[<span class="hljs-string">&quot;image_id&quot;</span>] = image_id<br>        target[<span class="hljs-string">&quot;area&quot;</span>] = area<br>        target[<span class="hljs-string">&quot;iscrowd&quot;</span>] = iscrowd<br><br>        <span class="hljs-keyword">if</span> self.transforms <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            img, target = self.transforms(img, target)<br>        <span class="hljs-comment"># 最终返回图片矩阵，label以及图片名</span><br>        <span class="hljs-keyword">return</span> img, target, self.imgs[idx]<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.imgs)<br></code></pre></td></tr></table></figure><p>调用举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> shutil<br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(<span class="hljs-string">&#x27;./temp/mini_airplane/images&#x27;</span>):<br>    shutil.copytree(<span class="hljs-string">&#x27;./datasets/mini_airplane/images&#x27;</span>,<span class="hljs-string">&#x27;./temp/mini_airplane/images&#x27;</span>)<br>dataset = AirplaneDetDataset(<span class="hljs-string">&#x27;./temp/mini_airplane&#x27;</span>, <span class="hljs-string">&#x27;train.json&#x27;</span>)<br>dataset[<span class="hljs-number">0</span>]  <span class="hljs-comment"># 有了__getitem__方法，就可以像使用列表一样了</span><br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">(tensor([[[<span class="hljs-number">0.9451</span>, <span class="hljs-number">0.9490</span>, <span class="hljs-number">0.9490</span>,  ..., <span class="hljs-number">0.9373</span>, <span class="hljs-number">0.9373</span>, <span class="hljs-number">0.9373</span>],<br>          [<span class="hljs-number">0.9490</span>, <span class="hljs-number">0.9490</span>, <span class="hljs-number">0.9451</span>,  ..., <span class="hljs-number">0.9373</span>, <span class="hljs-number">0.9373</span>, <span class="hljs-number">0.9373</span>],<br>          [<span class="hljs-number">0.9490</span>, <span class="hljs-number">0.9451</span>, <span class="hljs-number">0.9451</span>,  ..., <span class="hljs-number">0.9373</span>, <span class="hljs-number">0.9373</span>, <span class="hljs-number">0.9333</span>],<br>          ...,<br>          [<span class="hljs-number">0.3647</span>, <span class="hljs-number">0.1882</span>, <span class="hljs-number">0.0745</span>,  ..., <span class="hljs-number">0.0353</span>, <span class="hljs-number">0.0353</span>, <span class="hljs-number">0.0353</span>],<br>          [<span class="hljs-number">0.4941</span>, <span class="hljs-number">0.2980</span>, <span class="hljs-number">0.0824</span>,  ..., <span class="hljs-number">0.0314</span>, <span class="hljs-number">0.0353</span>, <span class="hljs-number">0.0392</span>],<br>          [<span class="hljs-number">0.1529</span>, <span class="hljs-number">0.1216</span>, <span class="hljs-number">0.2549</span>,  ..., <span class="hljs-number">0.0353</span>, <span class="hljs-number">0.0314</span>, <span class="hljs-number">0.0353</span>]],<br> <br>         [[<span class="hljs-number">0.9569</span>, <span class="hljs-number">0.9608</span>, <span class="hljs-number">0.9608</span>,  ..., <span class="hljs-number">0.9490</span>, <span class="hljs-number">0.9490</span>, <span class="hljs-number">0.9490</span>],<br>          [<span class="hljs-number">0.9608</span>, <span class="hljs-number">0.9608</span>, <span class="hljs-number">0.9569</span>,  ..., <span class="hljs-number">0.9490</span>, <span class="hljs-number">0.9490</span>, <span class="hljs-number">0.9490</span>],<br>          [<span class="hljs-number">0.9608</span>, <span class="hljs-number">0.9569</span>, <span class="hljs-number">0.9569</span>,  ..., <span class="hljs-number">0.9490</span>, <span class="hljs-number">0.9490</span>, <span class="hljs-number">0.9451</span>],<br>          ...,<br>          &#123;<span class="hljs-string">&#x27;boxes&#x27;</span>: tensor([[<span class="hljs-number">113.4800</span>,  <span class="hljs-number">51.8000</span>, <span class="hljs-number">362.9400</span>, <span class="hljs-number">237.8700</span>]]),<br>    <span class="hljs-string">&#x27;labels&#x27;</span>: tensor([<span class="hljs-number">1</span>]),<br>   <span class="hljs-string">&#x27;image_id&#x27;</span>: tensor([<span class="hljs-number">0</span>]),<br>   <span class="hljs-string">&#x27;area&#x27;</span>: tensor([<span class="hljs-number">46417.0195</span>]),<br>    <span class="hljs-string">&#x27;iscrowd&#x27;</span>: tensor([<span class="hljs-number">0</span>])&#125;,<br>  <span class="hljs-string">&#x27;COCO_val2014_000000145019.jpg&#x27;</span>)<br></code></pre></td></tr></table></figure><p>1）知识漏洞之<code>torch.as_tensor()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 共享内存？</span><br>t1=torch.tensor(data)  <span class="hljs-comment"># 新内存</span><br>t2=torch.from_numpy(data)<span class="hljs-comment"># 共享</span><br>t3=torch.as_tensor(data)<span class="hljs-comment"># 共享</span><br><br><span class="hljs-comment"># 关于as_tensor是否共享内存的进一步说明：</span><br>torch.as_tensor(data, dtype=<span class="hljs-literal">None</span>,device=<span class="hljs-literal">None</span>)<br><span class="hljs-comment"># 只有当dtype和device都与data相同时，才会共享内存</span><br></code></pre></td></tr></table></figure><p>综上，由其他python数据结构的数组创建tensor时，<strong>使用<code>as_tensor()</code>总是好的</strong>，它会自行判断是否共享内存。</p><p><strong>2）知识漏洞之<code>__getitem__</code>类方法：</strong></p><p>很多代码框架中，都出现了<code>__getitem__</code>类方法，到底是什么意思？Stack overflow上有人给出了好的解释：<a href="https://stackoverflow.com/questions/43627405/understanding-getitem-method">python - Understanding <strong>getitem</strong> method - Stack Overflow</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. The primary use case, in my opinion, is when you are writing a custom class that represents a collection of things. This allows you to use the familiar list/array indexing like planets[i] to access a given item even though planets is not actually a list (and it could, under the covers, use any data structure it chooses, such as a linked list or graph, or implement any non-list functions that it chooses, which a list could not). – jarmod Oct 6 &#x27;20 at 11:15</span><br><br><span class="hljs-comment"># 2. The [] syntax for getting item by key or index is just syntax sugar. When you evaluate a[i] Python calls a.__getitem__(i) (or type(a).__getitem__(a, i), but this distinction is about inheritance models and is not important here). Even if the class of a may not explicitly define this method, it is usually inherited from an ancestor class.</span><br></code></pre></td></tr></table></figure><p>也就是说，通过该方法，我们可以像使用列表一样使用类对象；定义了<code>__getitem__</code>类方法之后，使用 <code>a[i]</code> 就相当于在调用 <code>a.__getitem__(i)</code></p><p>再看网友给出的一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Without using __getitem__ we would have a class like this :</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Building</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, floors</span>):</span><br>         self._floors = [<span class="hljs-literal">None</span>]*floors<br>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">occupy</span>(<span class="hljs-params">self, floor_number, data</span>):</span><br>          self._floors[floor_number] = data<br>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_floor_data</span>(<span class="hljs-params">self, floor_number</span>):</span><br>          <span class="hljs-keyword">return</span> self._floors[floor_number]<br><br>building1 = Building(<span class="hljs-number">4</span>) <span class="hljs-comment"># Construct a building with 4 floors</span><br>building1.occupy(<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;Reception&#x27;</span>)<br>building1.occupy(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;ABC Corp&#x27;</span>)<br>building1.occupy(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;DEF Inc&#x27;</span>)<br><span class="hljs-built_in">print</span>( building1.get_floor_data(<span class="hljs-number">2</span>) )<br><br><span class="hljs-comment"># We could however use __getitem__ (and its counterpart __setitem__) to make the usage of the Building class &#x27;nicer&#x27;.</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Building</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, floors</span>):</span><br>         self._floors = [<span class="hljs-literal">None</span>]*floors<br>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__setitem__</span>(<span class="hljs-params">self, floor_number, data</span>):</span><br>          self._floors[floor_number] = data<br>     <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, floor_number</span>):</span><br>          <span class="hljs-keyword">return</span> self._floors[floor_number]<br><br>building1 = Building(<span class="hljs-number">4</span>) <span class="hljs-comment"># Construct a building with 4 floors</span><br>building1[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;Reception&#x27;</span><br>building1[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;ABC Corp&#x27;</span><br>building1[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;DEF Inc&#x27;</span><br><span class="hljs-built_in">print</span>( building1[<span class="hljs-number">2</span>] )<br></code></pre></td></tr></table></figure><p>综上，<code>__setitem__</code>通常配套使用，让我们像使用list一样使用类对象，代码变得非常简洁。</p><p>那么，同理，可以联想到<code>__len__</code>方法的作用，也是让我们可以直接对类对象写出这样的代码：<code>len(object)</code></p><p>3）知识漏洞之<code>shutil</code>模块—— 高阶文件操作</p><p>shutil模块提供了一系列对文件和文件及和的高阶操作，特别是提供了一些支持文件拷贝和删除的函数。</p><p>具体参见：<a href="https://www.cnblogs.com/dianel/p/10776981.html">python中的shutil模块 - Python运维开发 - 博客园 (cnblogs.com)</a></p><h3 id="五、模型构建"><a href="#五、模型构建" class="headerlink" title="五、模型构建"></a>五、模型构建</h3><p>1.获取现成的模型进行finetune：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torchvision.models.detection.faster_rcnn <span class="hljs-keyword">import</span> FastRCNNPredictor<br><span class="hljs-keyword">from</span> torchvision.models.detection <span class="hljs-keyword">import</span> FasterRCNN<br><span class="hljs-keyword">from</span> torchvision.models.detection.rpn <span class="hljs-keyword">import</span> AnchorGenerator<br><br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader, Dataset<br><span class="hljs-keyword">from</span> torch.utils.data.sampler <span class="hljs-keyword">import</span> SequentialSampler<br><br>      <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_object_detection_model</span>(<span class="hljs-params">num_classes</span>):</span><br>    <span class="hljs-comment"># 载入一个在COCO数据集上预训练好的faster rcnn 模型，backbone为resnet50，neck网络使用fpn</span><br>    model = torchvision.models.detection.fasterrcnn_resnet50_fpn(pretrained=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-comment"># 获取最后分类的head的输入特征维度</span><br>    in_features = model.roi_heads.box_predictor.cls_score.in_features<br>    <span class="hljs-comment"># 将最后分类的head从原始的COCO输出81类替换为我们现在输入的num_classes类，注意这里的num_classes=实际的类别数量+1，1代表背景</span><br>    model.roi_heads.box_predictor = FastRCNNPredictor(in_features, num_classes)<br><br>    <span class="hljs-keyword">return</span> model<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">device = torch.device(<span class="hljs-string">&#x27;cuda&#x27;</span>) <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> torch.device(<span class="hljs-string">&#x27;cpu&#x27;</span>)<br><span class="hljs-comment"># 构建我们的基于faster rcnn的飞机检测模型，类别数量如上所讲述=1+1=2</span><br>model = get_object_detection_model(<span class="hljs-number">2</span>).to(device)<br><br><span class="hljs-built_in">print</span>(model)  <span class="hljs-comment"># 可查看model架构</span><br></code></pre></td></tr></table></figure><p><strong>torchvision模块</strong>是非常优秀的计算机视觉工具包，提供了很多盛行的网络架构，包括目标检测、实例分割！</p><p>源码地址：<a href="https://github.com/pytorch/vision/tree/master/torchvision/models">vision/torchvision/models at master · pytorch/vision (github.com)</a> 如有需要，可以好好研读！</p><p>对该模块的目录做一个小总结：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># /detection</span><br>anchor_utils(AnchorGenerator等)、generalized_rcnn、faster_rcnn、mask_rcnn、keypoint_rcnn、retinanet、ssd、(还有诸如roi_heads、rpn等偏功能化的模块)<br><span class="hljs-comment"># /quantization</span><br><span class="hljs-comment"># /segmentation</span><br><span class="hljs-comment"># /video</span><br><br><span class="hljs-comment"># 分类：</span><br>alexnet、densenet、googlenet、inception、mnasnet、mobilenet、resnet、vgg、shufflenet、squeezenet<br></code></pre></td></tr></table></figure><h3 id="六、训练与验证"><a href="#六、训练与验证" class="headerlink" title="六、训练与验证"></a>六、训练与验证</h3><p>1.训练数据集及相关计算函数的准备</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 这个Averager用于统计训练过程中的loss，便于打印</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Averager</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.current_total = <span class="hljs-number">0.0</span><br>        self.iterations = <span class="hljs-number">0.0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send</span>(<span class="hljs-params">self, value</span>):</span><br>        self.current_total += value<br>        self.iterations += <span class="hljs-number">1</span><br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">value</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> self.iterations == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> * self.current_total / self.iterations<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reset</span>(<span class="hljs-params">self</span>):</span><br>        self.current_total = <span class="hljs-number">0.0</span><br>        self.iterations = <span class="hljs-number">0.0</span><br></code></pre></td></tr></table></figure><p>对<code>@property</code>的理解，可以参考：<a href="https://zhuanlan.zhihu.com/p/64487092">python @property的介绍与使用 - 知乎 (zhihu.com)</a></p><p>简单理解：添加了<code>@property</code>的函数，应作为类属性来使用，即不再作为函数使用；同时该属性具备私有性，用户无法修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># collate_fn函数用于将一个batch的数据转换为tuple格式</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">collate_fn</span>(<span class="hljs-params">batch</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">zip</span>(*batch))<br><span class="hljs-comment"># 使用上面的AirplaneDetDataset来定义训练和验证的数据类</span><br>train_dataset = AirplaneDetDataset(<span class="hljs-string">&#x27;temp/mini_airplane&#x27;</span>, <span class="hljs-string">&#x27;train.json&#x27;</span>)<br>valid_dataset = AirplaneDetDataset(<span class="hljs-string">&#x27;temp/mini_airplane&#x27;</span>, <span class="hljs-string">&#x27;val.json&#x27;</span>)<br><span class="hljs-comment"># 定义训练data_loader</span><br>train_data_loader = DataLoader(<br>    train_dataset,<br>    batch_size=<span class="hljs-number">1</span>,<br>    shuffle=<span class="hljs-literal">False</span>,<br>    num_workers=<span class="hljs-number">0</span>,<br>    collate_fn=collate_fn<br>)<br><span class="hljs-comment"># 定义验证data_loader</span><br>valid_data_loader = DataLoader(<br>    valid_dataset,<br>    batch_size=<span class="hljs-number">1</span>,<br>    shuffle=<span class="hljs-literal">False</span>,<br>    num_workers=<span class="hljs-number">0</span>,<br>    collate_fn=collate_fn<br>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">params = [p <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> model.parameters() <span class="hljs-keyword">if</span> p.requires_grad]<br><span class="hljs-comment"># 建立sgd 优化器</span><br>optimizer = torch.optim.SGD(params, lr=<span class="hljs-number">0.0025</span>, momentum=<span class="hljs-number">0.9</span>, weight_decay=<span class="hljs-number">0.0005</span>)<br>lr_scheduler = <span class="hljs-literal">None</span><br><span class="hljs-comment"># 一共训练8个epoch</span><br>num_epochs = <span class="hljs-number">1</span> <span class="hljs-comment">#8</span><br></code></pre></td></tr></table></figure><p>2.训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># resnet50模型过大，内存不足</span><br>loss_hist = Averager()<br>itr = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 按照每一个epoch循环训练</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>    loss_hist.reset()<br>    <span class="hljs-comment"># 从data loader 中采样每个batch数据用于训练</span><br>    <span class="hljs-keyword">for</span> images, targets, _ <span class="hljs-keyword">in</span> train_data_loader:<br>        <br>        <span class="hljs-comment"># 将image 和 label 挪到GPU中</span><br>        images = <span class="hljs-built_in">list</span>(image.to(device) <span class="hljs-keyword">for</span> image <span class="hljs-keyword">in</span> images)<br>        targets = [&#123;k: v.to(device) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> t.items()&#125; <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> targets]<br>        <br>        <span class="hljs-comment"># 数据进入模型并反向传播得到loss</span><br>        loss_dict = model(images, targets)<br><br>        losses = <span class="hljs-built_in">sum</span>(loss <span class="hljs-keyword">for</span> loss <span class="hljs-keyword">in</span> loss_dict.values())<br>        loss_value = losses.item()<br><br>        loss_hist.send(loss_value)<br><br>        <span class="hljs-comment"># 更新模型参数</span><br>        optimizer.zero_grad()<br>        losses.backward()<br>        optimizer.step()<br><br>        <span class="hljs-keyword">if</span> itr % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Iteration #<span class="hljs-subst">&#123;itr&#125;</span> loss: <span class="hljs-subst">&#123;loss_value&#125;</span>&quot;</span>)<br><br>        itr += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> itr&gt;<span class="hljs-number">10</span>:<span class="hljs-keyword">break</span>;<br>    <br>    <span class="hljs-comment"># update the learning rate</span><br>    <span class="hljs-keyword">if</span> lr_scheduler <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        lr_scheduler.step()<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Epoch #<span class="hljs-subst">&#123;epoch&#125;</span> loss: <span class="hljs-subst">&#123;loss_hist.value&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>3.验证阶段：</p><p>1）取训练集图片，验证bbox是否准确：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 循环load训练集的数据</span><br>itr = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> images, _, imgname <span class="hljs-keyword">in</span> <span class="hljs-built_in">iter</span>(train_data_loader):<br>    images = <span class="hljs-built_in">list</span>(img.to(device) <span class="hljs-keyword">for</span> img <span class="hljs-keyword">in</span> images)<br>    sample = images[<span class="hljs-number">0</span>].permute(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>).cpu().numpy()<br>    model.<span class="hljs-built_in">eval</span>()<br>    cpu_device = torch.device(<span class="hljs-string">&quot;cpu&quot;</span>)<br>    <span class="hljs-comment"># 将图片送入网络infer得到预测结果</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        outputs = model(images)<br>        outputs = [&#123;k: v.to(cpu_device) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> t.items()&#125; <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> outputs]<br><br>    <span class="hljs-comment"># 从预测结果中解析出需要的bbox 和score内容</span><br>    boxes = outputs[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;boxes&#x27;</span>].data.cpu().numpy()<br>    scores = outputs[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;scores&#x27;</span>].data.cpu().numpy()<br>    <span class="hljs-comment"># 保留score大于0.5的预测框</span><br>    boxes = boxes[scores &gt;= <span class="hljs-number">0.5</span>].astype(np.int32)<br>    <span class="hljs-comment"># 在图上绘制所有预测框</span><br>    <span class="hljs-keyword">for</span> box <span class="hljs-keyword">in</span> boxes:<br>        cv2.rectangle(np.ascontiguousarray(sample),<br>                      (<span class="hljs-built_in">int</span>(box[<span class="hljs-number">0</span>]), <span class="hljs-built_in">int</span>(box[<span class="hljs-number">1</span>])),<br>                      (<span class="hljs-built_in">int</span>(box[<span class="hljs-number">2</span>]), <span class="hljs-built_in">int</span>(box[<span class="hljs-number">3</span>])),<br>                      (<span class="hljs-number">220</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">3</span>)<br>    <span class="hljs-comment"># 保存结果图片</span><br><span class="hljs-comment">#     plt.savefig(&#x27;./results/train_vis/&#x27;+str(imgname))</span><br>    plt.imshow(sample)<br>    plt.show()<br>    itr+=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> itr&gt;<span class="hljs-number">3</span>:<br>        <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><p>2）在验证集上测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">itr = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> images, _, imgname <span class="hljs-keyword">in</span> <span class="hljs-built_in">iter</span>(valid_data_loader):<span class="hljs-comment"># 取验证集数据</span><br>    images = <span class="hljs-built_in">list</span>(img.to(device) <span class="hljs-keyword">for</span> img <span class="hljs-keyword">in</span> images)<br>    sample = images[<span class="hljs-number">0</span>].permute(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>).cpu().numpy()<br>    cpu_device = torch.device(<span class="hljs-string">&quot;cpu&quot;</span>)<br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        outputs = model(images)<br>        outputs = [&#123;k: v.to(cpu_device) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> t.items()&#125; <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> outputs]<br><span class="hljs-comment">#     fig, ax = plt.subplots(1, 1, figsize=(16, 8))</span><br>    boxes = outputs[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;boxes&#x27;</span>].data.cpu().numpy()<br>    scores = outputs[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;scores&#x27;</span>].data.cpu().numpy()<br><br>    boxes = boxes[scores &gt;= <span class="hljs-number">0.5</span>].astype(np.int32)<br>    <span class="hljs-keyword">for</span> box <span class="hljs-keyword">in</span> boxes:<br>        cv2.rectangle(np.ascontiguousarray(sample),<br>                      (<span class="hljs-built_in">int</span>(box[<span class="hljs-number">0</span>]), <span class="hljs-built_in">int</span>(box[<span class="hljs-number">1</span>])),<br>                      (<span class="hljs-built_in">int</span>(box[<span class="hljs-number">2</span>]), <span class="hljs-built_in">int</span>(box[<span class="hljs-number">3</span>])),<br>                      (<span class="hljs-number">220</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">3</span>)<br>    <br>    plt.imshow(sample)<br>    plt.savefig(<span class="hljs-string">&#x27;./temp/&#x27;</span>+<span class="hljs-built_in">str</span>(imgname[<span class="hljs-number">0</span>]))<br>    plt.show()<br>    itr += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> itr&gt;<span class="hljs-number">3</span>:<br>        <span class="hljs-keyword">break</span>;<br></code></pre></td></tr></table></figure><h3 id="七、检测结果的mAP计算"><a href="#七、检测结果的mAP计算" class="headerlink" title="七、检测结果的mAP计算"></a>七、检测结果的mAP计算</h3><p>一般计算mAP采用<strong>COCO的官方工具</strong>，所以我们需要做的是<strong>将我们的预测结果保存为COCO标准格式</strong>，然后和COCO格式的label文件一起来求出mAP值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 首先预测每张验证集的图片，将每张图片的结果保存在字典imgname2bboxes中</span><br>imgname2bboxes = <span class="hljs-built_in">dict</span>()<br><span class="hljs-keyword">for</span> images, _, imgname <span class="hljs-keyword">in</span> <span class="hljs-built_in">iter</span>(valid_data_loader):<br>    imgname = imgname[<span class="hljs-number">0</span>]<br>    imgname2bboxes[imgname] = []<br>    images = <span class="hljs-built_in">list</span>(img.to(device) <span class="hljs-keyword">for</span> img <span class="hljs-keyword">in</span> images)<br>    sample = images[<span class="hljs-number">0</span>].permute(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>).cpu().numpy()<br>    cpu_device = torch.device(<span class="hljs-string">&quot;cpu&quot;</span>)<br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        outputs = model(images)<br>        outputs = [&#123;k: v.to(cpu_device) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> t.items()&#125; <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> outputs]<br>    boxes = outputs[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;boxes&#x27;</span>].data.cpu().numpy()<br>    scores = outputs[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;scores&#x27;</span>].data.cpu().numpy()<br><br>    boxes = boxes[scores &gt;= <span class="hljs-number">0.05</span>].astype(np.int32)<br>    scores = scores[scores &gt;= <span class="hljs-number">0.05</span>]<br>    <span class="hljs-keyword">for</span> box, score <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(boxes, scores):<br>        imgname2bboxes[imgname].append([box[<span class="hljs-number">0</span>], box[<span class="hljs-number">1</span>], box[<span class="hljs-number">2</span>], box[<span class="hljs-number">3</span>], score])<br><br><span class="hljs-comment"># 将imgname2bboxes字典的内容转换为COCO标准格式并保存下来，用于之后的计算mAP</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;temp/mini_airplane/annotations/val.json&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    val_labels = json.load(f)<br>val_images = val_labels[<span class="hljs-string">&quot;images&quot;</span>]<br>imagename2id = <span class="hljs-built_in">dict</span>()<br><span class="hljs-keyword">for</span> img <span class="hljs-keyword">in</span> val_images:<br>    imagename2id[img[<span class="hljs-string">&quot;file_name&quot;</span>]] = img[<span class="hljs-string">&quot;id&quot;</span>]<br>val_annotations = []<br>anno_id = <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> imgname, bboxes <span class="hljs-keyword">in</span> imgname2bboxes.items():<br>    <span class="hljs-keyword">for</span> bbox <span class="hljs-keyword">in</span> bboxes:<br>        box = <span class="hljs-built_in">list</span>([<span class="hljs-built_in">int</span>(bbox[<span class="hljs-number">0</span>]), <span class="hljs-built_in">int</span>(bbox[<span class="hljs-number">1</span>]), <span class="hljs-built_in">int</span>(bbox[<span class="hljs-number">2</span>]) - <span class="hljs-built_in">int</span>(bbox[<span class="hljs-number">0</span>]) + <span class="hljs-number">1</span>, <span class="hljs-built_in">int</span>(bbox[<span class="hljs-number">3</span>]) - <span class="hljs-built_in">int</span>(bbox[<span class="hljs-number">1</span>]) + <span class="hljs-number">1</span>])<br>        score = <span class="hljs-built_in">float</span>(bbox[-<span class="hljs-number">1</span>])<br>        imgid = imagename2id[imgname]<br>        val_annotations.append(&#123;<br>            <span class="hljs-string">&quot;id&quot;</span>: anno_id,<br>            <span class="hljs-string">&quot;bbox&quot;</span>: box,<br>            <span class="hljs-string">&quot;score&quot;</span>: score,<br>            <span class="hljs-string">&quot;image_id&quot;</span>: imagename2id[imgname],<br>            <span class="hljs-string">&quot;category_id&quot;</span>: <span class="hljs-number">1</span><br>        &#125;)<br>        anno_id += <span class="hljs-number">1</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;results/val_results.json&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    json.dump(val_annotations, f, indent=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>求mAP：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">! python datasets/src/coco_eval.py results/val_results.json --ann datasets/mini_airplane/annotations/val.json<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Deep Learning-Objects Detection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch_Related（三）</title>
    <link href="/2021/08/15/Pytorch-Related%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2021/08/15/Pytorch-Related%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="项目二：目标检测算法中的anchor、NMS和FPN"><a href="#项目二：目标检测算法中的anchor、NMS和FPN" class="headerlink" title="项目二：目标检测算法中的anchor、NMS和FPN"></a>项目二：目标检测算法中的anchor、NMS和FPN</h2><span id="more"></span><h3 id="一、anchor"><a href="#一、anchor" class="headerlink" title="一、anchor"></a>一、anchor</h3><p>1.由预定义的大小scale和高宽比ratio生成的一组anchor box，选定好scale和ratio之后，通过滑动窗口的方式将这些anchor铺满整个图片，具体方式为对于目标图片（一般指经过conv后的feature map），图中的每个点都要对应一组anchor，即在feature map上逐点滑窗，以这些点为中心生成anchor box。</p><p>有了这些anchor box后，模型不是直接去回归坐标框位置，而是以anchor box为基准，回归GT框和anchor box之间的<strong>平移和缩放值</strong>。</p><p>2.参数：</p><p>base_size：基础大小</p><p>anchor_scale：在base_size的基础上，调整anchor的大小</p><p>anchor_ratio：用以生成各种长宽比例的长方形anchor</p><p>3.主要计算公式：</p><img src="/.com//blog\source\images\image-20210805165454366.png" alt="image-20210805165454366" style="zoom: 50%;"><p>4.代码</p><p>获取anchor box的实质，就是获取anchor box的四维坐标：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 定义anchor生成器类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AnchorGenerator</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, base_size, scales, ratios, ctr=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-comment"># base_size 是anchor的基本大小</span><br>        <span class="hljs-comment"># scales 是anchor缩放的比例，我们可以在基础大小上给定倍数来缩放anchor从而生成更多anchor</span><br>        <span class="hljs-comment"># ratios 指的是anchor的高宽变化比例</span><br>        <span class="hljs-comment"># ctr 为anchor中心点坐标，默认为None，通过anchor大小来自动计算中心点</span><br>        self.base_size = base_size<br>        self.scales = torch.Tensor(scales)<br>        self.ratios = torch.Tensor(ratios)<br>        self.ctr = ctr<br>        self.base_anchors = self.gen_base_anchors()<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">num_base_anchors</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.base_anchors.size(<span class="hljs-number">0</span>)<br> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gen_base_anchors</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 用于生成基础anchor，这些基础anchor将会滑动窗口形式铺满图片</span><br>        <span class="hljs-comment"># 基础anchor的宽和高</span><br>        w = self.base_size<br>        h = self.base_size<br>        <span class="hljs-comment"># 计算基础anchor的中心坐标（左上角为0，0点）</span><br>        <span class="hljs-keyword">if</span> self.ctr <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            x_ctr = <span class="hljs-number">0.5</span> * (w - <span class="hljs-number">1</span>)<br>            y_ctr = <span class="hljs-number">0.5</span> * (h - <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">else</span>:<br>            x_ctr, y_ctr = self.ctr<br>        <span class="hljs-comment"># 计算高宽比例并将基础anchor乘上这一比例</span><br>        h_ratios = torch.sqrt(self.ratios)<br>        w_ratios = <span class="hljs-number">1</span> / h_ratios<br><br>        ws = (w * w_ratios[:, <span class="hljs-literal">None</span>] * self.scales[<span class="hljs-literal">None</span>, :]).view(-<span class="hljs-number">1</span>)<br>        hs = (h * h_ratios[:, <span class="hljs-literal">None</span>] * self.scales[<span class="hljs-literal">None</span>, :]).view(-<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 使用之前计算的anchor中心坐标和最终的高度和宽度计算得到最终的base anchor, 为了保证坐标是整数，最后使用round取整</span><br>        base_anchors = torch.stack(<br>            [<br>                x_ctr - <span class="hljs-number">0.5</span> * (ws - <span class="hljs-number">1</span>), y_ctr - <span class="hljs-number">0.5</span> * (hs - <span class="hljs-number">1</span>),<br>                x_ctr + <span class="hljs-number">0.5</span> * (ws - <span class="hljs-number">1</span>), y_ctr + <span class="hljs-number">0.5</span> * (hs - <span class="hljs-number">1</span>)<br>            ],<br>            dim=-<span class="hljs-number">1</span>).<span class="hljs-built_in">round</span>()<br><br>        <span class="hljs-keyword">return</span> base_anchors<br>    <br>    <span class="hljs-comment"># 猜测：_meshgird作用应该是搭配后面的grid_anchors完成“滑动窗口”，逐点产生anchor组</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_meshgrid</span>(<span class="hljs-params">self, x, y, row_major=<span class="hljs-literal">True</span></span>):</span><br>        xx = x.repeat(<span class="hljs-built_in">len</span>(y))<br>        yy = y.view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>).repeat(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(x)).view(-<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> row_major:<br>            <span class="hljs-keyword">return</span> xx, yy<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> yy, xx<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grid_anchors</span>(<span class="hljs-params">self, featmap_size, device=<span class="hljs-string">&#x27;cpu&#x27;</span></span>):</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;device: cuda or cpu&#x27;&#x27;&#x27;</span><br>        <span class="hljs-comment"># 首先生成base anchor </span><br>        base_anchors = self.base_anchors.to(device)<br>        <span class="hljs-comment"># 然后使用当前anchor要覆盖图片的大小来给定所有需要滑窗铺设anchor的点的位置（其实就是这个图的所有点）</span><br>        feat_h, feat_w = featmap_size<br>        shift_x = torch.arange(<span class="hljs-number">0</span>, feat_w, device=device)<br>        shift_y = torch.arange(<span class="hljs-number">0</span>, feat_h, device=device)<br>        <span class="hljs-comment"># 生成滑动窗口的x和y坐标</span><br>        shift_xx, shift_yy = self._meshgrid(shift_x, shift_y)<br>        shifts = torch.stack([shift_xx, shift_yy, shift_xx, shift_yy], dim=-<span class="hljs-number">1</span>)<br>        shifts = shifts.type_as(base_anchors)<br>        <span class="hljs-comment"># 将based anchor 沿着x，y坐标平移滑窗，将anchor铺满图片</span><br>        all_anchors = base_anchors[<span class="hljs-literal">None</span>, :, :] + shifts[:, <span class="hljs-literal">None</span>, :]<br>        all_anchors = all_anchors.view(-<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)<br>        <span class="hljs-keyword">return</span> all_anchors<br></code></pre></td></tr></table></figure><p>调用方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># base大小为9，缩放倍数为1，ratio为[0.5,1,2.0]</span><br>ag = AnchorGenerator(<span class="hljs-number">9</span>, [<span class="hljs-number">1.</span>], [<span class="hljs-number">0.5</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">2.0</span>])<br>all_anchors = ag.grid_anchors((<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))   <span class="hljs-comment"># 假定feature map大小为1*1，测试看看结果</span><br><span class="hljs-built_in">print</span>(all_anchors)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor([[-<span class="hljs-number">2.</span>,  <span class="hljs-number">1.</span>, <span class="hljs-number">10.</span>,  <span class="hljs-number">7.</span>],<br>        [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">8.</span>,  <span class="hljs-number">8.</span>],<br>        [ <span class="hljs-number">1.</span>, -<span class="hljs-number">2.</span>,  <span class="hljs-number">7.</span>, <span class="hljs-number">10.</span>]])<br></code></pre></td></tr></table></figure><h3 id="二、anchor-box与GT-box匹配"><a href="#二、anchor-box与GT-box匹配" class="headerlink" title="二、anchor box与GT box匹配"></a>二、anchor box与GT box匹配</h3><p>根据IoU 直接为GT box分配anchor box</p><p>上一步生成了非常多的预设anchor，接下来需要给每个GT bbox 匹配一个对应的anchor，这样这个GT 框就是以这个anchor为基准来检测。<br>常用的匹配策略叫做max iou assign，也就是依据anchor box和gt box之间的IoU值来匹配，每个GT 选择与其IoU值大于一定阈值中最大的那个anchor来匹配，<br>一般分为以下几个步骤：</p><p>（1）计算所有anchor和gt框的iou值<br>（2）如果一个<strong>anchor和所有gt的iou值都小于阈值neg_iou_thr</strong>，也就是说这个anchor没有覆盖到任何的gt框，那么就将这个anchor标记为负样本（neg_iou_thr一般取0.3）<br>（3）对于每一个anchor，先找到<strong>与它iou最大的gt框</strong>，如果他们的<strong>iou大于pos_iou_thr阈值</strong>（一般取0.7或者0.5），那么就将这个gt和这个anchor匹配<br>（4）对于所有的gt框，将它与和<strong>它iou值最大的anchor匹配</strong>（这一步是为了解决上一步中可能存在部分gt框没有anchor匹配的问题）</p><p>这样每个gt框都匹配上了一个或者多个anchor</p><p><strong>1.计算两组bbox之间的overlap或iou值</strong></p><p>先上代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bbox_overlaps</span>(<span class="hljs-params">bboxes1, bboxes2, mode=<span class="hljs-string">&#x27;iou&#x27;</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;计算输入的两组bboxes之间的overlap值.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    rows = bboxes1.size(<span class="hljs-number">0</span>) <span class="hljs-comment"># bboxes1中box的个数</span><br>    cols = bboxes2.size(<span class="hljs-number">0</span>) <span class="hljs-comment"># bboxes2中box的个数</span><br><br>    <span class="hljs-keyword">if</span> rows * cols == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> bboxes1.new(rows, cols)<br><br>    lt = torch.<span class="hljs-built_in">max</span>(bboxes1[:, <span class="hljs-literal">None</span>, :<span class="hljs-number">2</span>], bboxes2[:, :<span class="hljs-number">2</span>])  <span class="hljs-comment"># [rows, cols, 2]</span><br>    rb = torch.<span class="hljs-built_in">min</span>(bboxes1[:, <span class="hljs-literal">None</span>, <span class="hljs-number">2</span>:], bboxes2[:, <span class="hljs-number">2</span>:])  <span class="hljs-comment"># [rows, cols, 2]</span><br><br>    wh = (rb - lt + <span class="hljs-number">1</span>).clamp(<span class="hljs-built_in">min</span>=<span class="hljs-number">0</span>)  <span class="hljs-comment"># [rows, cols, 2]</span><br>    overlap = wh[:, :, <span class="hljs-number">0</span>] * wh[:, :, <span class="hljs-number">1</span>]<br>    area1 = (bboxes1[:, <span class="hljs-number">2</span>] - bboxes1[:, <span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) * (bboxes1[:, <span class="hljs-number">3</span>] - bboxes1[:, <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)<br><br>    <span class="hljs-keyword">if</span> mode == <span class="hljs-string">&#x27;iou&#x27;</span>:<br>        area2 = (bboxes2[:, <span class="hljs-number">2</span>] - bboxes2[:, <span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) * (bboxes2[:, <span class="hljs-number">3</span>] - bboxes2[:, <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>)<br>        ious = overlap / (area1[:, <span class="hljs-literal">None</span>] + area2 - overlap)<br>    <span class="hljs-keyword">else</span>:<br>        ious = overlap / (area1[:, <span class="hljs-literal">None</span>])<br><br>    <span class="hljs-keyword">return</span> ious<br></code></pre></td></tr></table></figure><p>使用举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># bbox的顺序为[xmin,ymin,xmax,ymax]</span><br>bboxes1 = torch.FloatTensor([<br>            [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>],<br>            [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>],<br>            [<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">38</span>, <span class="hljs-number">42</span>],<br>            ])<br>bboxes2 = torch.FloatTensor([<br>            [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>],<br>            [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">19</span>],<br>            [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>],<br>            ])<br>ious = bbox_overlaps(bboxes1, bboxes2)<br><span class="hljs-built_in">print</span>(ious)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor([[<span class="hljs-number">0.5238</span>, <span class="hljs-number">0.0500</span>, <span class="hljs-number">0.0041</span>],<br>        [<span class="hljs-number">0.0323</span>, <span class="hljs-number">0.0452</span>, <span class="hljs-number">1.0000</span>],<br>        [<span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0000</span>, <span class="hljs-number">0.0000</span>]])<br></code></pre></td></tr></table></figure><p>（1）<code>torch.max()</code>有多个版本！！！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">input</span>,dim,keepdim=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># dim=0列取最大，dim=1行取最大</span><br><br>torch.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">input</span>,other,out=<span class="hljs-literal">None</span>)  <span class="hljs-comment"># input和other都是tensor，实现逐元素比较两个tensor，输出最大值</span><br>  <span class="hljs-comment"># 两个tensor维度不一定一致，但必须满足“可广播”</span><br>      <span class="hljs-comment"># 输出的维度就是广播后的维度</span><br></code></pre></td></tr></table></figure><p>（2）切片中的<code>None</code>:</p><p>经常见<code>a[:, None, :4]</code>的语句，切片中的None实际上是numpy中newaxis的别名，也即<strong>增加维度</strong>！</p><p>实验结果：</p><p><img src="/.com//blog\source\images\image-20210806091544126.png" alt="image-20210806091544126"></p><p>也即：None增加了维度，结果为1</p><p>（3）pytorch中的广播机制：</p><p>如果满足以下规则，则两个张量是“可广播的”：<br>１、每个张量具有至少一个维度。<br>２、从尾随尺寸开始迭代尺寸时，尺寸<strong>要么相等</strong>，<strong>要么其中之一为1</strong>，<strong>或者不存在其中之一</strong>。（从<strong>尾部开始比较</strong>！）</p><p>符合广播条件的，按照下面方式广播：</p><p>１、如果x和y的维度不相同，<strong>用１来扩张维度少的那个</strong>，使两个张量维度一致。<br>２、对于每个维度，<strong>结果维度是x,y对应维度的最大值</strong>。</p><p>举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>x=torch.empty(<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>y=torch.empty(  <span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>(x+y).size()<br>torch.Size([<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>])<br></code></pre></td></tr></table></figure><p>再举一个：</p><img src="/.com//blog\source\images\image-20210806091954070.png" alt="image-20210806091954070" style="zoom: 50%;"><p>(4) 计算iou代码的整体思路：</p><img src="/.com//blog\source\images\image-20210806104239858.png" alt="image-20210806104239858" style="zoom: 50%;"><p><strong>2.anchor box与GT box匹配</strong></p><p>先上代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># anchor与GT匹配的类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxIoUAssigner</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    每个候选框会被打上一个标签：`-1`, `0`, `1`</span><br><span class="hljs-string"></span><br><span class="hljs-string">    - -1: 忽略</span><br><span class="hljs-string">    - 0: 负样本，表示这个anchor没有和任何gt box匹配成功，代表背景</span><br><span class="hljs-string">    - index: 正样本，值为所匹配的gt的label，从1开始</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        pos_iou_thr (float): 正样本iou阈值.</span><br><span class="hljs-string">        neg_iou_thr (float or tuple): 负样本iou阈值.</span><br><span class="hljs-string">        min_pos_iou (float): 最小正样本iou阈值，用于当GT没有anchor匹配时二次降低标准寻找合适的anchor，保证每个GT都有anchor匹配上</span><br><span class="hljs-string">        gt_max_assign_all (bool): 如果出现一个GT与多个anchor的iou相同且均为最大值，是否将这些anchor都和该GT匹配</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,</span></span><br><span class="hljs-function"><span class="hljs-params">                 pos_iou_thr,</span></span><br><span class="hljs-function"><span class="hljs-params">                 neg_iou_thr,</span></span><br><span class="hljs-function"><span class="hljs-params">                 min_pos_iou=<span class="hljs-number">.0</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">                 gt_max_assign_all=<span class="hljs-literal">True</span></span>):</span><br>        self.pos_iou_thr = pos_iou_thr<br>        self.neg_iou_thr = neg_iou_thr<br>        self.min_pos_iou = min_pos_iou<br>        self.gt_max_assign_all = gt_max_assign_all<br>        <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">assign</span>(<span class="hljs-params">self, bboxes, gt_bboxes, gt_labels=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;匹配gt框和anchor.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        匹配步骤按照如下进行：</span><br><span class="hljs-string"></span><br><span class="hljs-string">        1. 将所有的anchor都初始化为 -1</span><br><span class="hljs-string">        2. 如果anchor与所有GT的iou值 all gts &lt; neg_iou_thr， 就说明这个anchor不能喝任何GT匹配，标记为 0，负样本</span><br><span class="hljs-string">        3. 对每个anchor，如果与它与对应最大iou值的gt框的iou值大于pos_iou_thr,就把这个anchor匹配到这个框上，标记为对应的gt的lable，</span><br><span class="hljs-string">           属于正样本</span><br><span class="hljs-string">        4. 对于每个gt，将与其iou最大的所有anchor均与它匹配</span><br><span class="hljs-string"></span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br>        bboxes = bboxes[:, :<span class="hljs-number">4</span>]<br>        overlaps = bbox_overlaps(gt_bboxes, bboxes)<br><br>        assign_result = self.assign_wrt_overlaps(overlaps, gt_labels)<br>        <br>        <span class="hljs-keyword">return</span> assign_result<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">assign_wrt_overlaps</span>(<span class="hljs-params">self, overlaps, gt_labels=<span class="hljs-literal">None</span></span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;Assign w.r.t. the overlaps of bboxes with gts.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Args:</span><br><span class="hljs-string">            overlaps (Tensor): gt和anchor之间的overlaps</span><br><span class="hljs-string">            gt_labels (Tensor, optional): gtbox的类别label.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Returns:</span><br><span class="hljs-string">            :obj:`AssignResult`: The assign result.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        num_gts, num_bboxes = overlaps.size(<span class="hljs-number">0</span>), overlaps.size(<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 计算iou函数返回的overlaps，第一维是GT box个数，第二维是anchor box个数</span><br><span class="hljs-comment"># 这里分别把它们取出来        </span><br>        <br><span class="hljs-comment"># 1. 将所有的anchor都初始化为 -1</span><br>        assigned_gt_inds = overlaps.new_full((num_bboxes, ),<br>                                             -<span class="hljs-number">1</span>,<br>                                             dtype=torch.long)<br><br>        <span class="hljs-comment"># 对于每个anchor，找到与其iou最大的gt</span><br>        max_overlaps, argmax_overlaps = overlaps.<span class="hljs-built_in">max</span>(dim=<span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 对于每个gt，找到与其iou最大的anchor</span><br>        gt_max_overlaps, gt_argmax_overlaps = overlaps.<span class="hljs-built_in">max</span>(dim=<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 2. 如果anchor与所有GT的iou值 all gts &lt; neg_iou_thr， 就说明这个anchor不能喝任何GT匹配，标记为 0，负样本</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(self.neg_iou_thr, <span class="hljs-built_in">float</span>):<br>            assigned_gt_inds[(max_overlaps &gt;= <span class="hljs-number">0</span>)<br>                             &amp; (max_overlaps &lt; self.neg_iou_thr)] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(self.neg_iou_thr, <span class="hljs-built_in">tuple</span>):<br>            <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(self.neg_iou_thr) == <span class="hljs-number">2</span><br>            assigned_gt_inds[(max_overlaps &gt;= self.neg_iou_thr[<span class="hljs-number">0</span>])<br>                             &amp; (max_overlaps &lt; self.neg_iou_thr[<span class="hljs-number">1</span>])] = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 3. 对每个anchor，如果与它与对应最大iou值的gt框的iou值大于pos_iou_thr,就把这个anchor匹配到这个框上，标记为对应的gt的lable，</span><br>   <span class="hljs-comment"># 属于正样本</span><br>        pos_inds = max_overlaps &gt;= self.pos_iou_thr<br>        assigned_gt_inds[pos_inds] = argmax_overlaps[pos_inds] + <span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># 4. 对于每个gt，将与其iou最大的所有anchor均与它匹配</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_gts):<br>            <span class="hljs-keyword">if</span> gt_max_overlaps[i] &gt;= self.min_pos_iou:<br>                <span class="hljs-keyword">if</span> self.gt_max_assign_all:<br>                    max_iou_inds = overlaps[i, :] == gt_max_overlaps[i]<br>                    assigned_gt_inds[max_iou_inds] = i + <span class="hljs-number">1</span><br>                <span class="hljs-keyword">else</span>:<br>                    assigned_gt_inds[gt_argmax_overlaps[i]] = i + <span class="hljs-number">1</span><br>                <br>                <br>        <span class="hljs-keyword">if</span> gt_labels <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            assigned_labels = assigned_gt_inds.new_zeros((num_bboxes, ))<br>            pos_inds = torch.nonzero(assigned_gt_inds &gt; <span class="hljs-number">0</span>).squeeze()<br>            <span class="hljs-keyword">if</span> pos_inds.numel() &gt; <span class="hljs-number">0</span>:<br>                assigned_labels[pos_inds] = gt_labels[<br>                    assigned_gt_inds[pos_inds] - <span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">else</span>:<br>            assigned_labels = <span class="hljs-literal">None</span><br>        <span class="hljs-comment"># 返回值分别为： gt的数量，anchor匹配到gt的序号， anchor和所匹配gt的iou， anchor匹配到的label值</span><br>        <span class="hljs-keyword">return</span> num_gts, assigned_gt_inds, max_overlaps, assigned_labels<br><br></code></pre></td></tr></table></figure><p>匹配举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">assigner = MaxIoUAssigner(<br>        pos_iou_thr=<span class="hljs-number">0.5</span>,<br>        neg_iou_thr=<span class="hljs-number">0.5</span>,<br>    )<br>anchors = torch.FloatTensor([<br>        [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>],<br>        [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>],<br>        [<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>],<br>        [<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, <span class="hljs-number">38</span>, <span class="hljs-number">42</span>],<br>    ])<br>gt_bboxes = torch.FloatTensor([<br>        [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">9</span>],<br>        [<span class="hljs-number">0</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">19</span>],<br>    ])<br>gt_labels = torch.LongTensor([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>assign_result = assigner.assign(anchors, gt_bboxes, gt_labels=gt_labels)<br>num_gts, assigned_gt_inds, max_overlaps, assigned_labels = assign_result<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;gt的数量： &quot;</span>, num_gts)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;anchor匹配到第几个gt： &quot;</span>, assigned_gt_inds)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;anchor匹配到gt的序号： &quot;</span>, max_overlaps)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;anchor匹配到的label值： &quot;</span>, assigned_labels)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">gt的数量：  <span class="hljs-number">2</span><br>anchor匹配到第几个gt：  tensor([<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>])<br>anchor匹配到gt的序号：  tensor([<span class="hljs-number">0.9091</span>, <span class="hljs-number">0.0452</span>, <span class="hljs-number">0.1846</span>, <span class="hljs-number">0.0000</span>])<br>anchor匹配到的label值：  tensor([<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h3 id="三、基于anchor-box的坐标编码和解码"><a href="#三、基于anchor-box的坐标编码和解码" class="headerlink" title="三、基于anchor box的坐标编码和解码"></a>三、基于anchor box的坐标编码和解码</h3><p>前面说过，anchor based的方法，基本都是对“GT和anchor之间的平移量、缩放量”进行回归修正，因此上一步完成GT和anchor的匹配之后，就要求解GT相对于anchor的平移、缩放量了，这一步又称为坐标编码。</p><p>定义：<br>$p_x$ 为achor的x轴中心点，$p_y$ 为anchor的y轴中心点, $p_w$ 为anchor的宽度，$p_h$ 为anchor的高<br>$g_x$ 为gt box的x轴中心点，$g_y$ 为gt box的y轴中心点, $g_w$ 为gt box的宽度，$g_h$ 为gt box的高<br>编码过程：<br><img src="/.com//blog\source\images\image-20210806152341948.png" alt="image-20210806152341948"><br>其中$d_x$和$d_y$表示平移，$d_w$和$d_h$表示缩放</p><p>实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bbox2delta</span>(<span class="hljs-params">proposals, gt, means=[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], stds=[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]</span>):</span><br>    <span class="hljs-keyword">assert</span> proposals.size() == gt.size()<br><br>    proposals = proposals.<span class="hljs-built_in">float</span>()<br>    gt = gt.<span class="hljs-built_in">float</span>()<br>    <span class="hljs-comment"># 求出 anchor的中心点和高宽</span><br>    px = (proposals[..., <span class="hljs-number">0</span>] + proposals[..., <span class="hljs-number">2</span>]) * <span class="hljs-number">0.5</span><br>    py = (proposals[..., <span class="hljs-number">1</span>] + proposals[..., <span class="hljs-number">3</span>]) * <span class="hljs-number">0.5</span><br>    pw = proposals[..., <span class="hljs-number">2</span>] - proposals[..., <span class="hljs-number">0</span>] + <span class="hljs-number">1.0</span><br>    ph = proposals[..., <span class="hljs-number">3</span>] - proposals[..., <span class="hljs-number">1</span>] + <span class="hljs-number">1.0</span><br>    <span class="hljs-comment"># 求出gt的中心点和高宽</span><br>    gx = (gt[..., <span class="hljs-number">0</span>] + gt[..., <span class="hljs-number">2</span>]) * <span class="hljs-number">0.5</span><br>    gy = (gt[..., <span class="hljs-number">1</span>] + gt[..., <span class="hljs-number">3</span>]) * <span class="hljs-number">0.5</span><br>    gw = gt[..., <span class="hljs-number">2</span>] - gt[..., <span class="hljs-number">0</span>] + <span class="hljs-number">1.0</span><br>    gh = gt[..., <span class="hljs-number">3</span>] - gt[..., <span class="hljs-number">1</span>] + <span class="hljs-number">1.0</span><br>    <span class="hljs-comment"># 编码</span><br>    dx = (gx - px) / pw<br>    dy = (gy - py) / ph<br>    dw = torch.log(gw / pw)<br>    dh = torch.log(gh / ph)<br>    deltas = torch.stack([dx, dy, dw, dh], dim=-<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 用均值标准差来归一化</span><br>    means = deltas.new_tensor(means).unsqueeze(<span class="hljs-number">0</span>)<br>    stds = deltas.new_tensor(stds).unsqueeze(<span class="hljs-number">0</span>)<br>    deltas = deltas.sub_(means).div_(stds)<br><br>    <span class="hljs-keyword">return</span> deltas<br></code></pre></td></tr></table></figure><p>使用举例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">anchors = torch.Tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],<br>                      [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],<br>                      [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],<br>                      [ <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>]])<br>gt_bbox = torch.Tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">1.0000</span>,  <span class="hljs-number">1.0000</span>],<br>                        [ <span class="hljs-number">0.2817</span>,  <span class="hljs-number">0.2817</span>,  <span class="hljs-number">4.7183</span>,  <span class="hljs-number">4.7183</span>],<br>                        [-<span class="hljs-number">6.3891</span>,  <span class="hljs-number">0.6321</span>,  <span class="hljs-number">7.3891</span>,  <span class="hljs-number">0.3679</span>],<br>                        [ <span class="hljs-number">5.8967</span>,  <span class="hljs-number">2.9251</span>,  <span class="hljs-number">5.5033</span>,  <span class="hljs-number">3.2749</span>]])<br>deltas = bbox2delta(anchors, gt_bbox)<br><span class="hljs-built_in">print</span>(deltas)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.0000</span>],<br>        [ <span class="hljs-number">1.0000</span>,  <span class="hljs-number">1.0000</span>,  <span class="hljs-number">1.0000</span>,  <span class="hljs-number">1.0000</span>],<br>        [ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">2.0000</span>, -<span class="hljs-number">0.9999</span>],<br>        [ <span class="hljs-number">0.7000</span>, -<span class="hljs-number">1.9000</span>, -<span class="hljs-number">0.4999</span>,  <span class="hljs-number">0.3000</span>]])<br></code></pre></td></tr></table></figure><p>2.经过上述编码，模型最终学习的结果就是编码的值，想要得到最终实际的坐标框，需要进行解码！</p><p>解码就是上述的逆过程：</p><p><img src="/.com//blog\source\images\image-20210806152649302.png" alt="image-20210806152649302"></p><p>最终（x1，y1）为预测框左上角坐标，（x2，y2）为预测框右下角坐标。</p><p>实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delta2bbox</span>(<span class="hljs-params">rois,</span></span><br><span class="hljs-function"><span class="hljs-params">               deltas,</span></span><br><span class="hljs-function"><span class="hljs-params">               means=[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>],</span></span><br><span class="hljs-function"><span class="hljs-params">               stds=[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>],</span></span><br><span class="hljs-function"><span class="hljs-params">               max_shape=<span class="hljs-literal">None</span>,</span></span><br><span class="hljs-function"><span class="hljs-params">               wh_ratio_clip=<span class="hljs-number">16</span> / <span class="hljs-number">1000</span></span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    对bbox进行解码，使用delta 从rois解码回bbox</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        rois (Tensor): anchor box或者proposal坐标</span><br><span class="hljs-string">        deltas (Tensor): 编码后的结果，即相对每个roi的平移和缩放量</span><br><span class="hljs-string">        means (list): delta 的均值，用于反标准化</span><br><span class="hljs-string">        stds (list): delta 的标准差，用于反标准化</span><br><span class="hljs-string">        max_shape (tuple[int, int]): 解码后bbox 的最大尺度</span><br><span class="hljs-string">        wh_ratio_clip (float): 解码后bbbox的最大高宽比</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Returns:</span><br><span class="hljs-string">        Tensor: 返回值为bbox的坐标，每一行是一个框，格式为 [tl_x, tl_y, br_x, br_y],即左上角点坐标和右下角点坐标</span><br><span class="hljs-string"></span><br><span class="hljs-string">    References:</span><br><span class="hljs-string">        .. [1] https://arxiv.org/abs/1311.2524</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    means = deltas.new_tensor(means).repeat(<span class="hljs-number">1</span>, deltas.size(<span class="hljs-number">1</span>) // <span class="hljs-number">4</span>)<br>    stds = deltas.new_tensor(stds).repeat(<span class="hljs-number">1</span>, deltas.size(<span class="hljs-number">1</span>) // <span class="hljs-number">4</span>)<br>    denorm_deltas = deltas * stds + means<br>    dx = denorm_deltas[:, <span class="hljs-number">0</span>::<span class="hljs-number">4</span>]<br>    dy = denorm_deltas[:, <span class="hljs-number">1</span>::<span class="hljs-number">4</span>]<br>    dw = denorm_deltas[:, <span class="hljs-number">2</span>::<span class="hljs-number">4</span>]<br>    dh = denorm_deltas[:, <span class="hljs-number">3</span>::<span class="hljs-number">4</span>]<br>    max_ratio = np.<span class="hljs-built_in">abs</span>(np.log(wh_ratio_clip))<br>    dw = dw.clamp(<span class="hljs-built_in">min</span>=-max_ratio, <span class="hljs-built_in">max</span>=max_ratio)<br>    dh = dh.clamp(<span class="hljs-built_in">min</span>=-max_ratio, <span class="hljs-built_in">max</span>=max_ratio)<br>    <span class="hljs-comment"># 计算每个 roi 的中心</span><br>    px = ((rois[:, <span class="hljs-number">0</span>] + rois[:, <span class="hljs-number">2</span>]) * <span class="hljs-number">0.5</span>).unsqueeze(<span class="hljs-number">1</span>).expand_as(dx)<br>    py = ((rois[:, <span class="hljs-number">1</span>] + rois[:, <span class="hljs-number">3</span>]) * <span class="hljs-number">0.5</span>).unsqueeze(<span class="hljs-number">1</span>).expand_as(dy)<br>    <span class="hljs-comment"># 计算高度和宽度</span><br>    pw = (rois[:, <span class="hljs-number">2</span>] - rois[:, <span class="hljs-number">0</span>] + <span class="hljs-number">1.0</span>).unsqueeze(<span class="hljs-number">1</span>).expand_as(dw)<br>    ph = (rois[:, <span class="hljs-number">3</span>] - rois[:, <span class="hljs-number">1</span>] + <span class="hljs-number">1.0</span>).unsqueeze(<span class="hljs-number">1</span>).expand_as(dh)<br>    <span class="hljs-comment"># 使用 exp 函数来缩放</span><br>    gw = pw * dw.exp()<br>    gh = ph * dh.exp()<br>    <span class="hljs-comment"># 使用 dx和 dy平移</span><br>    gx = torch.addcmul(px, <span class="hljs-number">1</span>, pw, dx)  <span class="hljs-comment"># gx = px + pw * dx</span><br>    gy = torch.addcmul(py, <span class="hljs-number">1</span>, ph, dy)  <span class="hljs-comment"># gy = py + ph * dy</span><br>    <span class="hljs-comment"># 转换为左上角和右下角坐标形式</span><br>    x1 = gx - gw * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span><br>    y1 = gy - gh * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span><br>    x2 = gx + gw * <span class="hljs-number">0.5</span> - <span class="hljs-number">0.5</span><br>    y2 = gy + gh * <span class="hljs-number">0.5</span> - <span class="hljs-number">0.5</span><br>    <span class="hljs-keyword">if</span> max_shape <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        x1 = x1.clamp(<span class="hljs-built_in">min</span>=<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>=max_shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>)<br>        y1 = y1.clamp(<span class="hljs-built_in">min</span>=<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>=max_shape[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>)<br>        x2 = x2.clamp(<span class="hljs-built_in">min</span>=<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>=max_shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>)<br>        y2 = y2.clamp(<span class="hljs-built_in">min</span>=<span class="hljs-number">0</span>, <span class="hljs-built_in">max</span>=max_shape[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>)<br>    bboxes = torch.stack([x1, y1, x2, y2], dim=-<span class="hljs-number">1</span>).view_as(deltas)<br>    <span class="hljs-keyword">return</span> bboxes<br></code></pre></td></tr></table></figure><p>使用举例：</p><p>将模型预测出来的deltas基于anchor解码成正常的bbox：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">anchor = torch.Tensor([[ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],<br>                      [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],<br>                      [ <span class="hljs-number">0.</span>,  <span class="hljs-number">0.</span>,  <span class="hljs-number">1.</span>,  <span class="hljs-number">1.</span>],<br>                      [ <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>,  <span class="hljs-number">5.</span>]])<br>deltas = torch.Tensor([[  <span class="hljs-number">0.</span>,   <span class="hljs-number">0.</span>,   <span class="hljs-number">0.</span>,   <span class="hljs-number">0.</span>],<br>                        [  <span class="hljs-number">1.</span>,   <span class="hljs-number">1.</span>,   <span class="hljs-number">1.</span>,   <span class="hljs-number">1.</span>],<br>                        [  <span class="hljs-number">0.</span>,   <span class="hljs-number">0.</span>,   <span class="hljs-number">2.</span>,  -<span class="hljs-number">1.</span>],<br>                        [ <span class="hljs-number">0.7</span>, -<span class="hljs-number">1.9</span>, -<span class="hljs-number">0.5</span>,  <span class="hljs-number">0.3</span>]])<br>bbox = delta2bbox(rois, deltas)<br><span class="hljs-built_in">print</span>(bbox)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">tensor([[ <span class="hljs-number">0.0000</span>,  <span class="hljs-number">0.0000</span>,  <span class="hljs-number">1.0000</span>,  <span class="hljs-number">1.0000</span>],<br>        [ <span class="hljs-number">0.2817</span>,  <span class="hljs-number">0.2817</span>,  <span class="hljs-number">4.7183</span>,  <span class="hljs-number">4.7183</span>],<br>        [-<span class="hljs-number">6.3891</span>,  <span class="hljs-number">0.6321</span>,  <span class="hljs-number">7.3891</span>,  <span class="hljs-number">0.3679</span>],<br>        [ <span class="hljs-number">5.8967</span>,  <span class="hljs-number">2.9251</span>,  <span class="hljs-number">5.5033</span>,  <span class="hljs-number">3.2749</span>]])<br></code></pre></td></tr></table></figure><p>至此，基于anchor的算法实现就介绍完毕，当然，这是比较底层的实现方法，目前有很多库可以直接调用faster-rcnn模型； 了解底层算法的好处：有助实现算法的优化，例如算法可有如下优化思路：</p><p>1.若目标检测的对象类别比较单一，可以在选取 anchor 的尺寸和高宽比时对 GT box 的这两个参数进行聚类，得到一个比较合适的数值。<br>2.可以尝试在每张图的不同位置设置不同尺寸和大小的 adaptive anchor<br>3.针对检测目标的特性选择anchor的形状，如使用平行四边形</p><h2 id="Post-Process之NMS"><a href="#Post-Process之NMS" class="headerlink" title="Post-Process之NMS"></a>Post-Process之NMS</h2><p>由于目标检测算法往往会在一个目标的周围产生大量的目标检测框，而我们最终只需要其检测的最合适的一个，所以需要使用NMS算法来对结果进行后处理。<br>NMS算法的基本思想为：对于一个目标周围的若干大量检测框，找出其中置信度最高的一个保留，然后将其余的框去除<br>具体步骤为：</p><ol><li>对所有的检测框按照置信度从高到低的顺序排序</li><li>求出其他检测框与置信度最高的框的iou值，如果大于一定阈值则说明这些框与置信度最高的框重复性高，将这些框移除（抑制），小于阈值的框保留等待进一步处理，置信度最高的框保存到结果中</li><li>将上一步剩余的框再一次按照1和2步骤操作，反复循环到没有框在需要处理（上一步能留下来的框，一般都是另一个物体的框了，所以可继续执行）</li></ol><img src="/.com//blog\source\images\2020-9-17-plHxTI1BECT3fke_cGCll.png" alt="avatar"><h2 id="卷积结构之FPN——feature-pyrimid-network-特征金字塔网络"><a href="#卷积结构之FPN——feature-pyrimid-network-特征金字塔网络" class="headerlink" title="卷积结构之FPN——feature pyrimid network 特征金字塔网络"></a>卷积结构之FPN——feature pyrimid network 特征金字塔网络</h2><p>特征金字塔思路主要是利用bakcbone多个stage对应多个分辨率特征图的特点，采用<strong>小尺寸特征图用于检测大尺寸物体</strong>，而<strong>大尺寸特征图检测小尺寸物体</strong>的思路。<br>如上图所示，backbone的多个stage每个stage都会输出一个特征图，通过融合浅层和深层的特征来动态分配大目标和小目标。<br>上图中的C2，C3, C4, C5代表了backbone的4个stage对应的输出，然后通过如图所示的自上向下，也就是从深层特征到浅层特征的方式融合后，再经过一个卷积层，生成最终的P2,P3,P4，P5特征图用于后续的分类和回归。</p><img src="/.com//blog\source\images\2020-9-17-3cvzw2q7dFkKn3dFpRWEq.png" alt="avatar" style="zoom:67%;"><img src="/.com//blog\source\images\2020-9-17-s53Z_xFHPsEI68hxTMmwm.png" alt="avatar" style="zoom:80%;">]]></content>
    
    
    <categories>
      
      <category>Deep Learning-Objects Detection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch_Related（二）</title>
    <link href="/2021/08/13/Pytorch-Related%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2021/08/13/Pytorch-Related%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="项目一：基于pytorch实现昆虫分类任务"><a href="#项目一：基于pytorch实现昆虫分类任务" class="headerlink" title="项目一：基于pytorch实现昆虫分类任务"></a>项目一：基于pytorch实现昆虫分类任务</h2><span id="more"></span><p>1.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function, division<br></code></pre></td></tr></table></figure><p>该句语句是python2的概念，那么python3对于python2就是future了，也就是说，在python2的环境下，超前使用python3的print函数;</p><p>这是python提供的一种机制：如果<strong>某个版本中出现了某个新的功能特性</strong>，而且这个特性和当前版本中使用的不兼容，也就是它在该版本中不是语言标准，那么我如果想要使用的话就需要从<strong>future</strong>模块导入。</p><p>2.torchvision的transform库可以用字典的形式定义对训练集、测试集不同的操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">data_transforms = &#123;<br>    <span class="hljs-comment"># 训练中的数据增强和归一化</span><br>    <span class="hljs-string">&#x27;train&#x27;</span>: transforms.Compose([<br>        transforms.RandomResizedCrop(<span class="hljs-number">224</span>), <span class="hljs-comment"># 随机裁剪</span><br>        transforms.RandomHorizontalFlip(), <span class="hljs-comment"># 左右翻转</span><br>        transforms.ToTensor(),<br>        transforms.Normalize([<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>], [<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>]) <span class="hljs-comment"># 均值方差归一化</span><br>    ]), <br>    <span class="hljs-comment"># 验证集不增强，仅进行归一化</span><br>    <span class="hljs-string">&#x27;val&#x27;</span>: transforms.Compose([<br>        transforms.Resize(<span class="hljs-number">256</span>),<br>        transforms.CenterCrop(<span class="hljs-number">224</span>),<br>        transforms.ToTensor(),<br>        transforms.Normalize([<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>], [<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])<br>    ]),<br>&#125;<br></code></pre></td></tr></table></figure><p>3.pythonic的数据读取方式：</p><p>注：此项目代码的数据读取思路整体遵循：<strong>搭配for循环读取成字典</strong></p><p><strong>ImageFolder</strong>：PIL Image对象，可以通过xxx.classes查看“类名”，xxx.classes_to_idx等操作具体百度；</p><p> <strong>–&gt; DataLoader</strong>：读取成batch，有一个参数<code>num_workers</code>在后面解释</p><p>假定训练集和测试集在一个文件夹下，且名字分别为”train”、”val”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">data_dir = <span class="hljs-string">&#x27;datasets/hymenoptera_data&#x27;</span><br><span class="hljs-comment"># image_datasets是要一个字典，key有for循环给出</span><br>image_datasets = &#123;x: datasets.ImageFolder(os.path.join(data_dir, x),<br>                                          data_transforms[x])<br>                  <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;train&#x27;</span>, <span class="hljs-string">&#x27;val&#x27;</span>]&#125;<br><br><span class="hljs-comment"># 读取batch</span><br>dataloaders = &#123;x: torch.utils.data.DataLoader(image_datasets[x], batch_size=<span class="hljs-number">4</span>,<br>                                             shuffle=<span class="hljs-literal">True</span>, num_workers=<span class="hljs-number">4</span>)   <span class="hljs-comment"># num_workers</span><br>              <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;train&#x27;</span>, <span class="hljs-string">&#x27;val&#x27;</span>]&#125;<br><br><span class="hljs-comment"># 获取一些数据集的信息</span><br>dataset_sizes = &#123;x: <span class="hljs-built_in">len</span>(image_datasets[x]) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;train&#x27;</span>, <span class="hljs-string">&#x27;val&#x27;</span>]&#125;<br>class_names = image_datasets[<span class="hljs-string">&#x27;train&#x27;</span>].classes<br></code></pre></td></tr></table></figure><p>4.</p><p>DataLoader中的<code>num_workers</code></p><ol><li><p>dataloader一次性创建<code>num_worker</code>个worker，（也可以说dataloader一次性创建<code>num_worker</code>个工作进程，worker也是普通的工作进程），</p><p>并用<code>batch_sampler</code>将指定batch分配给指定worker，worker将它负责的batch加载进RAM。</p><p>然后，dataloader从RAM中找本轮迭代要用的batch，如果找到了，就使用。如果没找到，就要<code>num_worker</code>个worker继续加载batch到内存，直到dataloader在RAM中找到目标batch。一般情况下都是能找到的，因为<code>batch_sampler</code>指定batch时当然优先指定本轮要用的batch。</p></li><li><p><code>num_worker</code>设置得大，好处是寻batch速度快，因为下一轮迭代的batch很可能在上一轮/上上一轮…迭代时已经加载好了。坏处是内存开销大，也<strong>加重了CPU负担</strong>（worker加载数据到RAM的进程是CPU复制的嘛）。<code>num_workers</code>的经验设置值是自己电脑/服务器的CPU核心数，<strong>如果CPU很强、RAM也很充足，就可以设置得更大些</strong>。</p></li><li><p>如果<code>num_worker</code>设为0，意味着每一轮迭代时，dataloader不再有自主加载数据到RAM这一步骤（因为没有worker了），而是在RAM中找batch，找不到时再加载相应的batch。缺点当然是速度更慢。</p></li></ol><p>设置<code>num_workers</code>后可能会报错：</p><img src="https://img-blog.csdnimg.cn/20201014205540715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTkxMjMwNw==,size_16,color_FFFFFF,t_70#pic_center" alt="img" style="zoom:50%;"><p>因为多个workers是多线程，windows递归创建子进程，<strong>必须放在<code>__main__</code>函数的内部</strong>！！</p><p>5.</p><p><strong><code>transforms.ToTensor()</code>函数到底有什么作用？</strong></p><p>将numpy的ndarray格式转化为torch.tensor格式，这个转换主要是通道顺序上做了调整：</p><p><strong>numpy中的BGR</strong>顺序 –&gt; <strong>torch中的RGB</strong>顺序</p><p>所以在可视化时，必须要先从tensor转换为numpy格式，要从RGB转换为BGR</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">imshow</span>(<span class="hljs-params">inp, title=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-comment"># 在可视化时候，要先将通道的顺序转换回来，即从RGB转回BGR</span><br>    inp = inp.numpy().transpose((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>))<br>    <span class="hljs-comment"># 接着再进行反归一化</span><br>    mean = np.array([<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>])<br>    std = np.array([<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])<br>    inp = std * inp + mean<br>    inp = np.clip(inp, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment"># 小于0的置为0，大于1的置为1</span><br>    plt.imshow(inp)<br>    <span class="hljs-keyword">if</span> title <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        plt.title(title)<br>    plt.pause(<span class="hljs-number">0.001</span>)<br>    <br><span class="hljs-comment">#  从训练数据中取一个batch的图片</span><br>inputs, classes = <span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(dataloaders[<span class="hljs-string">&#x27;train&#x27;</span>]))   <span class="hljs-comment"># 下面解释该语句；此处classes是[0,2,1,3,0,1]类别列表</span><br>out = torchvision.utils.make_grid(inputs)<span class="hljs-comment"># 子图拼接设置</span><br>imshow(out, title=[class_names[x] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> classes])  <span class="hljs-comment"># 用上述列表对应到实际名称，画在图上</span><br> <span class="hljs-comment"># class_names是实际名称列表</span><br></code></pre></td></tr></table></figure><p>6.</p><p>python内置函数之<code>iter()</code>与<code>next()</code>的搭配：</p><p><strong>next()</strong> 函数要和生成迭代器的 <strong>iter()</strong> 函数一起使用，返回迭代器的下一个项目–&gt;它们合作的效果有点像for循环</p><p>所以上述代码中的inputs、classes是取了一个batch</p><p>7.</p><p><code>torchvision.utils.make_grid</code>子图拼接设置：</p><p>主要有两个参数：<strong>padding</strong>设置子图间的缝隙大小；<strong>nrow</strong>设置一行有多少个图片</p><p>具体见：<a href="https://blog.csdn.net/zouxiaolv/article/details/105034512">Pytorch torchvision.utils.make_grid()用法_邹小驴-CSDN博客_torchvision.utils.make_grid</a></p><p>8.</p><p><code>plt.ion()</code>交互画图模式</p><p>因为python可视化库matplotlib的显示模式默认为阻塞（block）模式（即：在plt.show()之后，程序会暂停到那儿，并不会继续执行下去）。如何 展示动态图或多个窗口 呢？</p><p>使用plt.ion()这个函数，使matplotlib的显示模式转换为交互（interactive）模式。即使在脚本中遇到plt.show()，代码还是会继续执行。</p><p>以两段代码为例，即懂：</p><p>#1. 阻塞模式，无<code>plt.ion()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">imshow</span>(<span class="hljs-params">inp, title=<span class="hljs-literal">None</span></span>):</span><br>    inp = inp.numpy().transpose((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>))<br>    mean = np.array([<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>])<br>    std = np.array([<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])<br>    inp = std * inp + mean<br>    inp = np.clip(inp, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>    plt.imshow(inp)<br>    <span class="hljs-keyword">if</span> title <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        plt.title(title)<br>    plt.pause(<span class="hljs-number">0.001</span>)<br>    plt.show() <span class="hljs-comment"># 必须要用plt.show()才能显示，不管前面用的是imshow()还是plot() </span><br></code></pre></td></tr></table></figure><p>#2. 交互模式，使用<code>plt.ion()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.ion()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">imshow</span>(<span class="hljs-params">inp, title=<span class="hljs-literal">None</span></span>):</span><br>    inp = inp.numpy().transpose((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>))<br>    mean = np.array([<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>])<br>    std = np.array([<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])<br>    inp = std * inp + mean<br>    inp = np.clip(inp, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>    plt.imshow(inp)<br>    <span class="hljs-keyword">if</span> title <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        plt.title(title)<br>    plt.pause(<span class="hljs-number">0.001</span>)<br>    <br>    <br>    <span class="hljs-comment"># 一般放在所有代码的最后，因为执行到plt.show()程序就会暂停</span><br>    plt.ioff() <span class="hljs-comment"># 在plt.show()之前使用plt.ioff()，否则图片会一闪而过</span><br>    plt.show()   <span class="hljs-comment"># 一定要使用plt.show()</span><br></code></pre></td></tr></table></figure><p>9.</p><p><code>model.eval()</code>作用：不启用BN和Dropout， 但是不会影响的梯度的计算。</p><p>10.</p><p><code>with torch.no_grad():</code>、<code>with torch.set_grad_enabled(bool):</code></p><p>要理解这两个函数作用，首先清楚：pytorch中，如果tensor具有grad属性，则在<strong>前向传播中就会同时计算梯度</strong>（方便直接反向传播）</p><p>（1）with torch.no_grad():</p><p>​            with包裹的语句块下的tensor都不用求梯度</p><p>（2）with torch.set_grad_enabled(bool):</p><p>​            仅当传参为False，with下的tensor才不求梯度</p><p>​            —&gt;所以可用作对训练集、测试集分支，<code>with torch.set_grad_enabled(xxx == &#39;train&#39;):</code></p><p>11.</p><p><code>torch.max()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">_, pred = torch.<span class="hljs-built_in">max</span>(a,<span class="hljs-number">1</span>)<br><span class="hljs-comment"># _代表一个不关心的变量，返回最大值</span><br><span class="hljs-comment"># pred返回最大值的索引</span><br><span class="hljs-comment"># max的第二个参数是dim，dim=1表示一行中最大，dim=0表示一列中最大</span><br></code></pre></td></tr></table></figure><p>12.</p><p>train函数中loss的计算，易错点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">running_loss += loss.item() * inputs.size(<span class="hljs-number">0</span>)  <span class="hljs-comment"># 为什么要 *input.size(0) ?</span><br>running_corrects += torch.<span class="hljs-built_in">sum</span>(preds == labels.data)<br></code></pre></td></tr></table></figure><p>forward()函数中，input首先经过卷积层，此时的输出x是包含batchsize维度为4的tensor，即**(batchsize，channels，x，y)**，x.size(0)指batchsize的值</p><p>所以inputs.size(0)指的是batchsize的大小</p><p>13.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> phase == <span class="hljs-string">&#x27;train&#x27;</span>:<br>   scheduler.step()<br></code></pre></td></tr></table></figure><p>如果采用学习率衰减，则要另外创建scheduler = xxx.StepLR，且在训练中要另外执行<code>scheduler.step()</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.optim <span class="hljs-keyword">import</span> lr_scheduler<br><span class="hljs-comment"># 优化器使用sgd，学习率设置为0.001</span><br>optimizer_ft = optim.SGD(net.parameters(), lr=<span class="hljs-number">0.001</span>, momentum=<span class="hljs-number">0.9</span>)<br><br><span class="hljs-comment"># 每7个epoch将lr降低为原来的0.1</span><br>exp_lr_scheduler = lr_scheduler.StepLR(optimizer_ft, step_size=<span class="hljs-number">7</span>, gamma=<span class="hljs-number">0.1</span>)<br></code></pre></td></tr></table></figure><p>14.</p><p>计时后显示分、秒：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Training complete in &#123;:.0f&#125;m &#123;:.0f&#125;s&#x27;</span>.<span class="hljs-built_in">format</span>(<br>        time_elapsed // <span class="hljs-number">60</span>, time_elapsed % <span class="hljs-number">60</span>))<br></code></pre></td></tr></table></figure><p>15.</p><p>迁移学习之finetune：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">model_conv = torchvision.models.resnet18(pretrained=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># freeze前面的卷积层，使其训练时不更新</span><br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> model_conv.parameters():<br>    param.requires_grad = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 最后的分类fc层输出换为2，进行二分类</span><br>num_ftrs = model_conv.fc.in_features<br>model_conv.fc = nn.Linear(num_ftrs, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 仅训练最后改变的fc层</span><br>optimizer_conv = optim.SGD(model_conv.fc.parameters(), lr=<span class="hljs-number">0.001</span>, momentum=<span class="hljs-number">0.9</span>)<br><br></code></pre></td></tr></table></figure><p>首先第一句代码的作用是：所有参数都固定住，不会发生梯度的更新；第二句代码的作用是定义一个优化器，这个优化器的作用是优化全连接层中的参数，并没有说要优化特征层中的参数。那么这里自然会让人想到，为什么两个代码要一起用呢？</p><p>只写第一句那么，特征层不会产生梯度，但是梯度会在其中传播。</p><p>只写第二句，梯度正常产生，但是由于优化器没有涉及特征层的参数，所以特征层虽然产生了梯度，但是参数却不会改变。</p><p>合起来写：可以<strong>降低计算量</strong></p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning-Objects Detection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CUDA编译与NVCC编译器</title>
    <link href="/2021/08/12/CUDA%E7%BC%96%E8%AF%91%E4%B8%8ENVCC%E7%BC%96%E8%AF%91%E5%99%A8/"/>
    <url>/2021/08/12/CUDA%E7%BC%96%E8%AF%91%E4%B8%8ENVCC%E7%BC%96%E8%AF%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="CUDA编译与NVCC编译器"><a href="#CUDA编译与NVCC编译器" class="headerlink" title="CUDA编译与NVCC编译器"></a>CUDA编译与NVCC编译器</h2><p>NVCC是什么？</p><p>是一种编译器，对于C、C++等高级语言，需要通过编译器编译成可执行的二进制文件(binary)；</p><p><strong>nvcc对CUDA代码段(通常也是由C语言编写)进行编译</strong>，所有非CUDA的代码均交给通用的C编译器，windows下是C1编译器，Linux下是gcc编译器</p><span id="more"></span><h3 id="一、nvcc命令"><a href="#一、nvcc命令" class="headerlink" title="一、nvcc命令"></a>一、nvcc命令</h3><p>Nvcc的选项命令形式大概有以下3类：boolean (flag-)选项，单值选项和列表(multivalued-)选项。</p><p>下面是使用规则举例：</p><p>  -o file</p><p>  -o=file</p><p>  -Idir1,dir2 -I=dir3 -I dir4,dir5</p><p>  每一个选项命令都有两个名字，全称和简写，例如<em>–I</em>就是*–include-path*的简称，注本文后面的选项命令说明均只列出简称，详细见参考资料1。一般来说，全称多用于述，简称多用于实际使用。</p><p>编译选项可按用途分为以下8大类：</p><p>１．指定编译阶段</p><p>主要指定编译的阶段以及要编译的输入文件。</p><p>-cuda -cubin -fatbin -ptx -gpu -E </p><p><strong>-c :最常使用，编译每个输入文件.c/.cc/.cpp/.cxx/.cu为object文件</strong></p><p>-dc -dw -dlink -link </p><p>-lib ：编译所有的输入文件为object文件，并且把结果添加到指定的library输出文件</p><p>-run</p><p>２．文件和路径配置</p><p><strong>-o :指定输出文件的位置和名称</strong></p><p>-include ：指定预处理和编译时预先需要包含的头文件</p><p>-l ：指定链接时需要的库文件</p><p>-D ：指定预处理和编译时需要的宏</p><p>-U ：取消宏定义</p><p>-I ：指定包含文件的搜索路径</p><p>-isystem ：指定系统包含的引用文件的搜索路径</p><p>-L ：指定库文件的搜索路径</p><p>-odir ：指定输出文件的目录</p><p>-ccbin ：指定host编译器所在路径</p><p>-cudart ：指定CUDA runtime library使用类型（none,shared,static），默认为static</p><p>-ldir :指定包含libdevice库文件目录</p><p>３．指定编译器、连接器的行为</p><p>-pg </p><p>-g :产生可调式代码，调试模式下必须的</p><p>-G ：产生可调式的设备代码</p><p>-lineinfo ：为设备代码产生行number信息</p><p>-O ：产生优化代码 ，包括O0,O1,O2,O3，用于产生不同的指令集</p><p>-ftemplate-backtrace-limit -shared -x -std -nohdinitlist -nohdmoveforward -expt-relaxed-constexpr </p><p>-m :指定平台结构32 vs 64</p><p>４．编译工具内部选项</p><p>-Xcompiler -Xlinker -Xarchive -Xptxas -Xnvlink</p><p>-Xptxas -v:显示代码生成的统计结果</p><p>-Xptxas -dlcm=cg:关闭L1cache</p><p>-Xptxas -dlcm=ca:将L1cache增加到48KB(默认为16KB，和shared memory一共64KB)</p><p>５．编译驱动引导选项</p><p>-noprof -dryrun </p><p>-v :列出nvcc产生的编译命令，不影响其执行</p><p>-keep ：保留各步骤产生的中间文件，用于调试</p><p>-keep-dir -save-temps </p><p>-clean ：逆转nvcc的行为</p><p>-run-args -idp -ddp -dp -MT -nodlink</p><p>６．CUDA编译方式选项</p><p>-default-stream</p><p>７．驾驭GPU代码生成选项</p><p>-arch :指定GPU架构</p><p>-code -gencode -rdc -e </p><p>-maxrregcount ：指定GPU函数可使用的最大寄存器数量</p><p>-use_fast_math -ftz -prec-div -prec-sqrt -fmad</p><p>８．ptxas选项</p><p>-allow-expensive-optimizations -c -dlcm -dscm -g -disable-optimizer-consts -e -fmad -flcm -fscm -lineinfo -arch -h -m -maxrregcount -O -optf -o -preserve-relocs -sp-bound-check -v -V -Werror -warn-double-usage -warn-spills</p><h3 id="二、举例"><a href="#二、举例" class="headerlink" title="二、举例"></a>二、举例</h3><p>以Faster-RCNN的源码为例，简介cuda编程等一些文件的架构和流程</p><h4 id="1-make-sh编译配置文件"><a href="#1-make-sh编译配置文件" class="headerlink" title="1.make.sh编译配置文件"></a>1.<code>make.sh</code>编译配置文件</h4><p>在使用源代码时，作者都会让我们先跑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">sh make.sh<br></code></pre></td></tr></table></figure><p><strong><code>.sh</code>文件</strong>是bash脚本，就是<strong>自动化我们的命令行</strong>而已，所以在<code>make.sh</code>会有<code>cd xxx</code>、<code>cd ..</code>等命令的出现；</p><p>这一步实际上是在做所有与编译相关的工作，编译包括：</p><p><strong>1）cuda程序：<code>.cu</code>文件</strong></p><p><strong>2）python程序的C扩展：通过<code>build.py</code>编译<code>.c</code>文件</strong></p><p>注：cuda程序只是其中的一些实现，python的C扩展编译相当于是最后的总装！！</p><p><code>make.sh</code>文件的内容通常包括：</p><p>先用nvcc编译cuda程序 —&gt; 再执行build.py文件编译c程序     例子项目中的<code>make.sh</code>如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env bash</span><br><br><span class="hljs-comment"># CUDA_PATH=/usr/local/cuda/</span><br><br>export CUDA_PATH=/usr/local/cuda/<br><span class="hljs-comment">#You may also want to ad the following</span><br><span class="hljs-comment">#export C_INCLUDE_PATH=/opt/cuda/include</span><br><br>export CXXFLAGS=<span class="hljs-string">&quot;-std=c++11&quot;</span><br>export CFLAGS=<span class="hljs-string">&quot;-std=c99&quot;</span><br><br>CUDA_ARCH=<span class="hljs-string">&quot;-gencode arch=compute_30,code=sm_30 \</span><br><span class="hljs-string">           -gencode arch=compute_35,code=sm_35 \</span><br><span class="hljs-string">           -gencode arch=compute_50,code=sm_50 \</span><br><span class="hljs-string">           -gencode arch=compute_52,code=sm_52 \</span><br><span class="hljs-string">           -gencode arch=compute_60,code=sm_60 \</span><br><span class="hljs-string">           -gencode arch=compute_61,code=sm_61 &quot;</span><br><br><span class="hljs-comment"># compile NMS</span><br>cd nms/src<br>echo <span class="hljs-string">&quot;Compiling nms kernels by nvcc...&quot;</span><br>nvcc -c -o nms_cuda_kernel.cu.o nms_cuda_kernel.cu \<br> -D GOOGLE_CUDA=<span class="hljs-number">1</span> -x cu -Xcompiler -fPIC $CUDA_ARCH<br><br>cd ../<br>python build.py<br><br><span class="hljs-comment"># compile roi_pooling</span><br>cd ../<br>cd roi_pooling/src<br>echo <span class="hljs-string">&quot;Compiling roi pooling kernels by nvcc...&quot;</span><br>nvcc -c -o roi_pooling.cu.o roi_pooling_kernel.cu \<br> -D GOOGLE_CUDA=<span class="hljs-number">1</span> -x cu -Xcompiler -fPIC $CUDA_ARCH<br>cd ../<br>python build.py<br></code></pre></td></tr></table></figure><h4 id="2-进入cuda程序：nms-cuda-kernel-cu中"><a href="#2-进入cuda程序：nms-cuda-kernel-cu中" class="headerlink" title="2.进入cuda程序：nms_cuda_kernel.cu中"></a>2.进入cuda程序：<code>nms_cuda_kernel.cu</code>中</h4><p>截取部分代码进行体会：</p><p>可以理解为：实际就是用C语言造的轮子，外面用nvcc进行编译后就可以拿来使用了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#include &lt;stdbool.h&gt;</span><br><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><span class="hljs-comment">#include &lt;vector&gt;</span><br><span class="hljs-comment">#include &lt;iostream&gt;</span><br><span class="hljs-comment">#include &quot;nms_cuda_kernel.h&quot;</span><br><br><span class="hljs-comment">#define CUDA_WARN(XXX) \</span><br>    do &#123; <span class="hljs-keyword">if</span> (XXX != cudaSuccess) std::cout &lt;&lt; <span class="hljs-string">&quot;CUDA Error: &quot;</span> &lt;&lt; \<br>        cudaGetErrorString(XXX) &lt;&lt; <span class="hljs-string">&quot;, at line &quot;</span> &lt;&lt; __LINE__ \<br>&lt;&lt; std::endl; cudaDeviceSynchronize(); &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<br><br><span class="hljs-comment">#define CUDA_CHECK(condition) \</span><br>  /* Code block avoids redefinition of cudaError_t error */ \<br>  do &#123; \<br>    cudaError_t error = condition; \<br>    <span class="hljs-keyword">if</span> (error != cudaSuccess) &#123; \<br>      std::cout &lt;&lt; cudaGetErrorString(error) &lt;&lt; std::endl; \<br>    &#125; \<br>  &#125; <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span>)<br><br><span class="hljs-comment">#define DIVUP(m,n) ((m) / (n) + ((m) % (n) &gt; 0))</span><br><span class="hljs-built_in">int</span> const threadsPerBlock = sizeof(unsigned long long) * <span class="hljs-number">8</span>;<br><br>__device__ inline <span class="hljs-built_in">float</span> devIoU(<span class="hljs-built_in">float</span> const * const a, <span class="hljs-built_in">float</span> const * const b) &#123;<br>  <span class="hljs-built_in">float</span> left = <span class="hljs-built_in">max</span>(a[<span class="hljs-number">0</span>], b[<span class="hljs-number">0</span>]), right = <span class="hljs-built_in">min</span>(a[<span class="hljs-number">2</span>], b[<span class="hljs-number">2</span>]);<br>  <span class="hljs-built_in">float</span> top = <span class="hljs-built_in">max</span>(a[<span class="hljs-number">1</span>], b[<span class="hljs-number">1</span>]), bottom = <span class="hljs-built_in">min</span>(a[<span class="hljs-number">3</span>], b[<span class="hljs-number">3</span>]);<br>  <span class="hljs-built_in">float</span> width = <span class="hljs-built_in">max</span>(right - left + <span class="hljs-number">1</span>, <span class="hljs-number">0.</span>f), height = <span class="hljs-built_in">max</span>(bottom - top + <span class="hljs-number">1</span>, <span class="hljs-number">0.</span>f);<br>  <span class="hljs-built_in">float</span> interS = width * height;<br>  <span class="hljs-built_in">float</span> Sa = (a[<span class="hljs-number">2</span>] - a[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) * (a[<span class="hljs-number">3</span>] - a[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">float</span> Sb = (b[<span class="hljs-number">2</span>] - b[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>) * (b[<span class="hljs-number">3</span>] - b[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">return</span> interS / (Sa + Sb - interS);<br>&#125;<br><br>__global__ void nms_kernel(<span class="hljs-built_in">int</span> n_boxes, <span class="hljs-built_in">float</span> nms_overlap_thresh,<br>                           <span class="hljs-built_in">float</span> *dev_boxes, unsigned long long *dev_mask) &#123;<br>  const <span class="hljs-built_in">int</span> row_start = blockIdx.y;<br>  const <span class="hljs-built_in">int</span> col_start = blockIdx.x;<br><br>  // <span class="hljs-keyword">if</span> (row_start &gt; col_start) <span class="hljs-keyword">return</span>;<br><br>  const <span class="hljs-built_in">int</span> row_size =<br>        <span class="hljs-built_in">min</span>(n_boxes - row_start * threadsPerBlock, threadsPerBlock);<br>  const <span class="hljs-built_in">int</span> col_size =<br>        <span class="hljs-built_in">min</span>(n_boxes - col_start * threadsPerBlock, threadsPerBlock);<br></code></pre></td></tr></table></figure><h4 id="3-nvcc编译完后，执行build-py文件："><a href="#3-nvcc编译完后，执行build-py文件：" class="headerlink" title="3.nvcc编译完后，执行build.py文件："></a>3.nvcc编译完后，执行<code>build.py</code>文件：</h4><p>可见，程序中加载了<code>.c</code>和<code>.h</code>文件，实际上是对剩下的C程序进行编译，这里使用pytorch的<code>torch.utils.ffi</code>工具进行编译！</p><p>最后形成编译部分的总装，编译工作即完成了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> print_function<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch.utils.ffi <span class="hljs-keyword">import</span> create_extension<br><br><span class="hljs-comment">#this_file = os.path.dirname(__file__)</span><br><br>sources = []<br>headers = []<br>defines = []<br>with_cuda = <span class="hljs-literal">False</span><br><br><span class="hljs-keyword">if</span> torch.cuda.is_available():<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Including CUDA code.&#x27;</span>)<br>    sources += [<span class="hljs-string">&#x27;src/nms_cuda.c&#x27;</span>]<span class="hljs-comment"># c</span><br>    headers += [<span class="hljs-string">&#x27;src/nms_cuda.h&#x27;</span>]<span class="hljs-comment"># c的头文件</span><br>    defines += [(<span class="hljs-string">&#x27;WITH_CUDA&#x27;</span>, <span class="hljs-literal">None</span>)]<br>    with_cuda = <span class="hljs-literal">True</span><br><br>this_file = os.path.dirname(os.path.realpath(__file__))<br><span class="hljs-built_in">print</span>(this_file)<br>extra_objects = [<span class="hljs-string">&#x27;src/nms_cuda_kernel.cu.o&#x27;</span>]<br>extra_objects = [os.path.join(this_file, fname) <span class="hljs-keyword">for</span> fname <span class="hljs-keyword">in</span> extra_objects]<br><span class="hljs-built_in">print</span>(extra_objects)<br><br>ffi = create_extension(<br>    <span class="hljs-string">&#x27;_ext.nms&#x27;</span>,<br>    headers=headers,<br>    sources=sources,<br>    define_macros=defines,<br>    relative_to=__file__,<br>    with_cuda=with_cuda,<br>    extra_objects=extra_objects<br>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    ffi.build()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Deep Learning-Objects Detection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>WSDDN源码总结与收获</title>
    <link href="/2021/08/11/WSDDN%E6%BA%90%E7%A0%81%E6%80%BB%E7%BB%93%E4%B8%8E%E6%94%B6%E8%8E%B7/"/>
    <url>/2021/08/11/WSDDN%E6%BA%90%E7%A0%81%E6%80%BB%E7%BB%93%E4%B8%8E%E6%94%B6%E8%8E%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="WSDDN源码总结与收获"><a href="#WSDDN源码总结与收获" class="headerlink" title="WSDDN源码总结与收获"></a>WSDDN源码总结与收获</h2><p>不完全，所有步骤与细节已经注释在源码当中。</p><span id="more"></span><h3 id="一、datasets-py"><a href="#一、datasets-py" class="headerlink" title="一、datasets.py"></a>一、datasets.py</h3><p>1.　所有文件的读取都用OS库中路径的方式的完成，放在<code>datasets.py</code>文件中<br>2.　<strong>EdgeBoxes</strong>等区域建议方法在经典数据集上（如VOC2007）上已经训练好，并且有每个proposal的类别得分，可以从网上下载**.mat文件<strong>；<br>   .mat文件用</strong>scipy.io库<strong>中的</strong>loadmat函数<strong>读取<br>3.　VOC2007数据集等官方标注都用</strong>.xml文件<strong>给出，xml语法由标签和子标签组成，可以看作树结构，所以用</strong>xml.etree.ElementTree库<strong>处理<br>4.　弱监督中，对于训练集而言，</strong>只有image-level标签，这是怎么获得的呢？**<br>   <strong>实际上是人工产生的！</strong>VOC2007这种数据集只有精细的instance-level标注，我们需要先将其转换为image-level标签，作为训练数据的target拿去训练；<br>   所以在datasets.py文件中，对训练集和测试集的处理是不同的，本源码中采用的方法是：用<code>self.split</code>变量存储”trainval”/“test”，后面搭配 <code>if </code>实现对不同分支的处理</p><h3 id="二、network-py"><a href="#二、network-py" class="headerlink" title="二、network.py"></a>二、network.py</h3><ol><li><p><code>__init__</code>函数的参数是实例化网络时需要传的</p></li><li><p>必须定义<code>forward</code>函数，以覆盖继承的nn.Module类方法</p></li><li><p>使用既定的网络作为backbone时，通常使用<code>torchvision.models</code>中的模型，如alexnet 、vgg16等；</p><p>通常在pytorch的源码实现中，<code>features</code>是完成特征提取的卷积网络，<code>classifier</code>是后面的全连接层</p><p>在此基础上fine-tune，通常需要<strong>修改最后一层的网络架构</strong>–&gt;通过切片实现，<strong>切片不包含第二个值</strong>，例如：features[:-1]表示去掉最后一层</p></li><li><p>SPP和roi_pool的本质相同，所以通常用<code>torchvision.ops</code>库的<code>roi_pool</code>方法进行实现</p></li><li><p><code>torch.nn.functional</code>模块中有<code>sotfmax()</code>、<code>binary_cross_entropy()</code>等函数</p></li><li><p>如果loss是自己设计的，那么可以定义在network架构中，用<code>cal_loss</code>函数</p></li></ol><h3 id="三、utils-py"><a href="#三、utils-py" class="headerlink" title="三、utils.py"></a>三、utils.py</h3><ol><li>通常在该文件里定义随机种子函数set_seed，要完成：random、np、torch、torch.cudnn的随机种子设置</li><li>数据增强的方法定义在此</li><li>评估函数<code>evaluate</code>定义在此</li><li>实际中的小<strong>tricks</strong>也可定义在这里，比如<code>filter_small_boxes</code>、<code>swap_axes</code>等函数</li></ol><h3 id="四、train-py"><a href="#四、train-py" class="headerlink" title="四、train.py"></a>四、train.py</h3><ol><li><p>通常要用argparse与终端进行交互</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">parser = argparse.ArgumentParser(description=<span class="hljs-string">&quot;Train&quot;</span>)<br>parser.add_argument(<span class="hljs-string">&quot;--base_net&quot;</span>,<span class="hljs-built_in">type</span>=xxx,default=xxx,<span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;xxx&quot;</span>)<br>parser.add_argument()<br>parser.add_argument()<br>parser.add_argument()<br><br>args = parser.parse_args()<br><br>xxx=args.base_net<br>xxx=args.epoch<br>xxx=args.seed<br><span class="hljs-comment"># 后续就用新定义的变量xxx</span><br></code></pre></td></tr></table></figure></li><li><p>用<code>DataLoader</code>完成batch的读取</p></li><li><p>养成习惯：train函数中，每定义完一个变量之后，就<code>.to(DEVICE)</code>存到GPU中</p></li><li><p>通常为了观察网络的中间结果，需要在一定的迭代次数时，保存模型，方便后面进行测试；<br>使用<code>torch.save()</code>函数，搭配<code>net.state_dict()</code>实现；<br>通常保存为**.pt** 或 <strong>.pth</strong>文件</p></li><li><p>通常不是只在最后才测试模型，而是在一定迭代次数时送入test：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在一定迭代次数时，保存模型！！！   预设state_period参数</span><br>        <span class="hljs-keyword">if</span> epoch % STATE_PERIOD == <span class="hljs-number">0</span>:<br>            path = os.path.join(BASE_DIR, <span class="hljs-string">&quot;states&quot;</span>, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;net.base_net&#125;</span>_epoch_<span class="hljs-subst">&#123;epoch&#125;</span>.pt&quot;</span>)<br>            torch.save(net.state_dict(), path)  <br>            tqdm.write(<span class="hljs-string">f&quot;State saved to <span class="hljs-subst">&#123;path&#125;</span>&quot;</span>)  <br>        tqdm.write(<span class="hljs-string">f&quot;Avg loss is <span class="hljs-subst">&#123;epoch_loss / <span class="hljs-built_in">len</span>(train_ds)&#125;</span>&quot;</span>)<br><br>        <span class="hljs-keyword">if</span> epoch % EVAL_PERIOD == <span class="hljs-number">0</span>:<br>            tqdm.write(<span class="hljs-string">f&quot;Evaluation started at <span class="hljs-subst">&#123;datetime.now()&#125;</span>&quot;</span>)<br>            evaluate(net, test_dl)<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Deep Learning-Objects Detection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch_Related（一）</title>
    <link href="/2021/08/10/Pytorch-Related%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/08/10/Pytorch-Related%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>和python系列同理，本记录专门记录阅读源码过程中<code>Pytorch</code>相关的学习所得。</p><span id="more"></span><h2 id="pytorch-学习率衰减策略"><a href="#pytorch-学习率衰减策略" class="headerlink" title="pytorch 学习率衰减策略"></a>pytorch 学习率衰减策略</h2><p>所有策略参见：<a href="https://www.jianshu.com/p/9643cba47655">Pytorch中的学习率衰减方法 - 简书 (jianshu.com)</a></p><p>重点介绍<strong>MultiStepLR</strong>，又称“<strong>三段式lr</strong>”，这种衰减方式也是在学术论文中最常见的方式，一般手动调整也会采用这种方法。</p><p>epoch进入milestones范围内即乘以gamma，离开milestones范围之后再乘以gamma</p><p>需要注意：定义了scheduler实例后，训练时梯度下降迭代由optimizer.step()变为scheduler.step()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">lr_list = []<br>model = net()<br>LR = <span class="hljs-number">0.01</span><br>optimizer = Adam(model.parameters(),lr = LR)<br>scheduler = lr_scheduler.MultiStepLR(optimizer,milestones=[<span class="hljs-number">20</span>,<span class="hljs-number">80</span>],gamma = <span class="hljs-number">0.9</span>)<br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    scheduler.step()  <span class="hljs-comment"># 迭代</span><br>    lr_list.append(optimizer.state_dict()[<span class="hljs-string">&#x27;param_groups&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;lr&#x27;</span>])<br>plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>),lr_list,color = <span class="hljs-string">&#x27;r&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="/images/steplr" alt="img"></p><h2 id="模型保存-torch-save"><a href="#模型保存-torch-save" class="headerlink" title="模型保存 torch.save"></a>模型保存 torch.save</h2><p>为了保存模型参数、优化器参数、迭代轮次等参数：</p><ol><li>先建立一个字典，保存上述参数：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">state = &#123;<span class="hljs-string">&#x27;net&#x27;</span>:model.state_dict(), <span class="hljs-string">&#x27;optimizer&#x27;</span>:optimizer.state_dict(), <span class="hljs-string">&#x27;epoch&#x27;</span>:epoch&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>调用torch.save()：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.save(state, <span class="hljs-built_in">dir</span>)   <span class="hljs-comment"># dir为保存的文件路径，通常保存为.pt或.pth文件</span><br></code></pre></td></tr></table></figure><h2 id="模型读取-torch-load"><a href="#模型读取-torch-load" class="headerlink" title="模型读取 torch.load"></a>模型读取 torch.load</h2><p>当你想恢复某一阶段的训练、或者进行测试时，那么就可以读取之前保存的网络模型参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">checkpoint = torch.load(<span class="hljs-built_in">dir</span>)<br>model.load_state_dict(checkpoint[<span class="hljs-string">&#x27;net&#x27;</span>])<br>optimizer.load_state_dict(checkpoint[<span class="hljs-string">&#x27;optimizer&#x27;</span>])<br>start_epoch = checkpoint[<span class="hljs-string">&#x27;epoch&#x27;</span>] + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="Pytorch自带的NMS、RoIAlign、RoIPool方法"><a href="#Pytorch自带的NMS、RoIAlign、RoIPool方法" class="headerlink" title="Pytorch自带的NMS、RoIAlign、RoIPool方法"></a>Pytorch自带的NMS、RoIAlign、RoIPool方法</h2><p>参考：<a href="https://blog.csdn.net/shanglianlm/article/details/102002844">(1条消息) PyTorch学习之OPS (NMS, RoIAlign, RoIPool)_mingo_敏-CSDN博客_torchvision.ops.nms</a></p><ol><li>```python<br>torchvision.ops.nms(boxes, scores, iou_threshold)<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><br>- <span class="hljs-keyword">boxes </span>(Tensor[N, <span class="hljs-number">4</span>])) – <span class="hljs-keyword">bounding </span><span class="hljs-keyword">boxes坐标. </span>格式：(x1, y1, x2, y2)<br>- <span class="hljs-keyword">scores </span>(Tensor[N]) – <span class="hljs-keyword">bounding </span><span class="hljs-keyword">boxes得分</span><br><span class="hljs-keyword">- </span>iou_threshold (float) – IoU过滤阈值<br><br><span class="hljs-number">2</span>. ```python<br>   torchvision.ops.roi_pool(input, <span class="hljs-keyword">boxes, </span>output_size, spatial_scale=<span class="hljs-number">1</span>.<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure></li></ol><p>input (Tensor[N, C, H, W]) – 输入张量<br>boxes (Tensor[K, 5] or List[Tensor[L, 4]]) – 输入的box 坐标，格式：list(x1, y1, x2, y2) 或者(batch_index, x1, y1, x2, y2)<br>output_size (int or Tuple[int, int]) – 输出尺寸, 格式： (height, width)<br>spatial_scale (float) – 将输入坐标映射到box坐标的尺度因子. 默认: 1.0</p><p>注：SPP和RoiPool没有本质区别，因此编程实现时可以用roi_pool实现SPP层</p><ol start="3"><li><p>```python<br>torchvision.ops.roi_align(input, boxes, output_size, spatial_scale=1.0, sampling_ratio=-1)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><br><span class="hljs-selector-tag">input</span> (Tensor<span class="hljs-selector-attr">[N, C, H, W]</span>) – 输入张量<br>boxes (Tensor<span class="hljs-selector-attr">[K, 5]</span> or List<span class="hljs-selector-attr">[Tensor[L, 4]</span>]) – 输入的box 坐标，格式：list(x1, y1, x2, y2) 或者(batch_index, x1, y1, x2, y2)<br>output_size (int or Tuple<span class="hljs-selector-attr">[int, int]</span>) – 输出尺寸, 格式： (<span class="hljs-attribute">height</span>, <span class="hljs-attribute">width</span>)<br>spatial_scale (<span class="hljs-attribute">float</span>) – 将输入坐标映射到box坐标的尺度因子. 默认: <span class="hljs-number">1.0</span><br>sampling_ratio (int) – 插值网格上用来计算池化后输出的采样点数量；如果sampling_ratio&gt;<span class="hljs-number">0</span>, sampling_ratio个采样点将会被使用，如果sampling_ratio&lt;= <span class="hljs-number">0</span>，自适应采样点数量,即<span class="hljs-built_in">ceil</span>(roi_width / pooled_w)和<span class="hljs-built_in">ceil</span>(roi_height / pooled_h)，默认： sampling_ratio =-<span class="hljs-number">1</span><br><br>### 随机种子<br><br>要有概念：不同库的随机种子要分别设置<br><br><span class="hljs-number">1</span>. pytorch权重初始化：<br><br>   ```python<br>   if torch.cuda.<span class="hljs-built_in">is_available</span>():<br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;gpu cuda is available!&quot;</span>)<br>       torch.cuda.<span class="hljs-built_in">manual_seed</span>(<span class="hljs-number">1000</span>)   # GPU<br>   else:<br>       <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;cuda is not available! cpu is available!&quot;</span>)<br>       torch.<span class="hljs-built_in">manual_seed</span>(<span class="hljs-number">1000</span>)   # CPU<br></code></pre></td></tr></table></figure></li><li><p>random库：random.seed(0)</p></li><li><p>numpy库：np.random.seed(0)</p></li></ol><h2 id="cudnn加速"><a href="#cudnn加速" class="headerlink" title="cudnn加速"></a>cudnn加速</h2><p>背景知识参考：<a href="https://zhuanlan.zhihu.com/p/73711222">torch.backends.cudnn.benchmark ?! - 知乎 (zhihu.com)</a></p><p>卷积的前向传播实现有80多种算法！</p><ol><li></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.backends.cudnn.benchmark = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>在迭代开始之前自动寻找<strong>最适合当前配置的卷积算法</strong>；在输入维度、网络结构在iteration之间<strong>变化不大时</strong>，可采用，以提升网络效率；</p><p>如果设置为<code>False</code>，则每次都生成相同的卷积算法；</p><ol start="2"><li>理解：每次生成相同的算法还不够，还固定下一种特定的算法：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.backends.cudnn.deterministic = <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>设置为<code>True</code> 可保证每次生成的都是固定的算法。</p><p>据此我们可以看出来，首先如果我们的网络模型一直变的话，那肯定是不能设置 <code>cudnn.benchmark=True</code> 的。因为网络结构经常变，每次 PyTorch 都会自动来根据新的卷积场景做优化：这次花费了半天选出最合适的算法出来，结果下次你结构又变了，之前就白做优化了。不仅如此，还得要根据这个新的结构继续做选择最高效的算法组合，又花费不少的时间。这样反而会大大降低效率。</p><p>不过一般的 CV 模型来说，网络的结构一般是不会动态变化的，其次，图像一般都 resize 到固定的尺寸，batch size 也是固定的。所以，在大部分情况下，我们都可以在程序中加上这行神奇的代码，来减少运行时间！</p><p>综上，为保持<strong>代码的可复现性</strong>，通常有以下组合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 设置随机种子</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>np.random.seed(<span class="hljs-number">0</span>)<br>torch.manual_seed(<span class="hljs-number">0</span>)<br>torch.cuda.manual_seed_all(<span class="hljs-number">0</span>)<br><br>torch.backends.cudnn.deterministic = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 固定一种算法</span><br>torch.backends.cudnn.benchmark = <span class="hljs-literal">False</span>  <span class="hljs-comment"># 每次算法都一样</span><br></code></pre></td></tr></table></figure><h2 id="数据增强库albumentations"><a href="#数据增强库albumentations" class="headerlink" title="数据增强库albumentations"></a>数据增强库albumentations</h2><h2 id="Annotations文件——-xml文件"><a href="#Annotations文件——-xml文件" class="headerlink" title="Annotations文件—— .xml文件"></a>Annotations文件—— .xml文件</h2><p>和ROS里面的xml语法类似，标签+属性组成；所以通常可看作树状结构，用xml.etree.ElementTree功能包进行处理</p><p> 以一张图片的annotation为例：</p><p><img src="/images/image-20210720205929371.png" alt="image-20210720205929371"></p><p>1）可见，有两个object标签，每个标签下又有<code>name</code>、<code>difficult</code>、<code>bndbox</code>等子标签</p><p>其中<code>difficult</code>标签表示物体是否难以识别，0代表容易；</p><p>关于VOC数据集标注的具体说明，见<a href="https://blog.csdn.net/Terry_n/article/details/81000458">voc2012中xml文档代码简单说明_Terry_n的博客-CSDN博客</a></p><h2 id="torch-clamp-函数"><a href="#torch-clamp-函数" class="headerlink" title="torch.clamp()函数"></a>torch.clamp()函数</h2><p>将输入<code>input</code>张量每个元素的夹紧到区间 [min,max][min,max]，并返回结果到一个新张量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.clamp(<span class="hljs-built_in">input</span>, <span class="hljs-built_in">min</span>, <span class="hljs-built_in">max</span>, out=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>实际操作如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">      | <span class="hljs-built_in">min</span>, <span class="hljs-keyword">if</span> x_i &lt; <span class="hljs-built_in">min</span><br>y_i = | x_i, <span class="hljs-keyword">if</span> <span class="hljs-built_in">min</span> &lt;= x_i &lt;= <span class="hljs-built_in">max</span><br>      | <span class="hljs-built_in">max</span>, <span class="hljs-keyword">if</span> x_i &gt; <span class="hljs-built_in">max</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Deep Learning-Objects Detection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Python_Related（一）</title>
    <link href="/2021/08/10/Python-Related%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/08/10/Python-Related%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本系列记录阅读源码过程中与<code>python内置库</code>相关的学习所得，遇到没见过的库、不懂的用法，都Google / 百度力求理解，然而好记性不如烂笔头，在take notes的过程中不仅加深印象，还能成为以后必要时的reference。</p><span id="more"></span><h2 id="python-os库"><a href="#python-os库" class="headerlink" title="python os库"></a>python os库</h2><p>参考：<a href="https://www.jb51.net/article/182302.htm">python标准库OS模块详解_python_脚本之家 (jb51.net)</a></p><h3 id="一、常用功能"><a href="#一、常用功能" class="headerlink" title="一、常用功能"></a>一、常用功能</h3><ol><li>os.name</li></ol><p>该属性宽泛地指明了当前 Python 运行所在的环境，可以理解为程序所在的系统名称；</p><p>目前有效名称为以下三个：posix，nt，java；</p><p>其中posix是 Portable Operating System Interface of UNIX（可移植操作系统接口）的缩写。Linux 和 Mac OS 均会返回该值；nt全称应为“Microsoft Windows NT”，大体可以等同于 Windows 操作系统，因此 Windows 环境下会返回该值；java则是 Java 虚拟机环境下的返回值。</p><ol start="2"><li>os.listdir()</li></ol><p>“listdir”即“list directories”，列出（当前）目录下的全部路径（及文件）。该函数存在一个参数，用以指定要列出子目录的路径，默认为“.”，即“当前路径”；</p><p>函数返回值是一个列表，其中各元素均为字符串，分别是各路径名和文件名；</p><p>通常在需要遍历某个文件夹中文件的场景下极为实用；</p><p>比如定义以下函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_filelists</span>(<span class="hljs-params">file_dir=<span class="hljs-string">&#x27;.&#x27;</span></span>):</span><br>  list_directory = os.listdir(file_dir)<br>  filelists = []<br>  <span class="hljs-keyword">for</span> directory <span class="hljs-keyword">in</span> list_directory:<br>    <span class="hljs-comment"># os.path 模块稍后会讲到</span><br>    <span class="hljs-keyword">if</span>(os.path.isfile(directory)):<br>      filelists.append(directory)<br>  <span class="hljs-keyword">return</span> filelists<br></code></pre></td></tr></table></figure><ol start="3"><li>os.mkdir()</li></ol><p>“mkdir”，即“make directory”，用处是“新建一个路径”。需要传入一个类路径参数用以指定新建路径的位置和名称，如果指定路径已存在，则会抛出FileExistsError异常。</p><p>相应地，在需要新建多级路径的场景下，可以使用os.makedirs()来完成任务。函数os.makedirs()执行的是递归创建，若有必要，会分别新建指定路径经过的中间路径，直到最后创建出末端的“叶子路径”。</p><p>示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>os.mkdir(<span class="hljs-string">&quot;test_os_mkdir&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>os.mkdir(<span class="hljs-string">&quot;test_os_mkdir&quot;</span>)<br>Traceback (most recent call last):<br> File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>FileExistsError: [WinError <span class="hljs-number">183</span>] 当文件已存在时，无法创建该文件。: <span class="hljs-string">&#x27;test_os_mkdir&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.mkdir(<span class="hljs-string">&quot;test_os_mkdir/test_os_makedirs/just/do/python/hello&quot;</span>)<br>Traceback (most recent call last):<br> File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>FileNotFoundError: [WinError <span class="hljs-number">3</span>] 系统找不到指定的路径。: <span class="hljs-string">&#x27;test_os_mkdir/test_os_makedirs/just/do/python/hello&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.makedirs(<span class="hljs-string">&quot;test_os_mkdir/test_os_makedirs/just/do/python/hello&quot;</span>)<br></code></pre></td></tr></table></figure><ol start="4"><li><h3 id="os-remove"><a href="#os-remove" class="headerlink" title="os.remove()"></a>os.remove()</h3></li></ol><p>用于删除文件，如果指定路径是目录而非文件的话，就会抛出IsADirectoryError异常。删除目录应该使用<strong>os.rmdir()函数</strong>。</p><ol start="5"><li><h3 id="os-rename"><a href="#os-rename" class="headerlink" title="os.rename()"></a>os.rename()</h3></li></ol><p>该函数的作用是将文件或路径重命名，一般调用格式为os.rename(src, dst)，即将src指向的文件或路径重命名为dst指定的名称。</p><ol start="6"><li><h3 id="os-getcwd"><a href="#os-getcwd" class="headerlink" title="os.getcwd()"></a>os.getcwd()</h3></li></ol><p>“getcwd”实际上是“get the current working directory”的简写，顾名思义，也就是说这个函数的作用是“获取当前工作路径”。在程序运行的过程中，无论物理上程序在实际存储空间的什么地方，“当前工作路径”即可认为是程序所在路径；与之相关的“相对路径”、“同目录下模块导入”等相关的操作均以“当前工作路径”为准。</p><p>在交互式环境中，返回的就是交互终端打开的位置；而在 Python 文件中，返回的则是文件所在的位置。</p><ol start="7"><li><h3 id="os-chdir"><a href="#os-chdir" class="headerlink" title="os.chdir()"></a>os.chdir()</h3></li></ol><p>“chdir”其实是“change the directory”的简写，因此os.chdir()的用处实际上是<strong>切换当前工作路径为指定路径</strong>。其中“指定路径”需要作为参数传入函数os.chdir()，该参数既可以是文本或字节型字符串，也可以是一个文件描述符，还可以是一个广义的类路径（path-like）对象。若指定路径不存在，则会抛出FileNotFoundError异常。</p><p>有了这个函数，跨目录读写文件和调用模块就会变得非常方便了，很多时候也就不必再反复将同一个文件在各个目录之间复制粘贴运行，<strong>脚本完全可以坐镇中军</strong>，<strong>在一个目录下完成对其他目录文件的操作</strong>，正所谓“运筹帷幄之中，决胜于千里之外”也。</p><h3 id="二、os-path模块"><a href="#二、os-path模块" class="headerlink" title="二、os.path模块"></a>二、os.path模块</h3><p>其实这个模块是os模块根据系统类型从另一个模块导入的，并非直接由os模块实现，比如os.name值为nt，则在os模块中执行import ntpath as path；如果os.name值为posix，则导入posixpath。</p><p>使用该模块要注意一个很重要的特性：os.path中的函数基本上是纯粹的字符串操作。换句话说，传入该模块函数的参数甚至不需要是一个有效路径，该模块也不会试图访问这个路径，而仅仅是按照“路径”的通用格式对字符串进行处理。</p><p>该模块的作用是让我们在实现相同功能的时候<strong>不必考虑具体的系统</strong>，尤其是<strong>不需要过多关注文件系统分隔符的问题</strong>。</p><ol><li><h3 id="os-path-join"><a href="#os-path-join" class="headerlink" title="os.path.join()"></a>os.path.join()</h3></li></ol><p>这是一个十分实用的函数，可以将<strong>多个传入路径组合为一个路径</strong>。</p><p>实际上是将传入的几个字符串用系统的分隔符连接起来，组合成一个新的字符串，所以一般的用法是将第一个参数作为父目录，之后每一个参数即使下一级目录，从而组合成一个新的符合逻辑的路径。</p><p>但如果传入路径中存在一个“绝对路径”格式的字符串，且这个字符串不是函数的第一个参数，那么其他在这个参数之前的所有参数都会被丢弃，余下的参数再进行组合。更准确地说，只有最后一个“绝对路径”及其之后的参数才会体现在返回结果中。（<strong>会自动识别根目录</strong>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.join(<span class="hljs-string">&quot;just&quot;</span>, <span class="hljs-string">&quot;do&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;dot&quot;</span>, <span class="hljs-string">&quot;com&quot;</span>)<br><span class="hljs-string">&#x27;just\\do\\python\\dot\\com&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.join(<span class="hljs-string">&quot;just&quot;</span>, <span class="hljs-string">&quot;do&quot;</span>, <span class="hljs-string">&quot;d:/&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;dot&quot;</span>, <span class="hljs-string">&quot;com&quot;</span>)<br><span class="hljs-string">&#x27;d:/python\\dot\\com&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.join(<span class="hljs-string">&quot;just&quot;</span>, <span class="hljs-string">&quot;do&quot;</span>, <span class="hljs-string">&quot;d:/&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;dot&quot;</span>, <span class="hljs-string">&quot;g:/&quot;</span>, <span class="hljs-string">&quot;com&quot;</span>)<br><span class="hljs-string">&#x27;g:/com&#x27;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><h3 id="os-path-abspath"><a href="#os-path-abspath" class="headerlink" title="os.path.abspath()"></a>os.path.abspath()</h3></li></ol><p>将传入路径规范化，返回一个相应的绝对路径格式的字符串。</p><p>也就是说当传入路径符合“绝对路径”的格式时，该函数仅仅将路径分隔符替换为适应当前系统的字符，不做其他任何操作，并将结果返回。所谓“绝对路径的格式”，其实指的就是一个字母加冒号，之后跟分隔符和字符串序列的格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.abspath(<span class="hljs-string">&quot;a:/just/do/python&quot;</span>)<br><span class="hljs-string">&#x27;a:\\just\\do\\python&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 我的系统中并没有 a 盘</span><br>    <span class="hljs-comment"># 根本不会检测路径的有效性，只是当成字符串呆板地处理</span><br></code></pre></td></tr></table></figure><ol start="3"><li><h3 id="os-path-basename"><a href="#os-path-basename" class="headerlink" title="os.path.basename()"></a>os.path.basename()</h3></li></ol><p>该函数返回传入路径的“基名”，即传入路径的最下级目录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.basename(<span class="hljs-string">&quot;/ityouknow/justdopython/IAmBasename&quot;</span>)<br><span class="hljs-string">&#x27;IAmBasename&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 我的系统中同样没有这么一个路径。可见 os.path.basename() 页是单纯进行字符串处理</span><br></code></pre></td></tr></table></figure><ol start="4"><li><h3 id="os-path-dirname"><a href="#os-path-dirname" class="headerlink" title="os.path.dirname()"></a>os.path.dirname()</h3></li></ol><p>与上一个函数正好相反，返回的是最后一个分隔符前的整个字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.dirname(<span class="hljs-string">&quot;/ityouknow/justdopython/IAmBasename&quot;</span>)<br><span class="hljs-string">&#x27;/ityouknow/justdopython&#x27;</span><br></code></pre></td></tr></table></figure><ol start="5"><li><h3 id="os-path-split"><a href="#os-path-split" class="headerlink" title="os.path.split()"></a>os.path.split()</h3></li></ol><p>哈哈实际上前两个函数都是弟弟，这个函数才是老大。</p><p>函数os.path.split()的功能就是将传入路径以最后一个分隔符为界，分成两个字符串，并打包成元组的形式返回；前两个函数os.path.dirname()和os.path.basename()的返回值分别是函数os.path.split()返回值的第一个、第二个元素。就连二者的具体实现都十分真实：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">basename</span>(<span class="hljs-params">p</span>):</span><br>  <span class="hljs-string">&quot;&quot;&quot;Returns the final component of a pathname&quot;&quot;&quot;</span><br>  <span class="hljs-keyword">return</span> split(p)[<span class="hljs-number">1</span>]<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dirname</span>(<span class="hljs-params">p</span>):</span><br>  <span class="hljs-string">&quot;&quot;&quot;Returns the directory component of a pathname&quot;&quot;&quot;</span><br>  <span class="hljs-keyword">return</span> split(p)[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>通过os.path.join()函数又可以把它们组合起来得到原先的路径。</p><ol start="6"><li><h3 id="os-path-exists"><a href="#os-path-exists" class="headerlink" title="os.path.exists()"></a>os.path.exists()</h3></li></ol><p>用于判断路径<strong>所指向的位置是否存在</strong>。若存在则返回True，不存在则返回False：</p><p>一般的用法是在需要持久化保存某些数据的场景，为避免重复创建某个文件，需要在写入前用该函数检测一下相应文件是否存在，若不存在则新建，若存在则在文件内容之后增加新的内容。</p><ol start="7"><li><h3 id="os-path-isabs"><a href="#os-path-isabs" class="headerlink" title="os.path.isabs()"></a>os.path.isabs()</h3></li></ol><p>该函数判断传入路径是否是绝对路径，若是则返回True，否则返回False。当然，仅仅是检测格式，同样不对其有效性进行任何核验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.isabs(<span class="hljs-string">&quot;a:/justdopython&quot;</span>)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><ol start="8"><li><h3 id="os-path-isfile-和-os-path-isdir"><a href="#os-path-isfile-和-os-path-isdir" class="headerlink" title="os.path.isfile() 和 os.path.isdir()"></a>os.path.isfile() 和 os.path.isdir()</h3></li></ol><p>这两个函数分别判断传入路径是否是文件或路径，注意，<strong>此处会核验路径的有效性</strong>，如果是无效路径将会持续返回False。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 无效路径</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.isfile(<span class="hljs-string">&quot;a:/justdopython&quot;</span>)<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 有效路径</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.isfile(<span class="hljs-string">&quot;./just/plain_txt&quot;</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 无效路径</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.isdir(<span class="hljs-string">&quot;a:/justdopython/&quot;</span>)<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># 有效路径</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>os.path.isdir(<span class="hljs-string">&quot;./just/&quot;</span>)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>补充：os.environ()</p><p>在 python 中通过 os.environ 可以获取有关系统的各种信息.</p><p>通过 os.environ 获取环境变量，什么是环境变量呢？环境变量是程序和操作系统之间的通信方式。有些字符不宜明文写进代码里，比如数据库密码，个人账户密码，如果写进自己本机的环境变量里，程序用的时候通过 os.environ.get() 取出来就行了。这样开发人员本机测试的时候用的是自己本机的一套密码，生产环境部署的时候，用的是公司的公共账号和密码，这样就能增加安全性。</p><p><strong>os.environ 是一个字典，是环境变量的字典</strong>。</p><p>具体操作参考：<a href="https://blog.csdn.net/happyjacob/article/details/109279118"><a href="https://blog.csdn.net/happyjacob/article/details/109279118">os.environ模块环境变量详解_桑凯旋的博客-CSDN博客</a></a></p><h2 id="python字符串格式化"><a href="#python字符串格式化" class="headerlink" title="python字符串格式化"></a>python字符串格式化</h2><p>何谓字符串格式化？</p><p>1）将变量、对象的值填充到字符串中</p><p>2）在字符串中解析python表达式</p><p>3）对字符串进行格式化显示——左对齐、右对齐等、保留有效位数等</p><p>方法：</p><ol><li>%格式化</li></ol><p>1）使用变量来代替字符串中的%s</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;可优&quot;</span><br>lover = <span class="hljs-string">&quot;柠檬小姐姐&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;%s爱上了%s！&quot;</span> %(name, lover))<span class="hljs-comment"># 变量name与lover会以一一对应的形式来填充%s</span><br></code></pre></td></tr></table></figure><p>2）保留有效位数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pi = <span class="hljs-number">3.14159265359</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;圆周率（%.5f）有多长，爱你就有多深！&quot;</span> %(pi, )) <span class="hljs-comment">#浮点类型的变量，保留5位小数</span><br></code></pre></td></tr></table></figure><ol start="2"><li>format格式化</li></ol><p>1）使用变量来替换字符串中的{}</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;可优&quot;</span><br>lover = <span class="hljs-string">&quot;柠檬小姐姐&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;&#123;&#125;爱上了&#123;&#125;！&quot;</span>.<span class="hljs-built_in">format</span>(name, lover))<span class="hljs-comment"># 变量name与lover会以一一对应的形式来&#123;&#125;</span><br></code></pre></td></tr></table></figure><p>2）保留有效位数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pi = <span class="hljs-number">3.14159265359</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;圆周率&#123;:.5f&#125;有多长，爱你就有多深！&quot;</span>.<span class="hljs-built_in">format</span>(pi, )) <span class="hljs-comment"># 将浮点类型的变量，保留5位小数 </span><br></code></pre></td></tr></table></figure><ol start="3"><li><p>字符串对齐</p></li><li><p><strong>f字符串</strong>格式化</p></li></ol><p>在<strong>字符串前面添加了一个f之后</strong>，即为f字符串，可以在字符串中解析变量、运行python表达式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&quot;可优&quot;</span><br>lover = <span class="hljs-string">&quot;柠檬小姐姐&quot;</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span>爱上了<span class="hljs-subst">&#123;lover&#125;</span>！&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 运行python表达式</span><br><span class="hljs-keyword">import</span> random<br><br>love_times = random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br>name = <span class="hljs-string">&quot;可优&quot;</span><br>lover = <span class="hljs-string">&quot;柠檬小姐姐&quot;</span><br>sea = <span class="hljs-string">&quot;🌊&quot;</span><br>tortoise = <span class="hljs-string">&quot;🐢&quot;</span><br><span class="hljs-comment"># 可以在f字符串中，计算Python中的表达式</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span>对<span class="hljs-subst">&#123;lover&#125;</span>的爱，犹如滔滔江水绵绵不绝！<span class="hljs-subst">&#123;sea * <span class="hljs-number">3</span>&#125;</span>\n如果实在要加一个期限的话，我想是<span class="hljs-subst">&#123;love_times + <span class="hljs-number">10000</span>&#125;</span>年！<span class="hljs-subst">&#123;tortoise * <span class="hljs-number">3</span>&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取字典的值</span><br>self_info = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;可优&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">17</span>, <span class="hljs-string">&quot;lover&quot;</span>: <span class="hljs-string">&quot;柠檬小姐姐&quot;</span>&#125;<br><span class="hljs-comment"># 在f字符串中，获取字典的值</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;姓名: <span class="hljs-subst">&#123;self_info[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span>\n芳年: <span class="hljs-subst">&#123;self_info[<span class="hljs-string">&#x27;age&#x27;</span>]&#125;</span>\n爱人: <span class="hljs-subst">&#123;self_info[<span class="hljs-string">&#x27;lover&#x27;</span>]&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="tqdm进度条美化模块"><a href="#tqdm进度条美化模块" class="headerlink" title="tqdm进度条美化模块"></a>tqdm进度条美化模块</h2><p>只了解基本使用</p><p>tqdm是Python中专门用于进度条美化的模块，通过在非while的循环体内嵌入tqdm，可以得到一个能更好展现程序运行过程的提示进度条，本文就将针对tqdm的基本用法进行介绍。</p><p>基本用法：</p><p>在for循环体中用tqdm()包裹指定的迭代器或range()即可，下面是两个简单的例子：</p><ol><li>列表迭代器</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> time<br><br>text = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> tqdm([<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>]):<br>    time.sleep(<span class="hljs-number">0.25</span>)<br>    text = text + char<br>    <br><span class="hljs-built_in">print</span>(text)<br></code></pre></td></tr></table></figure><img src="/images/1344061-20190131214721175-918025861.png" alt="img" style="zoom:80%;"><p>2） range()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> it <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)):<br>    time.sleep(<span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><img src="/images/1344061-20190131214812656-1329418497.png" alt="img" style="zoom:67%;"><ol start="3"><li>使用trange，作为tqdm(range())的简洁替代</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> trange<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> trange(<span class="hljs-number">100</span>):<br>    time.sleep(<span class="hljs-number">0.01</span>)<br></code></pre></td></tr></table></figure><img src="/images/1344061-20190131214935098-1691543245.png" alt="img" style="zoom:50%;"><p>注：在tqdm的循环中，最好所有的print都用 tqdm.write() 替代，否则进度条会有错误</p><h2 id="python类-面向对象"><a href="#python类-面向对象" class="headerlink" title="python类 面向对象"></a>python类 面向对象</h2><p>参考：廖雪峰python教程<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017496031185408">类和实例 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><p>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<code>__init__</code>方法，在创建实例的时候，就把<code>name</code>，<code>score</code>等属性绑上去</p><p>注：判断一个变量是否是某个类型可以用<code>isinstance()</code>判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">isinstance</span>(a,<span class="hljs-built_in">list</span>)<br></code></pre></td></tr></table></figure><ol><li>特殊类方法—— <strong>getitem</strong>   </li></ol><p>?</p><h2 id="Python异常处理——-try-except-finally"><a href="#Python异常处理——-try-except-finally" class="headerlink" title="Python异常处理—— try-except-finally"></a>Python异常处理—— try-except-finally</h2><ol><li>try-except</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:  <br>    <span class="hljs-comment">## normal block  </span><br><span class="hljs-keyword">except</span> A:  <br>    <span class="hljs-comment">## exc A block  </span><br><span class="hljs-keyword">except</span>:  <br>    <span class="hljs-comment">## exc other block  </span><br><span class="hljs-keyword">else</span>:  <br>    <span class="hljs-comment">## noError block  </span><br></code></pre></td></tr></table></figure><p>–&gt;执行normal block<br>–&gt;发现有A错误，执行 exc A block(即处理异常)<br>–&gt;结束</p><p>如果没有A错误呢？<br>–&gt;执行normal block<br>–&gt;发现B错误，开始寻找匹配B的异常处理方法，发现A，跳过，发现except others(即except:)，执行exc other block<br>–&gt;结束</p><p>如果没有错误呢？<br>–&gt;执行normal block<br>–&gt;全程没有错误，跳入else 执行noError block<br>–&gt;结束</p><p>对于except后面跟的表达式，其实就是错误的定义，可以跟2种：1）python标准异常  2）自定义异常</p><ol start="2"><li>try-except-finally</li></ol><p>实质上就是不管执行过程中有没有异常，都要执行清场工作，执行finally后面的语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:  <br>    execution block  <span class="hljs-comment">##正常执行模块  </span><br><span class="hljs-keyword">except</span> A:  <br>    exc A block <span class="hljs-comment">##发生A错误时执行  </span><br><span class="hljs-keyword">except</span> B:  <br>    exc B block <span class="hljs-comment">##发生B错误时执行  </span><br><span class="hljs-keyword">except</span>:  <br>    other block <span class="hljs-comment">##发生除了A,B错误以外的其他错误时执行  </span><br><span class="hljs-keyword">else</span>:  <br>    <span class="hljs-keyword">if</span> no exception, jump to here <span class="hljs-comment">##没有错误时执行  </span><br><span class="hljs-keyword">finally</span>:  <br>    final block  <span class="hljs-comment">##总是执行  </span><br></code></pre></td></tr></table></figure><h2 id="Python-with语句"><a href="#Python-with语句" class="headerlink" title="Python with语句"></a>Python with语句</h2><p>在实际的编码过程中，有时有一些任务，需要事先做一些设置，事后做一些清理，with能够对这样的需求进行一个比较优雅的处理，最常用的例子就是对<strong>访问文件</strong>的处理。</p><p>文件读写初级：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span> f = <span class="hljs-built_in">open</span>(<span class="hljs-string">r&#x27;c:\mytest.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-number">2</span> data = f.read()<br><span class="hljs-number">3</span> f.close()<br><br><span class="hljs-comment"># 读写时未异常处理</span><br><span class="hljs-comment"># 有可能会忘记关闭文件</span><br></code></pre></td></tr></table></figure><p>文件读写中级：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span>  f = <span class="hljs-built_in">open</span>(<span class="hljs-string">r&#x27;c:\mytest.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <br><span class="hljs-number">2</span> <span class="hljs-keyword">try</span>: <br><span class="hljs-number">3</span>     data = f.read() <br><span class="hljs-number">4</span> <span class="hljs-keyword">finally</span>: <br><span class="hljs-number">5</span>     f.close()<br><br><span class="hljs-comment"># 解决了忘记关闭文件的问题</span><br></code></pre></td></tr></table></figure><p>文件读写高级：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1</span> <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">r&#x27;c:\test.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br><span class="hljs-number">2</span>     data = f.read()<br><br><span class="hljs-comment"># 简洁、高效</span><br></code></pre></td></tr></table></figure><p>说明：</p><p>with后面接的对象返回的结果赋值给f。此例当中open函数返回的文件对象赋值给了f；with会自已获取上下文件的异常信息。</p><p>with后面返回的对象要求必须有两个方法：<code>__enter__()</code>/<code>__exit__()</code></p><p><strong>with…as语句执行顺序：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> expression <span class="hljs-keyword">as</span> variable<br></code></pre></td></tr></table></figure><p>–&gt;首先执行expression里面的__enter__函数，它的返回值会赋给as后面的variable，想让它返回什么就返回什么，只要你知道怎么处理就可以了，如果不写as variable，返回值会被忽略。</p><p>–&gt;然后，开始执行with-block中的语句，不论成功失败(比如发生异常、错误，设置sys.exit())，在with-block执行完成后，会执行expression中的__exit__函数。</p><p><code>with</code>通常用作上下文管理器，简单理解：当要进行固定的进入、返回操作时，<strong>可以将对应需要的操作，放在with语句块中</strong>。 比如文件的读写等。</p><p>通常在pytorch中常用语句：<code>with torch.no_grad:</code></p><p>pytorch中对于tensor的计算操作，默认是要进行计算图构建的；但是有些情况下(evaluation)是不需要生成计算图的，在这种情况下可以使用<code>with torch.no_grad:</code>，强制之后的内容不进行计算图构建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> torch.no_grad:<br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> testloader:<br>        images, labels = data<br>        outputs = net(images)<br>        _, predicted = torch.<span class="hljs-built_in">max</span>(outputs.data, <span class="hljs-number">1</span>)<br>        total += labels.size(<span class="hljs-number">0</span>)<br>        correct += (predicted == labels).<span class="hljs-built_in">sum</span>().item()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Accuracy of the network on the 10000 test images: %d %%&#x27;</span> % (<br>    <span class="hljs-number">100</span> * correct / total))        <br><span class="hljs-built_in">print</span>(outputs)<br><br><span class="hljs-comment"># 此时的outputs是没有grad属性的！</span><br></code></pre></td></tr></table></figure><h2 id="Python函数装饰器"><a href="#Python函数装饰器" class="headerlink" title="Python函数装饰器"></a>Python函数装饰器</h2><p>装饰器是修改其他函数功能的函数，有助于让代码更简洁。</p><p>理解装饰器比较难，首先从“函数”开始逐步理解：</p><p>1.函数基础</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hi</span>(<span class="hljs-params">name=<span class="hljs-string">&quot;yasoob&quot;</span></span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hi &quot;</span> + name<br> <br><span class="hljs-built_in">print</span>(hi())<br><span class="hljs-comment"># output: &#x27;hi yasoob&#x27;</span><br> <br><span class="hljs-comment"># 我们甚至可以将一个函数赋值给一个变量，比如</span><br>greet = hi<br><span class="hljs-comment"># 我们这里没有在使用小括号，因为我们并不是在调用hi函数</span><br><span class="hljs-comment"># 而是在将它放在greet变量里头。我们尝试运行下这个</span><br> <br><span class="hljs-built_in">print</span>(greet())<br><span class="hljs-comment"># output: &#x27;hi yasoob&#x27;</span><br> <br><span class="hljs-comment"># 如果我们删掉旧的hi函数，看看会发生什么！</span><br><span class="hljs-keyword">del</span> hi<br><span class="hljs-built_in">print</span>(hi())<br><span class="hljs-comment">#outputs: NameError</span><br> <br><span class="hljs-built_in">print</span>(greet())<br><span class="hljs-comment">#outputs: &#x27;hi yasoob&#x27;</span><br></code></pre></td></tr></table></figure><p>2.在函数中定义函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hi</span>(<span class="hljs-params">name=<span class="hljs-string">&quot;yasoob&quot;</span></span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;now you are inside the hi() function&quot;</span>)<br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>():</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;now you are in the greet() function&quot;</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">welcome</span>():</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;now you are in the welcome() function&quot;</span><br> <br>    <span class="hljs-built_in">print</span>(greet())<br>    <span class="hljs-built_in">print</span>(welcome())<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;now you are back in the hi() function&quot;</span>)<br> <br>hi()<br><span class="hljs-comment">#output:now you are inside the hi() function</span><br><span class="hljs-comment">#       now you are in the greet() function</span><br><span class="hljs-comment">#       now you are in the welcome() function</span><br><span class="hljs-comment">#       now you are back in the hi() function</span><br> <br><span class="hljs-comment"># 上面展示了无论何时你调用hi(), greet()和welcome()将会同时被调用。</span><br><span class="hljs-comment"># 然后greet()和welcome()函数在hi()函数之外是不能访问的，比如：</span><br> <br>greet()<br><span class="hljs-comment">#outputs: NameError: name &#x27;greet&#x27; is not defined</span><br></code></pre></td></tr></table></figure><p>3.从函数中返回函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hi</span>(<span class="hljs-params">name=<span class="hljs-string">&quot;yasoob&quot;</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>():</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;now you are in the greet() function&quot;</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">welcome</span>():</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;now you are in the welcome() function&quot;</span><br> <br>    <span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;yasoob&quot;</span>:<br>        <span class="hljs-keyword">return</span> greet<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> welcome<br> <br>a = hi()<br><span class="hljs-built_in">print</span>(a)<br><span class="hljs-comment">#outputs: &lt;function greet at 0x7f2143c01500&gt;</span><br> <br><span class="hljs-comment">#上面清晰地展示了`a`现在指向到hi()函数中的greet()函数</span><br><span class="hljs-comment">#现在试试这个</span><br> <br><span class="hljs-built_in">print</span>(a())<br><span class="hljs-comment">#outputs: now you are in the greet() function</span><br></code></pre></td></tr></table></figure><p>再次看看这个代码。在 if/else 语句中我们返回 greet 和 welcome，而不是 greet() 和 welcome()。为什么那样？这是因为当你把一对小括号放在后面，这个函数就会执行；然而<strong>如果你不放括号在它后面，那它可以被到处传递</strong>，并且可以赋值给别的变量而不去执行它。</p><p>4.将函数作为参数传给另一个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hi</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hi yasoob!&quot;</span><br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doSomethingBeforeHi</span>(<span class="hljs-params">func</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am doing some boring work before executing hi()&quot;</span>)<br>    <span class="hljs-built_in">print</span>(func())<br> <br>doSomethingBeforeHi(hi)<br><span class="hljs-comment">#outputs:I am doing some boring work before executing hi()</span><br><span class="hljs-comment">#        hi yasoob!</span><br></code></pre></td></tr></table></figure><p>在外层函数的内部，参数仍然作为函数使用</p><p>5.你的第一个装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a_new_decorator</span>(<span class="hljs-params">a_func</span>):</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapTheFunction</span>():</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am doing some boring work before executing a_func()&quot;</span>)<br> <br>        a_func()<br> <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am doing some boring work after executing a_func()&quot;</span>)<br> <br>    <span class="hljs-keyword">return</span> wrapTheFunction<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a_function_requiring_decoration</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am the function which needs some decoration to remove my foul smell&quot;</span>)<br> <br>a_function_requiring_decoration()<br><span class="hljs-comment">#outputs: &quot;I am the function which needs some decoration to remove my foul smell&quot;</span><br> <br>a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)<br><span class="hljs-comment">#now a_function_requiring_decoration is wrapped by wrapTheFunction()</span><br> <br>a_function_requiring_decoration()<br><span class="hljs-comment">#outputs:I am doing some boring work before executing a_func()</span><br><span class="hljs-comment">#        I am the function which needs some decoration to remove my foul smell</span><br><span class="hljs-comment">#        I am doing some boring work after executing a_func()</span><br></code></pre></td></tr></table></figure><p>你看明白了吗？我们刚刚应用了之前学习到的原理。这正是 python 中装饰器做的事情！它们封装一个函数，并且用这样或者那样的方式来修改它的行为。现在你也许疑惑，我们在代码里并没有使用 <strong>@</strong> 符号？那只是一个简短的方式来生成一个被装饰的函数。这里是我们如何使用 <strong>@</strong> 来运行之前的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@a_new_decorator</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a_function_requiring_decoration</span>():</span><br>    <span class="hljs-string">&quot;&quot;&quot;Hey you! Decorate me!&quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am the function which needs some decoration to &quot;</span><br>          <span class="hljs-string">&quot;remove my foul smell&quot;</span>)<br> <br>a_function_requiring_decoration()<br><span class="hljs-comment">#outputs: I am doing some boring work before executing a_func()</span><br><span class="hljs-comment">#         I am the function which needs some decoration to remove my foul smell</span><br><span class="hljs-comment">#         I am doing some boring work after executing a_func()</span><br> <br><span class="hljs-comment">#the @a_new_decorator is just a short way of saying:</span><br>a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)<br></code></pre></td></tr></table></figure><p>装饰器常见的应用场景：授权（web应用的端点，在Flask、Django web框架中大量使用）、日志Logging等</p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning-Objects Detection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>系统学习ROS（六）</title>
    <link href="/2021/05/21/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ROS%EF%BC%88%E5%85%AD%EF%BC%89/"/>
    <url>/2021/05/21/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ROS%EF%BC%88%E5%85%AD%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>服务于上层应用，导航功能是十分重要且基础的功能之一，ROS中的Gmapping包可以方便地实现导航功能。导航不是单一的功能，它由多个分解的子功能组成，本文进行简单概述并介绍地图服务。</p><span id="more"></span><h2 id="十一、机器人导航"><a href="#十一、机器人导航" class="headerlink" title="十一、机器人导航"></a>十一、机器人导航</h2><p>一、ROS导航功能包简介</p><p>1.总结下来，涉及的关键技术有如下五点:</p><ol><li>全局地图</li><li>自身定位</li><li>路径规划</li><li>运动控制</li><li>环境感知</li></ol><p>2.ROS官方提供的导航功能包图示：</p><p><img src="/images/image-20210521191104511.png" alt="image-20210521191104511"></p><p>（方框中都是ROS功能包，白色必须、灰色可选、蓝色是机器人硬件提供的）</p><p>（1）全局地图：右上角的<strong>map_server</strong>用于提供全局地图，但是需要先画一张地图–&gt;<strong>SLAM</strong>；</p><p>（2）自身定位：左侧<strong>amcl+sensor transforms</strong>: 用传感器感知到的的周边信息，与全局地图匹配;</p><p>​                                            <strong>odometry source</strong>: 用里程计估算机器人位置</p><p>​                                如果在室外，那么可用GPS直接实现定位；但在室内就要依赖上面的amcl或odometry；</p><p>（3）路径规划：中间的move_base；</p><pre><code>     路径规划分为两种：1.**全局**路径规划：**global_planner**，基于全局地图的；</code></pre><p>​                     2.<strong>本地</strong>路径规划：<strong>local_planner</strong>，基于传感器实时感知到的小范围的地图；–&gt;帮助机器人<strong>躲避动态障碍物</strong></p><p>（4）运动控制：下面的base controller</p><p>（5）环境感知：右边的sensor sources； 在本地路径规划(避障)、SLAM中用到。</p><h3 id="3-上述功能中，绘制地图的工具——SLAM"><a href="#3-上述功能中，绘制地图的工具——SLAM" class="headerlink" title="3.上述功能中，绘制地图的工具——SLAM"></a>3.上述功能中，绘制地图的工具——SLAM</h3><p>（1）在 ROS 中，较为常用的 SLAM 实现也比较多，比如: gmapping、hector_slam、cartographer、rgbdslam、ORB_SLAM ….</p><p>（2）当然如果要完成 SLAM ，<strong>机器人必须要具备感知外界环境的能力</strong>，尤其是要具备获取周围环境<strong>深度信息</strong>的能力。感知的实现需要依赖于传感器，比如: 激光雷达、摄像头、RGB-D摄像头…</p><p>（3）SLAM 可以用于地图生成，而生成的地图还需要被保存以待后续使用，在 <strong>ROS 中保存地图的功能包是 map_server</strong></p><p>（4）辨析：SLAM不等于导航，SLAM只是实现地图构建和即使定位，是导航功能中的重要一环。</p><p>二、导航中的坐标系</p><p>1.简介</p><p>通常，以机器人的出发点为原点创建坐标系，但是这个这个坐标系不是客观存在的，定位实现需要依赖于机器人自身，机器人需要<strong>逆向推导参考系原点</strong>并<strong>计算坐标系相对关系</strong></p><p>两种方式：</p><p>（1）通过<strong>里程计</strong>定位:时时收集机器人的速度信息计算并发布机器人坐标系与父级参考系的相对关系；</p><p>​                通俗解释：里程计的速度*走过的时间=现在离原点的距离</p><p>​                缺点:里程计存在<strong>累计误差</strong>，不利于长距离或长期定位</p><p>（2）通过<strong>传感器</strong>定位:通过传感器收集外界环境信息通过匹配计算并发布机器人坐标系与父级参考系的相对关系。</p><p>​                缺点:传感器定位会出现跳变的情况，且传感器定位在<strong>标志物较少的环境下，其定位精度会大打折扣</strong></p><p>2.导航中的坐标系变换</p><p>不管使用哪种定位实现，最终都要发布<strong>机器人坐标系</strong>与其<strong>父级坐标系</strong>的相对关系；</p><p>（1）机器人坐标系：使用机器人模型中的根坐标系(base_link或base_footprint)</p><p>（2）父级坐标系：里程计定位时odom；传感器定位时map；</p><p>​            一般的继承关系：<strong>map/odom</strong> —&gt; <strong>base_link/base_footprint</strong> —&gt; laser、camera、wheel等一堆</p><p>​            当里程计和传感器<strong>结合使用</strong>时，将map设置为odom的父级：</p><p>​                                                <strong>map</strong> —&gt; <strong>odom</strong> —&gt; <strong>base_link/base_footprint</strong> —&gt; laser、camera、wheel等一堆</p><p>3.导航条件说明</p><p>（1）它是为<strong>差速驱动的轮式机器人</strong>设计的：它假设底盘受到理想的运动命令的控制并可实现预期的结果，命令的格式为：x速度分量，y速度分量，角速度(theta)分量</p><p>（2）它需要在底盘上安装一个<strong>单线激光雷达</strong>。这个激光雷达用于构建地图和定位</p><h3 id="三、导航实现"><a href="#三、导航实现" class="headerlink" title="三、导航实现"></a>三、导航实现</h3><p>1.SLAM建图：需要键盘控制机器人运动，逐步建图</p><p>  <strong>探索式的</strong>SLAM建图：给机器人一个大致目标，机器人自己规划路径过去</p><p>2.准备工作</p><p>（1）安装功能包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">sudo  apt  install  ros-melodic-gmapping  <span class="hljs-comment">#SLAM建图</span><br>sudo  apt  install  ros-melodic-<span class="hljs-built_in">map</span>-server  <span class="hljs-comment">#保存、读取地图</span><br>sudo  apt  install  ros-melodic-navigation  <span class="hljs-comment">#定位、路径规划</span><br></code></pre></td></tr></table></figure><p>（2）创建功能包，导入依赖：<code>gmapping</code>  <code>map_server</code>  <code>amcl</code>  <code>move_base</code></p><p><strong>3.gmapping</strong></p><p>（1）gmapping可以根据移动机器人里程计数据和激光雷达数据来绘制二维的栅格地图，gmapping对硬件也有一定的要求：</p><ul><li>该移动机器人可以发布<strong>里程计消息</strong></li><li>机器人需要发布<strong>雷达消息</strong>(该消息可以通过水平固定安装的雷达发布，或者也可以将<strong>深度相机消息</strong>转换成雷达消息)</li></ul><p>（2）gmapping节点说明</p><p>核心节点：<strong>slam_gmapping</strong> (简略说明)</p><ul><li><p>订阅的Topic</p></li><li><p>发布的Topic</p></li></ul><p>​        map_metadata: 地图元数据，包括地图的宽度、高度、分辨率等</p><p>​        map: 地图栅格数据; 在Rviz中订阅它！</p><p>​        ~entropy：机器人姿态分布熵估计(值越大，不确定性越大)</p><ul><li>参数</li><li>所需要的坐标变换</li><li>发布的坐标变换</li></ul><p>参考官网：<a href="http://wiki.ros.org/gmapping">http://wiki.ros.org/gmapping</a>  里面有众多参数，需要了解底层原理才能设置；否则使用默认值即可。</p><p>（3）gmapping节点相关的launch文件编写</p><p>可以参考 github 的演示 launch文件：<a href="https://github.com/ros-perception/slam_gmapping/blob/melodic-devel/gmapping/launch/slam_gmapping_pr2.launch">https://github.com/ros-perception/slam_gmapping/blob/melodic-devel/gmapping/launch/slam_gmapping_pr2.launch</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;use_sim_time&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!-- 是否为仿真环境；是则设置为true --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;gmapping&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;slam_gmapping&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slam_gmapping&quot;</span> <span class="hljs-attr">output</span>=<span class="hljs-string">&quot;screen&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">remap</span> <span class="hljs-attr">from</span>=<span class="hljs-string">&quot;scan&quot;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;scan&quot;</span>/&gt;</span>   <span class="hljs-comment">&lt;!-- 雷达话题 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;map_update_interval&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5.0&quot;</span>/&gt;</span>  <span class="hljs-comment">&lt;!-- 每5s更新一次地图 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxUrange&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16.0&quot;</span>/&gt;</span>  <span class="hljs-comment">&lt;!-- 雷达最长探测距离 --&gt;</span><br>        <br>       <span class="hljs-comment">&lt;!-- 关键参数：坐标系 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;base_frame&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;base_footprint&quot;</span>/&gt;</span><span class="hljs-comment">&lt;!--底盘坐标系；如果用的是base_link，则要修改--&gt;</span> <br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;odom_frame&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;odom&quot;</span>/&gt;</span> <span class="hljs-comment">&lt;!--里程计坐标系--&gt;</span><br>        <br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sigma&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.05&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;kernelSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lstep&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.05&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;astep&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.05&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;iterations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;5&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lsigma&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.075&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ogain&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3.0&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lskip&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;srr&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.1&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;srt&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.2&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;str&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.1&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;stt&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.2&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;linearUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1.0&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;angularUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.5&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;temporalUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3.0&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;resampleThreshold&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.5&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;particles&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;30&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;xmin&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;-50.0&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ymin&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;-50.0&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;xmax&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;50.0&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ymax&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;50.0&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;delta&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.05&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;llsamplerange&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.01&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;llsamplestep&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.01&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lasamplerange&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.005&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lasamplestep&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.005&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">node</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 坐标变换关系发布节点--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;rviz&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;rviz&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;rviz&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 可以保存 rviz 配置并后期直接使用--&gt;</span>s<br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    &lt;node pkg=&quot;rviz&quot; type=&quot;rviz&quot; name=&quot;rviz&quot; args=&quot;-d $(find my_nav_sum)/rviz/gmapping.rviz&quot;/&gt;</span><br><span class="hljs-comment">    --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><p>（4）启动建图仿真</p><p>1.首先启动之前编写好的机器人节点（配有雷达）</p><p>2.启动Rviz（已集成在上述gmapping的launch文件中），添加<code>RobotModel</code>、<code>LaserScan</code>插件，添加<code>Map</code>插件并将话题设置为<code>map</code>（gmapping节点自己发布的话题） —&gt;配置好之后可以保存配置，方便后续复用</p><p>3.配置启动完成后，启动键盘控制节点，控制机器人运动，进行建图</p><p>4.map_server</p><p>当节点关闭时，数据也会被一并释放，我们需要将栅格地图<strong>序列化</strong>到的磁盘以持久化存储，后期还要通过<strong>反序列化</strong>读取磁盘的地图数据再执行后续操作；</p><p>map_server功能包中提供了两个节点: </p><p>（1） map_saver ，用于将栅格地图保存到磁盘</p><p>订阅的topic：map(nav_msgs/OccupancyGrid)</p><p>地图保存的launch文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;filename&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$(find mycar_nav)/map/nav&quot;</span> /&gt;</span>  <span class="hljs-comment">&lt;!-- value 指定保存的路径 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;map_save&quot;</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;map_server&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;map_saver&quot;</span> <span class="hljs-attr">args</span>=<span class="hljs-string">&quot;-f $(arg filename)&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><p>修改value指定的路径即可，其他不用改</p><p>保存结果解释：</p><p>xxx.pgm 本质是一张图片，直接使用图片查看程序即可打开。</p><p>xxx.yaml 保存的是地图的元数据信息，用于描述图片，其格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#1.图片路径</span><br>image: /home/rosmelodic/ws02_nav/src/mycar_nav/<span class="hljs-built_in">map</span>/nav.pgm<br><span class="hljs-comment">#2.地图刻度尺，单位：米/像素</span><br>resolution: <span class="hljs-number">0.050000</span><br><span class="hljs-comment">#3.地图的位姿：想对于rviz中原点的位姿</span><br>origin: [-<span class="hljs-number">50.000000</span>, -<span class="hljs-number">50.000000</span>, <span class="hljs-number">0.000000</span>]<br><span class="hljs-comment">#4.取反（黑变白，白变黑）</span><br>negate: <span class="hljs-number">0</span><br><span class="hljs-comment">#5.占用阈值</span><br>occupied_thresh: <span class="hljs-number">0.65</span><br><span class="hljs-comment">#6.空闲阈值</span><br>free_thresh: <span class="hljs-number">0.196</span>            <span class="hljs-comment">#5、6一起决定障碍物</span><br></code></pre></td></tr></table></figure><p>（2） map_server，读取磁盘的栅格地图并以服务的方式提供出去。</p><p>launch文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 设置地图的配置文件 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;map&quot;</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;nav.yaml&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 运行地图服务器，并且加载设置的地图--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;map_server&quot;</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;map_server&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;map_server&quot;</span> <span class="hljs-attr">args</span>=<span class="hljs-string">&quot;$(find mycar_nav)/map/$(arg map)&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后在rviz中使用map组建订阅map话题即可看见地图</p>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>系统学习ROS（五）</title>
    <link href="/2021/05/21/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ROS%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2021/05/21/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ROS%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>学习了URDF语法以及Xacro优化之后，本文介绍URDF集成Gazebo以及URDF、Gazebo与Rviz的综合使用。</p><span id="more"></span><h2 id="URDF集成Gazebo"><a href="#URDF集成Gazebo" class="headerlink" title="URDF集成Gazebo"></a>URDF集成Gazebo</h2><p>一、基本集成流程</p><p>1.创建功能包，依赖包有: urdf、xacro、gazebo_ros、gazebo_ros_control、gazebo_plugins</p><p>2.当 URDF 需要与 Gazebo 集成时，<strong>和 Rviz 有明显区别:</strong></p><ul><li><p>必须使用 <strong>collision 标签</strong>，因为既然是仿真环境，那么必然涉及到碰撞检测，collision 提供碰撞检测的依据。</p></li><li><p>必须使用 <strong>inertial 标签</strong>，此标签标注了当前机器人某个刚体部分的惯性矩阵，用于一些力学相关的仿真计算。</p></li><li><p>颜色设置，也需要重新使用 <strong>gazebo 标签</strong>标注，因为之前的颜色设置为了方便调试包含透明度，仿真环境下没有此选项。</p></li></ul><p>3.urdf举例（知识点讲解在注释中）</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;robot name=<span class="hljs-string">&quot;mycar&quot;</span>&gt;<br>    &lt;link name=<span class="hljs-string">&quot;base_link&quot;</span>&gt;<br>        &lt;visual&gt;<br>            &lt;geometry&gt;<br>                &lt;box size=<span class="hljs-string">&quot;0.5 0.2 0.1&quot;</span> /&gt;<br>            &lt;/geometry&gt;<br>            &lt;origin xyz=<span class="hljs-string">&quot;0.0 0.0 0.0&quot;</span> rpy=<span class="hljs-string">&quot;0.0 0.0 0.0&quot;</span> /&gt;<br>            &lt;material name=<span class="hljs-string">&quot;yellow&quot;</span>&gt;<br>                &lt;color rgba=<span class="hljs-string">&quot;0.5 0.3 0.0 1&quot;</span> /&gt;<br>            &lt;/material&gt;<br>        &lt;/visual&gt;<br>        <br>        &lt;collision&gt;  <span class="hljs-comment">#碰撞属性</span><br>            &lt;geometry&gt;  <span class="hljs-comment">#如果link是标准的几何形状，则和link的visual属性一致</span><br>                &lt;box size=<span class="hljs-string">&quot;0.5 0.2 0.1&quot;</span> /&gt;<br>            &lt;/geometry&gt;<br>            &lt;origin xyz=<span class="hljs-string">&quot;0.0 0.0 0.0&quot;</span> rpy=<span class="hljs-string">&quot;0.0 0.0 0.0&quot;</span> /&gt;<br>        &lt;/collision&gt;<br>        <br>        &lt;inertial&gt;  <span class="hljs-comment">#惯性矩阵 需要结合link的质量与外形参数动态生成</span><br>            &lt;origin xyz=<span class="hljs-string">&quot;0 0 0&quot;</span> /&gt;<br>            &lt;mass value=<span class="hljs-string">&quot;6&quot;</span> /&gt;  <span class="hljs-comment">#质量</span><br>            &lt;inertia ixx=<span class="hljs-string">&quot;1&quot;</span> ixy=<span class="hljs-string">&quot;0&quot;</span> ixz=<span class="hljs-string">&quot;0&quot;</span> iyy=<span class="hljs-string">&quot;1&quot;</span> iyz=<span class="hljs-string">&quot;0&quot;</span> izz=<span class="hljs-string">&quot;1&quot;</span> /&gt;<br>        &lt;/inertial&gt;<br>    &lt;/link&gt;<br>    <br>    &lt;gazebo reference=<span class="hljs-string">&quot;base_link&quot;</span>&gt;  <span class="hljs-comment">#颜色设置</span><br>        &lt;material&gt;Gazebo/Black&lt;/material&gt;<br>    &lt;/gazebo&gt;<br><br>&lt;/robot&gt;<br></code></pre></td></tr></table></figure><p>4.launch文件中集成gazebo</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;launch&gt;<br><br>    <span class="hljs-comment">#将 Urdf 文件的内容加载到参数服务器</span><br>    &lt;param name=<span class="hljs-string">&quot;robot_description&quot;</span> textfile=<span class="hljs-string">&quot;$(find demo02_urdf_gazebo)/urdf/urdf01_helloworld.urdf&quot;</span> /&gt;<br><br>    <span class="hljs-comment">#启动gazebo</span><br>    &lt;include file=<span class="hljs-string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span> /&gt;  <span class="hljs-comment">#用gazebo提供的一个示例：empty_world</span><br>                                                                                                                                               <span class="hljs-comment">#是一个空的仿真环境</span><br><br>    <span class="hljs-comment">#在 gazebo 中显示机器人模型 </span><br>    &lt;node pkg=<span class="hljs-string">&quot;gazebo_ros&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;spawn_model&quot;</span> name=<span class="hljs-string">&quot;model&quot;</span> args=<span class="hljs-string">&quot;-urdf -model mycar -param robot_description&quot;</span>  /&gt;<br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure><p>5.常见的几何体<strong>惯性矩阵公式封装</strong></p><p>球体惯性矩阵</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">xacro:macro</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sphere_inertial_matrix&quot;</span> <span class="hljs-attr">params</span>=<span class="hljs-string">&quot;m r&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">inertial</span>&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">mass</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span><br>         <span class="hljs-tag">&lt;<span class="hljs-name">inertia</span> <span class="hljs-attr">ixx</span>=<span class="hljs-string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> <span class="hljs-attr">ixy</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">ixz</span>=<span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">iyy</span>=<span class="hljs-string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> <span class="hljs-attr">iyz</span>=<span class="hljs-string">&quot;0&quot;</span> </span><br><span class="hljs-tag">             <span class="hljs-attr">izz</span>=<span class="hljs-string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> /&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">inertial</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">xacro:macro</span>&gt;</span><br></code></pre></td></tr></table></figure><p>圆柱惯性矩阵</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">xacro:macro</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cylinder_inertial_matrix&quot;</span> <span class="hljs-attr">params</span>=<span class="hljs-string">&quot;m r h&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">inertial</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">mass</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">inertia</span> <span class="hljs-attr">ixx</span>=<span class="hljs-string">&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot;</span> <span class="hljs-attr">ixy</span> = <span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">ixz</span> = <span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">iyy</span>=<span class="hljs-string">&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot;</span> <span class="hljs-attr">iyz</span> = <span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">izz</span>=<span class="hljs-string">&quot;$&#123;m*r*r/2&#125;&quot;</span> /&gt;</span> <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">inertial</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">xacro:macro</span>&gt;</span><br></code></pre></td></tr></table></figure><p>立方体惯性矩阵</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">xacro:macro</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Box_inertial_matrix&quot;</span> <span class="hljs-attr">params</span>=<span class="hljs-string">&quot;m l w h&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">inertial</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">mass</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">inertia</span> <span class="hljs-attr">ixx</span>=<span class="hljs-string">&quot;$&#123;m*(h*h + l*l)/12&#125;&quot;</span> <span class="hljs-attr">ixy</span> = <span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">ixz</span> = <span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">                  <span class="hljs-attr">iyy</span>=<span class="hljs-string">&quot;$&#123;m*(w*w + l*l)/12&#125;&quot;</span> <span class="hljs-attr">iyz</span>= <span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">                  <span class="hljs-attr">izz</span>=<span class="hljs-string">&quot;$&#123;m*(w*w + h*h)/12&#125;&quot;</span> /&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">inertial</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">xacro:macro</span>&gt;</span><br></code></pre></td></tr></table></figure><p>二、实操</p><p>每个部件分别用一个xacro文件，由于要在gazebo中仿真，所以要为每个link设置<collision>标签、<inertial>标签；</inertial></collision></p><p>同时，还要先编写惯性矩阵算法宏的xacro文件，将上面三种几何体的封装放入其中。</p><p>（代码太长，避免视觉疲劳，不再放出，需要就查）</p><p>Tip：惯性矩阵文件如下，<strong>特别注意</strong>，在集成所有部件的xacro文件中，<strong>一定要先include惯性矩阵文件</strong>，否则后面无法解析宏！！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">robot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;base&quot;</span> <span class="hljs-attr">xmlns:xacro</span>=<span class="hljs-string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Macro for inertia matrix --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xacro:macro</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sphere_inertial_matrix&quot;</span> <span class="hljs-attr">params</span>=<span class="hljs-string">&quot;m r&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">inertial</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">mass</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">inertia</span> <span class="hljs-attr">ixx</span>=<span class="hljs-string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> <span class="hljs-attr">ixy</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">ixz</span>=<span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">iyy</span>=<span class="hljs-string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> <span class="hljs-attr">iyz</span>=<span class="hljs-string">&quot;0&quot;</span> </span><br><span class="hljs-tag">                <span class="hljs-attr">izz</span>=<span class="hljs-string">&quot;$&#123;2*m*r*r/5&#125;&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">inertial</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">xacro:macro</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xacro:macro</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cylinder_inertial_matrix&quot;</span> <span class="hljs-attr">params</span>=<span class="hljs-string">&quot;m r h&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">inertial</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">mass</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">inertia</span> <span class="hljs-attr">ixx</span>=<span class="hljs-string">&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot;</span> <span class="hljs-attr">ixy</span> = <span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">ixz</span> = <span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">iyy</span>=<span class="hljs-string">&quot;$&#123;m*(3*r*r+h*h)/12&#125;&quot;</span> <span class="hljs-attr">iyz</span> = <span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">izz</span>=<span class="hljs-string">&quot;$&#123;m*r*r/2&#125;&quot;</span> /&gt;</span> <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">inertial</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">xacro:macro</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xacro:macro</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Box_inertial_matrix&quot;</span> <span class="hljs-attr">params</span>=<span class="hljs-string">&quot;m l w h&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">inertial</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">mass</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;m&#125;&quot;</span> /&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">inertia</span> <span class="hljs-attr">ixx</span>=<span class="hljs-string">&quot;$&#123;m*(h*h + l*l)/12&#125;&quot;</span> <span class="hljs-attr">ixy</span> = <span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">ixz</span> = <span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">                   <span class="hljs-attr">iyy</span>=<span class="hljs-string">&quot;$&#123;m*(w*w + l*l)/12&#125;&quot;</span> <span class="hljs-attr">iyz</span>= <span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">                   <span class="hljs-attr">izz</span>=<span class="hljs-string">&quot;$&#123;m*(w*w + h*h)/12&#125;&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">inertial</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">xacro:macro</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">robot</span>&gt;</span><br></code></pre></td></tr></table></figure><p>三、Gazebo仿真环境搭建</p><p><strong>方式1：直接添加内置组建</strong></p><p>比如添加长方体、球体、街道、树木等等；</p><p>添加完毕后，选择 file —&gt; Save World as 选择保存路径(功能包下: worlds 目录)，文件名自定义，后缀名设置为 .world</p><p>在launch文件中启动时，只需要修改include下面的arg参数即可：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;launch&gt;<br>    &lt;param name=<span class="hljs-string">&quot;robot_description&quot;</span> command=<span class="hljs-string">&quot;$(find xacro)/xacro $(find demo02_urdf_gazebo)/urdf/xacro/my_base_camera_laser.urdf.xacro&quot;</span> /&gt;<br><br>    &lt;include file=<span class="hljs-string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span>&gt;<br>        &lt;arg name=<span class="hljs-string">&quot;world_name&quot;</span> value=<span class="hljs-string">&quot;$(find demo02_urdf_gazebo)/worlds/hello.world&quot;</span> /&gt;  <span class="hljs-comment">#在include下添加arg(使用自己搭建的仿真环境)</span><br>    &lt;/include&gt;<br><br>    &lt;node pkg=<span class="hljs-string">&quot;gazebo_ros&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;spawn_model&quot;</span> name=<span class="hljs-string">&quot;model&quot;</span> args=<span class="hljs-string">&quot;-urdf -model mycar -param robot_description&quot;</span>  /&gt;<br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure><p>拓：在insert中可以直接使用模型库，下载官方提供的模型库：<code>git clone https://github.com/osrf/gazebo_models</code></p><p><strong>方式2：自定义仿真环境</strong></p><p>在gazebo中选择左上角<strong>Edit —&gt; Exit Building Editor</strong>，这一步主要用于<strong>搭建房间墙体</strong>！</p><p>然后可以像方式1一样在房子中间加入<strong>球体、长方体</strong>等；</p><p>最后保存为 world 文件(保存路径功能包下的: worlds)，然后像方式1一样用launch文件启动</p><h2 id="URDF、Gazebo、Rviz综合使用"><a href="#URDF、Gazebo、Rviz综合使用" class="headerlink" title="URDF、Gazebo、Rviz综合使用"></a>URDF、Gazebo、Rviz综合使用</h2><p>在rviz中控制机器人运动：arbotix            在gazebo中机器人运动控制：<code>ros_control</code></p><p><strong>一、机器人运动控制</strong></p><p>1.ros_control简介</p><p>开发阶段为了提高效率是在仿真平台上测试的，部署时又有不同的实体机器人平台，不同平台的实现是有差异的，如何保证 ROS 程序的<strong>可移植性</strong>？ROS 内置的解决方式是 ros_control。</p><p>ros_control 是一套机器人控制的中间件，是一套规范，不同的机器人平台只要按照这套规范实现，那么就可以保证 与ROS 程序兼容。</p><p>简而言之，<code>ros_control</code>是<strong>ROS程序</strong>与<strong>机器人平台</strong>的接口</p><p>2.运动控制实现流程：</p><p>（1）已经创建完毕的机器人模型，编写一个单独的 xacro 文件，为机器人模型<strong>添加传动装置</strong>以及<strong>控制器</strong></p><p>（2）将此文件集成进xacro文件</p><p>（3）启动 Gazebo 并发布 /cmd_vel 消息控制机器人运动</p><p>控制关节运动：<strong>为joint添加</strong>传动装置及控制器的xacro文件：（重点实现在于<strong>transmission标签</strong>，但是这些内容都是<strong>可以在官方文档中直接复制</strong>的）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">robot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;my_car_move&quot;</span> <span class="hljs-attr">xmlns:xacro</span>=<span class="hljs-string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 传动实现:用于连接控制器与关节 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xacro:macro</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;joint_trans&quot;</span> <span class="hljs-attr">params</span>=<span class="hljs-string">&quot;joint_name&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- Transmission is important to link the joints and the controller --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">transmission</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;$&#123;joint_name&#125;_trans&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>transmission_interface/SimpleTransmission<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">joint</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;$&#123;joint_name&#125;&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">hardwareInterface</span>&gt;</span>hardware_interface/VelocityJointInterface<span class="hljs-tag">&lt;/<span class="hljs-name">hardwareInterface</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">joint</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">actuator</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;$&#123;joint_name&#125;_motor&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">hardwareInterface</span>&gt;</span>hardware_interface/VelocityJointInterface<span class="hljs-tag">&lt;/<span class="hljs-name">hardwareInterface</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">mechanicalReduction</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">mechanicalReduction</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">actuator</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">transmission</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">xacro:macro</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 每一个驱动轮都需要配置传动装置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xacro:joint_trans</span> <span class="hljs-attr">joint_name</span>=<span class="hljs-string">&quot;left_wheel2base_link&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xacro:joint_trans</span> <span class="hljs-attr">joint_name</span>=<span class="hljs-string">&quot;right_wheel2base_link&quot;</span> /&gt;</span><br><br>    <span class="hljs-comment">&lt;!--差速 控制器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">gazebo</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;differential_drive_controller&quot;</span> <span class="hljs-attr">filename</span>=<span class="hljs-string">&quot;libgazebo_ros_diff_drive.so&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">rosDebugLevel</span>&gt;</span>Debug<span class="hljs-tag">&lt;/<span class="hljs-name">rosDebugLevel</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">publishWheelTF</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">publishWheelTF</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">robotNamespace</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">robotNamespace</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">publishTf</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">publishTf</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">publishWheelJointState</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">publishWheelJointState</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">alwaysOn</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">alwaysOn</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">updateRate</span>&gt;</span>100.0<span class="hljs-tag">&lt;/<span class="hljs-name">updateRate</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">legacyMode</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">legacyMode</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">leftJoint</span>&gt;</span>left_wheel2base_link<span class="hljs-tag">&lt;/<span class="hljs-name">leftJoint</span>&gt;</span> <span class="hljs-comment">&lt;!-- 左轮 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">rightJoint</span>&gt;</span>right_wheel2base_link<span class="hljs-tag">&lt;/<span class="hljs-name">rightJoint</span>&gt;</span> <span class="hljs-comment">&lt;!-- 右轮 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">wheelSeparation</span>&gt;</span>$&#123;base_link_radius * 2&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">wheelSeparation</span>&gt;</span> <span class="hljs-comment">&lt;!-- 车轮间距 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">wheelDiameter</span>&gt;</span>$&#123;wheel_radius * 2&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">wheelDiameter</span>&gt;</span> <span class="hljs-comment">&lt;!-- 车轮直径 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">broadcastTF</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">broadcastTF</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">wheelTorque</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">wheelTorque</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">wheelAcceleration</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">wheelAcceleration</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">commandTopic</span>&gt;</span>cmd_vel<span class="hljs-tag">&lt;/<span class="hljs-name">commandTopic</span>&gt;</span> <span class="hljs-comment">&lt;!-- 运动控制话题 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">odometryFrame</span>&gt;</span>odom<span class="hljs-tag">&lt;/<span class="hljs-name">odometryFrame</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">odometryTopic</span>&gt;</span>odom<span class="hljs-tag">&lt;/<span class="hljs-name">odometryTopic</span>&gt;</span> <span class="hljs-comment">&lt;!-- 里程计话题 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">robotBaseFrame</span>&gt;</span>base_footprint<span class="hljs-tag">&lt;/<span class="hljs-name">robotBaseFrame</span>&gt;</span> <span class="hljs-comment">&lt;!-- 根坐标系 --&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">gazebo</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">robot</span>&gt;</span><br></code></pre></td></tr></table></figure><p>发布控制信息：（话题<code>cmd_vel</code>）</p><p>方法1：<code>rostopic pub -r 10 /cmd_vel geometry_msgs/Twist &#39;&#123;linear: &#123;x: 0.2, y: 0, z: 0&#125;, angular: &#123;x: 0, y: 0, z: 0.5&#125;&#125;&#39;</code></p><p>方法2：<strong>键盘控制节点</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">rosrun teleop_twist_keyboard teleop_twist_keyboard.py  _speed:=<span class="hljs-number">0.3</span>  _turn:=<span class="hljs-number">0.5</span><br><span class="hljs-comment">#_speed:=0.3  _turn:=0.5分别设置线速度、角速度</span><br></code></pre></td></tr></table></figure><p>（4）Rviz查看里程计信息</p><p>编写新的launch文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;launch&gt;<br>    &lt;!-- 启动 rviz --&gt;<br>    &lt;node pkg=<span class="hljs-string">&quot;rviz&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;rviz&quot;</span> name=<span class="hljs-string">&quot;rviz&quot;</span> /&gt;<br><br>    &lt;!-- 关节以及机器人状态发布节点 --&gt;<br>    &lt;node name=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> pkg=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> /&gt;<br>    &lt;node name=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> pkg=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> /&gt;<br><br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure><p>参考坐标设为<code>odom</code>，添加<code>RobotModel</code>组件，添加组件<code>Odometry</code>并设置topic为<code>odom</code></p><p><strong>3.雷达仿真</strong></p><p>在小车搭建好的基础上，只需要添加单独的xacro文件配置雷达，然后将该xacro集成即可。</p><p>雷达的xacro文件：（<strong>官网的实现，直接复制粘贴</strong>）</p><p>​    Tip：<strong>这里才是真正的仿真雷达</strong>，前面的<code>demo_ladar.xacro</code>只是为雷达提供了一个几何描述！！！所以这里的雷达，要通过reference参数连接到前面已经设置好的laser link上！</p><p><strong>官网文件扒下来，只需要改两个地方：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. reference修改为机器人模型中对应的link名称</span><br><br><span class="hljs-comment"># 2. &lt;frameName&gt;也修改为该link名称</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">robot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;my_sensors&quot;</span> <span class="hljs-attr">xmlns:xacro</span>=<span class="hljs-string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- 雷达 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">gazebo</span> <span class="hljs-attr">reference</span>=<span class="hljs-string">&quot;laser&quot;</span>&gt;</span>   <span class="hljs-comment">&lt;!--  laser是小车上一个link的名称  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sensor</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;ray&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;rplidar&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">pose</span>&gt;</span>0 0 0 0 0 0<span class="hljs-tag">&lt;/<span class="hljs-name">pose</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">visualize</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">visualize</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">update_rate</span>&gt;</span>5.5<span class="hljs-tag">&lt;/<span class="hljs-name">update_rate</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">ray</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scan</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">horizontal</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">samples</span>&gt;</span>360<span class="hljs-tag">&lt;/<span class="hljs-name">samples</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">resolution</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">resolution</span>&gt;</span>   <span class="hljs-comment">&lt;!--  分辨率，表示发射射线的频率  --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">min_angle</span>&gt;</span>-3<span class="hljs-tag">&lt;/<span class="hljs-name">min_angle</span>&gt;</span>  <span class="hljs-comment">&lt;!--  可转动的弧度rad  --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">max_angle</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">max_angle</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">horizontal</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">scan</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">range</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">min</span>&gt;</span>0.10<span class="hljs-tag">&lt;/<span class="hljs-name">min</span>&gt;</span> <span class="hljs-comment">&lt;!--  小于0.1m采样无效  --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">max</span>&gt;</span>30.0<span class="hljs-tag">&lt;/<span class="hljs-name">max</span>&gt;</span> <span class="hljs-comment">&lt;!--  大于30m采样无效  --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">resolution</span>&gt;</span>0.01<span class="hljs-tag">&lt;/<span class="hljs-name">resolution</span>&gt;</span> <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">range</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">noise</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>gaussian<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>   <span class="hljs-comment">&lt;!--  高斯噪声，为了仿真而设置  --&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">mean</span>&gt;</span>0.0<span class="hljs-tag">&lt;/<span class="hljs-name">mean</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">stddev</span>&gt;</span>0.01<span class="hljs-tag">&lt;/<span class="hljs-name">stddev</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">noise</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">ray</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gazebo_rplidar&quot;</span> <span class="hljs-attr">filename</span>=<span class="hljs-string">&quot;libgazebo_ros_laser.so&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">topicName</span>&gt;</span>/scan<span class="hljs-tag">&lt;/<span class="hljs-name">topicName</span>&gt;</span>   <br>        <span class="hljs-tag">&lt;<span class="hljs-name">frameName</span>&gt;</span>laser<span class="hljs-tag">&lt;/<span class="hljs-name">frameName</span>&gt;</span>  <span class="hljs-comment">&lt;!--  与reference一样，都必须设置为雷达连杆的名字  --&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">sensor</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">gazebo</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">robot</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在Rviz中显示雷达数据：</p><p>添加组件<code>LaserScan</code>并设置话题为<code>/scan</code></p><p><strong>4.摄像头仿真</strong></p><p>和雷达一样，只需要添加单独的xacro文件配置摄像头，然后将该xacro集成即可</p><p>摄像头配置xacro：（<strong>官网文件直接复制</strong>！）</p><p><strong>官网文件扒下来，只需要改两个地方：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. reference修改为机器人模型中对应的link名称</span><br><br><span class="hljs-comment"># 2. &lt;frameName&gt;也修改为该link名称</span><br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">robot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;my_sensors&quot;</span> <span class="hljs-attr">xmlns:xacro</span>=<span class="hljs-string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 被引用的link --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">gazebo</span> <span class="hljs-attr">reference</span>=<span class="hljs-string">&quot;camera&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 类型设置为 camara --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sensor</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;camera&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;camera_node&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">update_rate</span>&gt;</span>30.0<span class="hljs-tag">&lt;/<span class="hljs-name">update_rate</span>&gt;</span> <span class="hljs-comment">&lt;!-- 更新频率 --&gt;</span><br>      <span class="hljs-comment">&lt;!-- 摄像头基本信息设置 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">camera</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;head&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">horizontal_fov</span>&gt;</span>1.3962634<span class="hljs-tag">&lt;/<span class="hljs-name">horizontal_fov</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">image</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">width</span>&gt;</span>1280<span class="hljs-tag">&lt;/<span class="hljs-name">width</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">height</span>&gt;</span>720<span class="hljs-tag">&lt;/<span class="hljs-name">height</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">format</span>&gt;</span>R8G8B8<span class="hljs-tag">&lt;/<span class="hljs-name">format</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">clip</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">near</span>&gt;</span>0.02<span class="hljs-tag">&lt;/<span class="hljs-name">near</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">far</span>&gt;</span>300<span class="hljs-tag">&lt;/<span class="hljs-name">far</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">clip</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">noise</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>gaussian<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">mean</span>&gt;</span>0.0<span class="hljs-tag">&lt;/<span class="hljs-name">mean</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">stddev</span>&gt;</span>0.007<span class="hljs-tag">&lt;/<span class="hljs-name">stddev</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">noise</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">camera</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- 核心插件 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gazebo_camera&quot;</span> <span class="hljs-attr">filename</span>=<span class="hljs-string">&quot;libgazebo_ros_camera.so&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">alwaysOn</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">alwaysOn</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">updateRate</span>&gt;</span>0.0<span class="hljs-tag">&lt;/<span class="hljs-name">updateRate</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cameraName</span>&gt;</span>/camera<span class="hljs-tag">&lt;/<span class="hljs-name">cameraName</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">imageTopicName</span>&gt;</span>image_raw<span class="hljs-tag">&lt;/<span class="hljs-name">imageTopicName</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">cameraInfoTopicName</span>&gt;</span>camera_info<span class="hljs-tag">&lt;/<span class="hljs-name">cameraInfoTopicName</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">frameName</span>&gt;</span>camera<span class="hljs-tag">&lt;/<span class="hljs-name">frameName</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">hackBaseline</span>&gt;</span>0.07<span class="hljs-tag">&lt;/<span class="hljs-name">hackBaseline</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">distortionK1</span>&gt;</span>0.0<span class="hljs-tag">&lt;/<span class="hljs-name">distortionK1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">distortionK2</span>&gt;</span>0.0<span class="hljs-tag">&lt;/<span class="hljs-name">distortionK2</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">distortionK3</span>&gt;</span>0.0<span class="hljs-tag">&lt;/<span class="hljs-name">distortionK3</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">distortionT1</span>&gt;</span>0.0<span class="hljs-tag">&lt;/<span class="hljs-name">distortionT1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">distortionT2</span>&gt;</span>0.0<span class="hljs-tag">&lt;/<span class="hljs-name">distortionT2</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">sensor</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">gazebo</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">robot</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在Rviz中显示摄像头数据：</p><p>添加<code>Camera</code>组件，修改话题为<code>image_raw</code></p><p><strong>5.深度相机Kinect仿真</strong></p><p>Kinect配置xacro：（<strong>官网文件直接复制</strong>！）</p><p>由于机器人模型中没有为Kinect设置专门的link，所以借用雷达的link：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">robot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;my_sensors&quot;</span> <span class="hljs-attr">xmlns:xacro</span>=<span class="hljs-string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">gazebo</span> <span class="hljs-attr">reference</span>=<span class="hljs-string">&quot;kinect link名称&quot;</span>&gt;</span>  <br>      <span class="hljs-tag">&lt;<span class="hljs-name">sensor</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;depth&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;camera&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">always_on</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">always_on</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">update_rate</span>&gt;</span>20.0<span class="hljs-tag">&lt;/<span class="hljs-name">update_rate</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">camera</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">horizontal_fov</span>&gt;</span>$&#123;60.0*PI/180.0&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">horizontal_fov</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">image</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">format</span>&gt;</span>R8G8B8<span class="hljs-tag">&lt;/<span class="hljs-name">format</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">width</span>&gt;</span>640<span class="hljs-tag">&lt;/<span class="hljs-name">width</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">height</span>&gt;</span>480<span class="hljs-tag">&lt;/<span class="hljs-name">height</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">image</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">clip</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">near</span>&gt;</span>0.05<span class="hljs-tag">&lt;/<span class="hljs-name">near</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">far</span>&gt;</span>8.0<span class="hljs-tag">&lt;/<span class="hljs-name">far</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">clip</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">camera</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;kinect_camera_controller&quot;</span> <span class="hljs-attr">filename</span>=<span class="hljs-string">&quot;libgazebo_ros_openni_kinect.so&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">cameraName</span>&gt;</span>camera<span class="hljs-tag">&lt;/<span class="hljs-name">cameraName</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">alwaysOn</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">alwaysOn</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">updateRate</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">updateRate</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">imageTopicName</span>&gt;</span>rgb/image_raw<span class="hljs-tag">&lt;/<span class="hljs-name">imageTopicName</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">depthImageTopicName</span>&gt;</span>depth/image_raw<span class="hljs-tag">&lt;/<span class="hljs-name">depthImageTopicName</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">pointCloudTopicName</span>&gt;</span>depth/points<span class="hljs-tag">&lt;/<span class="hljs-name">pointCloudTopicName</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">cameraInfoTopicName</span>&gt;</span>rgb/camera_info<span class="hljs-tag">&lt;/<span class="hljs-name">cameraInfoTopicName</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">depthImageCameraInfoTopicName</span>&gt;</span>depth/camera_info<span class="hljs-tag">&lt;/<span class="hljs-name">depthImageCameraInfoTopicName</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">frameName</span>&gt;</span>kinect link名称<span class="hljs-tag">&lt;/<span class="hljs-name">frameName</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">baseline</span>&gt;</span>0.1<span class="hljs-tag">&lt;/<span class="hljs-name">baseline</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">distortion_k1</span>&gt;</span>0.0<span class="hljs-tag">&lt;/<span class="hljs-name">distortion_k1</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">distortion_k2</span>&gt;</span>0.0<span class="hljs-tag">&lt;/<span class="hljs-name">distortion_k2</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">distortion_k3</span>&gt;</span>0.0<span class="hljs-tag">&lt;/<span class="hljs-name">distortion_k3</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">distortion_t1</span>&gt;</span>0.0<span class="hljs-tag">&lt;/<span class="hljs-name">distortion_t1</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">distortion_t2</span>&gt;</span>0.0<span class="hljs-tag">&lt;/<span class="hljs-name">distortion_t2</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">pointCloudCutoff</span>&gt;</span>0.4<span class="hljs-tag">&lt;/<span class="hljs-name">pointCloudCutoff</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">sensor</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">gazebo</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">robot</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在Rviz中显示深度相机信息：</p><p>同样是添加<code>Camera</code>组件，话题有两个可选：</p><p>（1）camera/rgb/image_raw：显示和普通相机一样的彩色信息</p><p>（2）camera/depth/image_raw：显示<strong>深度信息（黑白灰）</strong></p><p>拓：在Rviz中显示深度相机<strong>点云信息</strong>：</p><p>添加<code>PointCloud2</code>组件，可能会出现错位问题，是因为图像数据与点云数据使用了两套坐标系统，且两套坐标系统位姿并不一致，解决办法查。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在gazebo中创建一个机器人世界，不仅可以仿真机器人的运动功能，还可以仿真机器人的传感器数据，这些数据就可以放到rviz中显示。</p><p>1.如果你手上<strong>已经有机器人硬件平台</strong>，并且在上边可以完成需要的功能，用rviz应该就可以满足开发需求。</p><p>2.如果你手上<strong>没有机器人硬件</strong>，或者想在仿真环境中做一些算法、应用的测试，gazebo+rviz应该是你需要的。</p><p>（3.rviz配合其他功能包也可以建立一个简单的仿真环境，比如rviz+ArbotiX）</p>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>系统学习ROS（四）</title>
    <link href="/2021/05/21/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ROS%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2021/05/21/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ROS%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>从本文起，开始介绍ROS最强大的功能之一——仿真。</p><p>简单来说，ROS仿真用URDF语法进行机器人建模，在Gazebo中实现，同时可以搭配Rviz对感知到的环境进行可视化。</p><span id="more"></span><h4 id="十、机器人仿真"><a href="#十、机器人仿真" class="headerlink" title="十、机器人仿真"></a>十、机器人仿真</h4><p>在 ROS 中，仿真实现涉及的内容主要有三:**对机器人建模(URDF)<strong>、</strong>创建仿真环境(Gazebo)<strong>以及</strong>感知环境(Rviz)**等系统性实现。</p><p><strong>仿真优势：</strong></p><p>1.**低成本:**当前机器人成本居高不下，动辄几十万，仿真可以大大降低成本，减小风险</p><p>2.**高效:**搭建的环境更为多样且灵活，可以提高测试效率以及测试覆盖率</p><p>3.**高安全性:**仿真环境下，无需考虑耗损问题</p><p><strong>仿真缺陷：</strong></p><p>1.仿真器所使用的物理引擎目前还不能够完全精确模拟真实世界的物理情况</p><p>2.仿真器构建的是关节驱动器（电机&amp;齿轮箱）、传感器与信号通信的<strong>绝对理想情况</strong>，目前不支持模拟实际硬件缺陷或者一些临界状态等情形</p><ul><li>如果非仿真环境(真实环境)，那么使用 URDF 结合 Rviz 直接显示感知的真实环境信息</li><li>如果是仿真环境，那么需要使用 URDF 结合 Gazebo 搭建仿真环境，并结合 Rviz 显示感知的虚拟环境信息</li></ul><h2 id="URDF与Rviz集成使用"><a href="#URDF与Rviz集成使用" class="headerlink" title="URDF与Rviz集成使用"></a>URDF与Rviz集成使用</h2><p>URDF：<strong>统一(标准化)机器人描述格式</strong>，可以以一种 XML 的方式描述机器人的部分结构，比如底盘、摄像头、激光雷达、机械臂以及不同关节的自由度</p><p>URDF 不能单独使用，需要结合 Rviz 或 Gazebo，URDF 只是一个文件，需要在 Rviz 或 Gazebo 中渲染成图形化的机器人模型。</p><p><strong>1.实现流程：</strong></p><p>（1）准备:新建功能包，导入依赖：urdf、xacro</p><p>（2）核心:编写 urdf 文件</p><p>（3）核心:在 launch 文件集成 URDF 与 Rviz</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;launch&gt;<br><span class="hljs-comment">#使用的参数名是:robot_description</span><br>    &lt;param name=<span class="hljs-string">&quot;robot_description&quot;</span> textfile=<span class="hljs-string">&quot;$(find 包名)/urdf/urdf/urdf01_HelloWorld.urdf&quot;</span> /&gt; <br><br>    &lt;node pkg=<span class="hljs-string">&quot;rviz&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;rviz&quot;</span> name=<span class="hljs-string">&quot;rviz&quot;</span> /&gt;<br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure><p>（4）在 Rviz 中显示机器人模型：add插件<code>RobotModel</code>，然后修改参考坐标系</p><p>Tip: <strong>优化第四步</strong>：如果每次启动rviz都要手动add插件太麻烦！可以保存rviz配置文件，然后在launch文件中加载配置文件</p><p>在rviz选在<strong>save config as</strong>，保存到刚刚的config文件夹下；重新编launch文件：<strong>给node rviz添加参数</strong><code>args=&quot;-d $(find 包名)/config/demo1.rviz&quot;</code></p><p><strong>2.URDF语法详解：</strong></p><p>可以主要简化为两部分:<strong>连杆(link标签)</strong> 与 <strong>关节(joint标签)</strong></p><p>URDF 中的不同标签:</p><ul><li>robot 根标签，类似于 launch文件中的launch标签 <robot></robot></li><li>link 连杆标签 <link></li><li>joint 关节标签 <joint></joint></li><li>gazebo 集成gazebo需要使用的标签 <gazebo></gazebo></li></ul><p>（1）robot标签</p><p>使用了<code>robot</code>标签作为<strong>根标签</strong>，所有的 link 和 joint 以及其他标签都必须包含在 robot 标签；</p><p>唯一的属性name: 指定机器人模型的名称</p><p>（2）link标签</p><p>某个部件(也即刚体部分)的外观和物理属性，比如: 机器人底座、轮子、激光雷达、摄像头…每一个部件都对应一个 link；</p><p>在 link 标签内，可以设计该部件的形状、尺寸、颜色、惯性矩阵、碰撞参数等一系列属性。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#属性</span><br>name ---&gt; 为连杆命名<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#子标签</span><br>    visual ---&gt; 描述外观(对应的数据是可视的)<br>        geometry 设置连杆的形状<br>            标签<span class="hljs-number">1</span>: box(盒状)<br>                属性:size=长(x) 宽(y) 高(z)<br>            标签<span class="hljs-number">2</span>: cylinder(圆柱)<br>                属性:radius=半径 length=高度<br>            标签<span class="hljs-number">3</span>: sphere(球体)<br>                属性:radius=半径<br>            标签<span class="hljs-number">4</span>: mesh(为连杆添加皮肤)<br>                属性: filename=资源路径(格式:package://&lt;packagename&gt;/&lt;path&gt;/文件)<br><br>        origin 设置偏移量与倾斜弧度<br>            属性<span class="hljs-number">1</span>: xyz=x偏移 y便宜 z偏移<br>            属性<span class="hljs-number">2</span>: rpy=x翻滚 y俯仰 z偏航 (单位是弧度)<br><br>        metrial 设置材料属性(颜色)<br>            属性: name<br>            标签: color<br>                属性: rgba=红绿蓝权重值与透明度 (每个权重值以及透明度取值[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>])<br>                    <br>    collision ---&gt; 连杆的碰撞属性<br>    <br>    Inertial ---&gt; 连杆的惯性矩阵<br></code></pre></td></tr></table></figure><p>举例：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;robot&gt;<br>    &lt;link name=<span class="hljs-string">&quot;base_link&quot;</span>&gt;    <span class="hljs-comment">#机器人底盘的link，一般都取名为base_link</span><br>        &lt;visual&gt;   <span class="hljs-comment">#子级1：可视化标签</span><br>            &lt;geometry&gt;  <span class="hljs-comment">#子级2：设置几何形状</span><br>                &lt;box size=<span class="hljs-string">&quot;0.5 0.3 0.1&quot;</span> /&gt;                             <span class="hljs-comment">#子级3：box长方体</span><br>                 &lt;cylinder radius=<span class="hljs-string">&quot;0.5&quot;</span> length=<span class="hljs-string">&quot;0.1&quot;</span> /&gt;  <span class="hljs-comment">#子级3：cylinder圆柱体</span><br>                &lt;sphere radius=<span class="hljs-string">&quot;0.3&quot;</span> /&gt;                                <span class="hljs-comment">#子级3：sphere球体</span><br>                        <br>                        &lt;mesh filename=<span class="hljs-string">&quot;package://包名/mesh文件路径名&quot;</span>&gt;  <span class="hljs-comment">#子级3：mesh修改皮肤</span><br>              &lt;/geometry&gt;<br>            <br>            &lt;origin xyz=<span class="hljs-string">&quot;0 0 0&quot;</span> rpy=<span class="hljs-string">&quot;0 0 0&quot;</span> /&gt;  <span class="hljs-comment">#子级2：设置偏移量、倾斜弧度</span><br><br>            &lt;material name=<span class="hljs-string">&quot;black&quot;</span>&gt;   <span class="hljs-comment">#子级2：颜色</span><br>                &lt;color rgba=<span class="hljs-string">&quot;0.7 0.5 0 0.5&quot;</span> /&gt;  <span class="hljs-comment">#子级3：color   rgba中的a表示透明度！</span><br>            &lt;/material&gt;<br>        &lt;/visual&gt;<br>    &lt;/link&gt;<br>&lt;/robot&gt;<br></code></pre></td></tr></table></figure><p>（3）joint标签</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#属性</span><br>    name ---&gt; 为关节命名<br>    <br>    type ---&gt; 关节运动形式<br>        continuous: 旋转关节，可以绕单轴无限旋转  <span class="hljs-comment">#常用</span><br>        revolute: 旋转关节，类似于 continues,但是有旋转角度限制<br>        prismatic: 滑动关节，沿某一轴线移动的关节，有位置极限<br>        planer: 平面关节，允许在平面正交方向上平移或旋转<br>        floating: 浮动关节，允许进行平移、旋转运动<br>        fixed: 固定关节，不允许运动的特殊关节  <span class="hljs-comment">#常用</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#子标签</span><br>    parent(必需的)<br>    parent link的名字是一个强制的属性：<br>        link:父级连杆的名字，是这个link在机器人结构树中的名字。<br>            <br>    child(必需的)<br>    child link的名字是一个强制的属性：<br>        link:子级连杆的名字，是这个link在机器人结构树中的名字。<br>            <br>    origin<br>        属性: xyz=各轴线上的偏移量  rpy=各轴线上的偏移弧度。<br>            <br>    axis<br>        属性: xyz用于设置可以围绕哪个关节轴运动。<span class="hljs-comment">#0表示不能围绕该轴转动，1表示可以围绕该轴转动</span><br></code></pre></td></tr></table></figure><p>举例：创建机器人模型，底盘为长方体，在长方体的前面添加一摄像头，摄像头可以沿着 Z 轴 360 度旋转。</p><p>​          思路：底板link、摄像头link、二者之间的连接用一个joint</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;robot name=<span class="hljs-string">&quot;mycar&quot;</span>&gt;<br><span class="hljs-comment">#底盘</span><br>    &lt;link name=<span class="hljs-string">&quot;base_link&quot;</span>&gt;    <br>        &lt;visual&gt;<br>            &lt;geometry&gt;<br>                &lt;box size=<span class="hljs-string">&quot;0.5 0.2 0.1&quot;</span> /&gt;<br>            &lt;/geometry&gt;<br>            &lt;origin xyz=<span class="hljs-string">&quot;0 0 0&quot;</span> rpy=<span class="hljs-string">&quot;0 0 0&quot;</span> /&gt;<br>            &lt;material name=<span class="hljs-string">&quot;blue&quot;</span>&gt;<br>                &lt;color rgba=<span class="hljs-string">&quot;0 0 1.0 0.5&quot;</span> /&gt;<br>            &lt;/material&gt;<br>        &lt;/visual&gt;<br>    &lt;/link&gt;<br><br>    <span class="hljs-comment">#摄像头</span><br>    &lt;link name=<span class="hljs-string">&quot;camera&quot;</span>&gt;<br>        &lt;visual&gt;<br>            &lt;geometry&gt;<br>                &lt;box size=<span class="hljs-string">&quot;0.02 0.05 0.05&quot;</span> /&gt;<br>            &lt;/geometry&gt;<br>            &lt;origin xyz=<span class="hljs-string">&quot;0 0 0&quot;</span> rpy=<span class="hljs-string">&quot;0 0 0&quot;</span> /&gt;<br>            &lt;material name=<span class="hljs-string">&quot;red&quot;</span>&gt;<br>                &lt;color rgba=<span class="hljs-string">&quot;1 0 0 0.5&quot;</span> /&gt;<br>            &lt;/material&gt;<br>        &lt;/visual&gt;<br>    &lt;/link&gt;<br><br>    <span class="hljs-comment">#关节</span><br>    &lt;joint name=<span class="hljs-string">&quot;camera2baselink&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;continuous&quot;</span>&gt;  <span class="hljs-comment">#可自由旋转</span><br>        &lt;parent link=<span class="hljs-string">&quot;base_link&quot;</span>/&gt;<br>        &lt;child link=<span class="hljs-string">&quot;camera&quot;</span> /&gt; <br>        <br>         <span class="hljs-comment">#设置偏移量</span><br>        &lt;origin xyz=<span class="hljs-string">&quot;0.2 0 0.075&quot;</span> rpy=<span class="hljs-string">&quot;0 0 0&quot;</span> /&gt;  <span class="hljs-comment">#设置偏移量，否则子link会生成在父link的中心位置</span><br>        &lt;axis xyz=<span class="hljs-string">&quot;0 0 1&quot;</span> /&gt;<br>    &lt;/joint&gt;<br><br>&lt;/robot&gt;<br></code></pre></td></tr></table></figure><p><strong>joint偏移量：</strong></p><ul><li>child link的gemotry属性中的偏移量是<strong>相对于joint位置</strong>而言的</li><li>所以设置好了joint的偏移量，才能确定好child link的位置</li><li><strong>默认规则：</strong>一般情况下，<strong>link中的偏移量都设置为0；link的位置通过joint的偏移量来设置！</strong></li><li>所以当你要设置一个link的位置时，首先要设置好它的joint的偏移量！</li></ul><p>joint相对于parent link的偏移量解释：</p><p>编写完urdf文件后，用launch文件集成启动：</p><p>如果使用普通的办法，即只设置robot_description参数，则会报错<br>原因：rviz缺少不同部件之间的坐标系关系（transform）<br>解决：ROS中提供了关于机器人模型显示的坐标发布节点2个：<strong>joint_state_publisher、robot_state_publisher</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;launch&gt;<br><br>    &lt;param name=<span class="hljs-string">&quot;robot_description&quot;</span> textfile=<span class="hljs-string">&quot;$(find urdf_rviz_demo)/urdf/urdf/urdf03_joint.urdf&quot;</span> /&gt;<br>    &lt;node pkg=<span class="hljs-string">&quot;rviz&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;rviz&quot;</span> name=<span class="hljs-string">&quot;rviz&quot;</span> args=<span class="hljs-string">&quot;-d $(find urdf_rviz_demo)/config/helloworld.rviz&quot;</span> /&gt; <br><br>    <span class="hljs-comment">#添加关节状态发布节点</span><br>    &lt;node pkg=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> name=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> /&gt;<br>    <span class="hljs-comment">#添加机器人状态发布节点</span><br>    &lt;node pkg=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> name=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> /&gt;<br>    <span class="hljs-comment">#可选:用于控制关节运动的节点，用于测试关节运动是否正常（主要用于测试）</span><br>    &lt;node pkg=<span class="hljs-string">&quot;joint_state_publisher_gui&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;joint_state_publisher_gui&quot;</span> name=<span class="hljs-string">&quot;joint_state_publisher_gui&quot;</span> /&gt;<br><br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure><p>总结：joint偏移量的设置需要自行计算，launch文件中要为rviz启动2个坐标关系发布节点！</p><h4 id="用base-footprint优化urdf："><a href="#用base-footprint优化urdf：" class="headerlink" title="用base_footprint优化urdf："></a>用base_footprint优化urdf：</h4><p>前面实现的模型，其base_link都是半沉到地下的；修改：用一个<strong>极小的物体（base_footprint）</strong>代替base_link去半沉到地下，然后<strong>将base_link连接到base_footprint上</strong>， 最后<strong>在rviz中选择参考坐标系为base_footprint</strong>，则base_footprint就一定会半沉下去，base_link就一定不会沉下去！</p><h4 id="问题篇2："><a href="#问题篇2：" class="headerlink" title="问题篇2："></a>问题篇2：</h4><p>在运行集成了urdf文件的launch文件时，报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">UnicodeEncodeError: <span class="hljs-string">&#x27;ascii&#x27;</span> codec can<span class="hljs-string">&#x27;t encode characters in position 463-464: ordinal not in range(128)</span><br><span class="hljs-string">[joint_state_publisher-3] process has died [pid 4443, exit code 1, cmd /opt/ros/melodic/lib/joint_state_publisher/joint_state_publisher __name:=joint_state_publisher __log:=/home/rosmelodic/.ros/log/b38967c0-0acb-11eb-aee3-0800278ee10c/joint_state_publisher-3.log].</span><br><span class="hljs-string">log file: /home/rosmelodic/.ros/log/b38967c0-0acb-11eb-aee3-0800278ee10c/joint_state_publisher-3*.log</span><br></code></pre></td></tr></table></figure><p>即出现编码问题</p><p>解决：去除URDF中的中文注释即可～</p><p><strong>（4）实操项目2</strong>：简易机器人模型</p><p>创建一个四轮圆柱状机器人模型，机器人参数如下,底盘为圆柱状，半径 10cm，高 8cm，四轮由两个驱动轮和两个万向支撑轮组成，两个驱动轮半径为  3.25cm,轮胎宽度1.5cm，两个万向轮为球状，半径 0.75cm，底盘离地间距为 1.5cm(与万向轮直径一致)</p><p>2个驱动轮+2个万向轮+底盘</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">robot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mycar&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- footprint --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;base_footprint&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">visual</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">geometry</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">sphere</span> <span class="hljs-attr">radius</span>=<span class="hljs-string">&quot;0.001&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">geometry</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">visual</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">link</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 底盘 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;base_link&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">visual</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">geometry</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cylinder</span> <span class="hljs-attr">radius</span>=<span class="hljs-string">&quot;0.1&quot;</span> <span class="hljs-attr">length</span>=<span class="hljs-string">&quot;0.08&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">geometry</span>&gt;</span><br>            <br>            <span class="hljs-tag">&lt;<span class="hljs-name">origin</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&quot;0 0 0&quot;</span> <span class="hljs-attr">rpy</span>=<span class="hljs-string">&quot;0 0 0&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">visual</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">link</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- joint1 --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">joint</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;link2footprint&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;fixed&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span> <span class="hljs-attr">link</span> =<span class="hljs-string">&quot;base_footprint&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">link</span>=<span class="hljs-string">&quot;base_link&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">origin</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&quot;0 0 0.055&quot;</span> <span class="hljs-attr">rpy</span>=<span class="hljs-string">&quot;0 0 0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">joint</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 左驱动轮  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;left_wheel&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">visual</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">geometry</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cylinder</span> <span class="hljs-attr">radius</span>=<span class="hljs-string">&quot;0.0325&quot;</span> <span class="hljs-attr">length</span>=<span class="hljs-string">&quot;0.015&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">geometry</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">origin</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&quot;0 0 0&quot;</span> <span class="hljs-attr">rpy</span>=<span class="hljs-string">&quot;1.5705 0 0&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">material</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;black&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">rgba</span>=<span class="hljs-string">&quot;0.0 0.0 0.0 1.0&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">material</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">visual</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">link</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 右驱动轮  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;right_wheel&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">visual</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">geometry</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">cylinder</span> <span class="hljs-attr">radius</span>=<span class="hljs-string">&quot;0.0325&quot;</span> <span class="hljs-attr">length</span>=<span class="hljs-string">&quot;0.015&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">geometry</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">origin</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&quot;0 0 0&quot;</span> <span class="hljs-attr">rpy</span>=<span class="hljs-string">&quot;1.5705 0 0&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">material</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;black&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">rgba</span>=<span class="hljs-string">&quot;0.0 0.0 0.0 1.0&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">material</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">visual</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">link</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- joint：左轮与底盘  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">joint</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;left2link&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;continuous&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span> <span class="hljs-attr">link</span> =<span class="hljs-string">&quot;base_link&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">link</span>=<span class="hljs-string">&quot;left_wheel&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">origin</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&quot;0   0.1 -0.0225&quot;</span> <span class="hljs-attr">rpy</span>=<span class="hljs-string">&quot;0 0 0&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">axis</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&quot;0 1 0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">joint</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- joint：右轮与底盘  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">joint</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;right2link&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;continuous&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span> <span class="hljs-attr">link</span> =<span class="hljs-string">&quot;base_link&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">link</span>=<span class="hljs-string">&quot;right_wheel&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">origin</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&quot;0   -0.1 -0.0225&quot;</span> <span class="hljs-attr">rpy</span>=<span class="hljs-string">&quot;0 0 0&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">axis</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&quot;0 1 0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">joint</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 前万向轮  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;front_wheel&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">visual</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">geometry</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">sphere</span> <span class="hljs-attr">radius</span>=<span class="hljs-string">&quot;0.015&quot;</span>  /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">geometry</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">origin</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&quot;0 0 0&quot;</span> <span class="hljs-attr">rpy</span>=<span class="hljs-string">&quot;1.5705 0 0&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">material</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;black&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">rgba</span>=<span class="hljs-string">&quot;0.0 0.0 0.0 1.0&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">material</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">visual</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">link</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- 后万向轮  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;back_wheel&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">visual</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">geometry</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">sphere</span> <span class="hljs-attr">radius</span>=<span class="hljs-string">&quot;0.015&quot;</span>  /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">geometry</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">origin</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&quot;0 0 0&quot;</span> <span class="hljs-attr">rpy</span>=<span class="hljs-string">&quot;1.5705 0 0&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">material</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;black&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">rgba</span>=<span class="hljs-string">&quot;0.0 0.0 0.0 1.0&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">material</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">visual</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">link</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- joint：万向轮与底盘  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">joint</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;front2link&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;continuous&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span> <span class="hljs-attr">link</span> =<span class="hljs-string">&quot;base_link&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">link</span>=<span class="hljs-string">&quot;front_wheel&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">origin</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&quot;0.08  0 -0.0475&quot;</span> <span class="hljs-attr">rpy</span>=<span class="hljs-string">&quot;0 0 0&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">axis</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&quot;0 1 0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">joint</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- joint：万向轮与底盘  --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">joint</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;back2link&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;continuous&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span> <span class="hljs-attr">link</span> =<span class="hljs-string">&quot;base_link&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">link</span>=<span class="hljs-string">&quot;back_wheel&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">origin</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&quot;-0.08  0 -0.0475&quot;</span> <span class="hljs-attr">rpy</span>=<span class="hljs-string">&quot;0 0 0&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">axis</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&quot;0 1 0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">joint</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">robot</span>&gt;</span><br></code></pre></td></tr></table></figure><p>模型中几个joint偏移量的解释：</p><p>(1)joint:<code> left2link</code>   y是车体半径 z是车体中心高度 - 轮子半径</p><p>(2)joint: <code>front2link</code> 几何推导类似 略</p><p>launch文件集成：其中<strong>urdf文件通过param启动！</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robot_description&quot;</span> <span class="hljs-attr">textfile</span>=<span class="hljs-string">&quot;$(find demo_urdf)/urdf/urdf/demo_test.urdf&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;rviz&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;rviz&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;rviz&quot;</span> <span class="hljs-attr">args</span>=<span class="hljs-string">&quot;-d $(find demo_urdf)/config/demo1.rviz&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>3.URDF常用工具</strong></p><p>（1）check_urdf 语法检查 <code>check_urdf   demo.urdf</code></p><p>（2）urdf_to_graphiz 结构查看  <code>urdf_to_graphiz  xxx</code>会生成 urdf 模型结构pdf文件保存到xxx目录下</p><h3 id="URDF优化——xacro"><a href="#URDF优化——xacro" class="headerlink" title="URDF优化——xacro"></a>URDF优化——xacro</h3><p>普通urdf的问题及解决：</p><ul><li>代码复用 —— Xacro宏（函数）</li><li>参数设计 —— Xacro变量</li></ul><p>示例程序：Xacro文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">robot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mycar&quot;</span> <span class="hljs-attr">xmlns:xacro</span>=<span class="hljs-string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 属性封装 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xacro:property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;wheel_radius&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.0325&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xacro:property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;wheel_length&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.0015&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xacro:property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;PI&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3.1415927&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xacro:property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;base_link_length&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.08&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xacro:property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lidi_space&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;0.015&quot;</span> /&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 宏 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xacro:macro</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;wheel_func&quot;</span> <span class="hljs-attr">params</span>=<span class="hljs-string">&quot;wheel_name flag&quot;</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;$&#123;wheel_name&#125;_wheel&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">visual</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">geometry</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">cylinder</span> <span class="hljs-attr">radius</span>=<span class="hljs-string">&quot;$&#123;wheel_radius&#125;&quot;</span> <span class="hljs-attr">length</span>=<span class="hljs-string">&quot;$&#123;wheel_length&#125;&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">geometry</span>&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">origin</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&quot;0 0 0&quot;</span> <span class="hljs-attr">rpy</span>=<span class="hljs-string">&quot;$&#123;PI / 2&#125; 0 0&quot;</span> /&gt;</span><br><br>                <span class="hljs-tag">&lt;<span class="hljs-name">material</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;wheel_color&quot;</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">color</span> <span class="hljs-attr">rgba</span>=<span class="hljs-string">&quot;0 0 0 0.3&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">material</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">visual</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">link</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 3-2.joint --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">joint</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;$&#123;wheel_name&#125;2link&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;continuous&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">parent</span> <span class="hljs-attr">link</span>=<span class="hljs-string">&quot;base_link&quot;</span>  /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">link</span>=<span class="hljs-string">&quot;$&#123;wheel_name&#125;_wheel&quot;</span> /&gt;</span><br>            <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">                x 无偏移</span><br><span class="hljs-comment">                y 车体半径</span><br><span class="hljs-comment">                z z= 车体高度 / 2 + 离地间距 - 车轮半径</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">origin</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&quot;0 $&#123;0.1 * flag&#125; $&#123;(base_link_length / 2 + lidi_space - wheel_radius) * -1&#125;&quot;</span> <span class="hljs-attr">rpy</span>=<span class="hljs-string">&quot;0 0 0&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">axis</span> <span class="hljs-attr">xyz</span>=<span class="hljs-string">&quot;0 1 0&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">joint</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">xacro:macro</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xacro:wheel_func</span> <span class="hljs-attr">wheel_name</span>=<span class="hljs-string">&quot;left&quot;</span> <span class="hljs-attr">flag</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xacro:wheel_func</span> <span class="hljs-attr">wheel_name</span>=<span class="hljs-string">&quot;right&quot;</span> <span class="hljs-attr">flag</span>=<span class="hljs-string">&quot;-1&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">robot</span>&gt;</span><br></code></pre></td></tr></table></figure><p>1.Xacro语法详解</p><p>（1）在使用 xacro 生成 urdf 时，根标签<code>robot</code>中必须包含命名空间声明:<code>xmlns:xacro=&quot;http://wiki.ros.org/xacro&quot;</code></p><p>（2）<strong>属性</strong>：用于封装 URDF 中的一些字段，比如: PAI 值，小车的尺寸，轮子半径 ….</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;xacro:<span class="hljs-built_in">property</span>  name=<span class="hljs-string">&quot;xxxx&quot;</span>  value=<span class="hljs-string">&quot;yyyy&quot;</span> /&gt;  <span class="hljs-comment">#属性定义</span><br>    <br>&lt;my_varible   length = <span class="hljs-string">&quot;$&#123;属性名称&#125;&quot;</span>&gt;  <span class="hljs-comment">#调用</span><br>&lt;my_varible   radius = <span class="hljs-string">&quot;$&#123;数学表达式&#125;&quot;</span>&gt;  <span class="hljs-comment">#数学运算</span><br></code></pre></td></tr></table></figure><p>（3）宏：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;xacro:macro  name=<span class="hljs-string">&quot;宏名称&quot;</span> params=<span class="hljs-string">&quot;参数列表(多参数之间使用空格分隔)&quot;</span>&gt;  <span class="hljs-comment">#宏定义</span><br>...<br>&lt;/xacro:macro&gt;<br>    <br>&lt;xacro:宏名称  参数<span class="hljs-number">1</span>=xxx  参数<span class="hljs-number">2</span>=xxx/&gt; <span class="hljs-comment">#调用</span><br></code></pre></td></tr></table></figure><p>（4）文件包含：机器人由多部件组成，不同部件可能封装为单独的 xacro 文件；最后再将不同的文件集成，组合为完整机器人</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;robot name=<span class="hljs-string">&quot;xxx&quot;</span>  xmlns:xacro=<span class="hljs-string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;<br>      &lt;xacro:include  filename=<span class="hljs-string">&quot;my_base.xacro&quot;</span> /&gt;<br>      &lt;xacro:include  filename=<span class="hljs-string">&quot;my_camera.xacro&quot;</span> /&gt;<br>      &lt;xacro:include  filename=<span class="hljs-string">&quot;my_laser.xacro&quot;</span> /&gt;<br>      ....<br>&lt;/robot&gt;<br></code></pre></td></tr></table></figure><p>2.Xacro完整流程实现——优化小车底盘模型</p><ul><li>流程：</li></ul><p>编写xacro文件 + 将xacro文件集成到launch文件中</p><ul><li>实现：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;robot name=<span class="hljs-string">&quot;my_base&quot;</span> xmlns:xacro=<span class="hljs-string">&quot;http://www.ros.org/wiki/xacro&quot;</span>&gt;<br>    <br>    <span class="hljs-comment">#底盘</span><br>    &lt;xacro:<span class="hljs-built_in">property</span> name=<span class="hljs-string">&quot;PI&quot;</span> value=<span class="hljs-string">&quot;3.141&quot;</span>/&gt; <span class="hljs-comment">#封装变量、常量</span><br>        <br>    &lt;xacro:<span class="hljs-built_in">property</span> name=<span class="hljs-string">&quot;base_footprint_radius&quot;</span> value=<span class="hljs-string">&quot;0.001&quot;</span> /&gt;   <span class="hljs-comment">#封装base_footprint 半径等等</span><br>    &lt;xacro:<span class="hljs-built_in">property</span> name=<span class="hljs-string">&quot;base_link_radius&quot;</span> value=<span class="hljs-string">&quot;0.1&quot;</span> /&gt; <br>    &lt;xacro:<span class="hljs-built_in">property</span> name=<span class="hljs-string">&quot;base_link_length&quot;</span> value=<span class="hljs-string">&quot;0.08&quot;</span> /&gt;<br>    &lt;xacro:<span class="hljs-built_in">property</span> name=<span class="hljs-string">&quot;earth_space&quot;</span> value=<span class="hljs-string">&quot;0.015&quot;</span> /&gt;<br><br>    &lt;material name=<span class="hljs-string">&quot;black&quot;</span>&gt;<br>        &lt;color rgba=<span class="hljs-string">&quot;0.0 0.0 0.0 1.0&quot;</span> /&gt;<br>    &lt;/material&gt;<br><br>    &lt;link name=<span class="hljs-string">&quot;base_footprint&quot;</span>&gt;<br>      &lt;visual&gt;<br>        &lt;geometry&gt;<br>          &lt;sphere radius=<span class="hljs-string">&quot;$&#123;base_footprint_radius&#125;&quot;</span> /&gt;<br>        &lt;/geometry&gt;<br>      &lt;/visual&gt;<br>    &lt;/link&gt;<br><br>    &lt;link name=<span class="hljs-string">&quot;base_link&quot;</span>&gt;<br>      &lt;visual&gt;<br>        &lt;geometry&gt;<br>          &lt;cylinder radius=<span class="hljs-string">&quot;$&#123;base_link_radius&#125;&quot;</span> length=<span class="hljs-string">&quot;$&#123;base_link_length&#125;&quot;</span> /&gt;<br>        &lt;/geometry&gt;<br>        &lt;origin xyz=<span class="hljs-string">&quot;0 0 0&quot;</span> rpy=<span class="hljs-string">&quot;0 0 0&quot;</span> /&gt;<br>        &lt;material name=<span class="hljs-string">&quot;yellow&quot;</span>&gt;<br>          &lt;color rgba=<span class="hljs-string">&quot;0.5 0.3 0.0 0.5&quot;</span> /&gt;<br>        &lt;/material&gt;<br>      &lt;/visual&gt;<br>    &lt;/link&gt;<br><br>    &lt;joint name=<span class="hljs-string">&quot;base_link2base_footprint&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;fixed&quot;</span>&gt;<br>      &lt;parent link=<span class="hljs-string">&quot;base_footprint&quot;</span> /&gt;<br>      &lt;child link=<span class="hljs-string">&quot;base_link&quot;</span> /&gt;<br>      &lt;origin xyz=<span class="hljs-string">&quot;0 0 $&#123;earth_space + base_link_length / 2 &#125;&quot;</span> /&gt;<br>    &lt;/joint&gt;<br><br>    <span class="hljs-comment">#驱动轮</span><br>    &lt;xacro:<span class="hljs-built_in">property</span> name=<span class="hljs-string">&quot;wheel_radius&quot;</span> value=<span class="hljs-string">&quot;0.0325&quot;</span> /&gt;  <span class="hljs-comment">#封装驱动轮属性</span><br>    &lt;xacro:<span class="hljs-built_in">property</span> name=<span class="hljs-string">&quot;wheel_length&quot;</span> value=<span class="hljs-string">&quot;0.015&quot;</span> /&gt;<br><br>    &lt;xacro:macro name=<span class="hljs-string">&quot;add_wheels&quot;</span> params=<span class="hljs-string">&quot;name flag&quot;</span>&gt;  <span class="hljs-comment">#驱动轮宏  name是left/right    flag是1/-1 表示左或右</span><br>      &lt;link name=<span class="hljs-string">&quot;$&#123;name&#125;_wheel&quot;</span>&gt;<br>        &lt;visual&gt;<br>          &lt;geometry&gt;<br>            &lt;cylinder radius=<span class="hljs-string">&quot;$&#123;wheel_radius&#125;&quot;</span> length=<span class="hljs-string">&quot;$&#123;wheel_length&#125;&quot;</span> /&gt;<br>          &lt;/geometry&gt;<br>          &lt;origin xyz=<span class="hljs-string">&quot;0.0 0.0 0.0&quot;</span> rpy=<span class="hljs-string">&quot;$&#123;PI / 2&#125; 0.0 0.0&quot;</span> /&gt;<br>          &lt;material name=<span class="hljs-string">&quot;black&quot;</span> /&gt;<br>        &lt;/visual&gt;<br>      &lt;/link&gt;<br><br>      &lt;joint name=<span class="hljs-string">&quot;$&#123;name&#125;_wheel2base_link&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;continuous&quot;</span>&gt;<br>        &lt;parent link=<span class="hljs-string">&quot;base_link&quot;</span> /&gt;<br>        &lt;child link=<span class="hljs-string">&quot;$&#123;name&#125;_wheel&quot;</span> /&gt;<br>        &lt;origin xyz=<span class="hljs-string">&quot;0 $&#123;flag * base_link_radius&#125; $&#123;-(earth_space + base_link_length / 2 - wheel_radius) &#125;&quot;</span> /&gt;<br>        &lt;axis xyz=<span class="hljs-string">&quot;0 1 0&quot;</span> /&gt;<br>      &lt;/joint&gt;<br>    &lt;/xacro:macro&gt;<br>    &lt;xacro:add_wheels name=<span class="hljs-string">&quot;left&quot;</span> flag=<span class="hljs-string">&quot;1&quot;</span> /&gt;<br>    &lt;xacro:add_wheels name=<span class="hljs-string">&quot;right&quot;</span> flag=<span class="hljs-string">&quot;-1&quot;</span> /&gt;<br>        <br>        <br>    <span class="hljs-comment">#万向轮</span><br>    &lt;xacro:<span class="hljs-built_in">property</span> name=<span class="hljs-string">&quot;support_wheel_radius&quot;</span> value=<span class="hljs-string">&quot;0.0075&quot;</span> /&gt;  <span class="hljs-comment">#封装万向轮属性</span><br><br>    &lt;xacro:macro name=<span class="hljs-string">&quot;add_support_wheel&quot;</span> params=<span class="hljs-string">&quot;name flag&quot;</span> &gt;  <span class="hljs-comment">#封装宏</span><br>      &lt;link name=<span class="hljs-string">&quot;$&#123;name&#125;_wheel&quot;</span>&gt;<br>        &lt;visual&gt;<br>            &lt;geometry&gt;<br>                &lt;sphere radius=<span class="hljs-string">&quot;$&#123;support_wheel_radius&#125;&quot;</span> /&gt;<br>            &lt;/geometry&gt;<br>            &lt;origin xyz=<span class="hljs-string">&quot;0 0 0&quot;</span> rpy=<span class="hljs-string">&quot;0 0 0&quot;</span> /&gt;<br>            &lt;material name=<span class="hljs-string">&quot;black&quot;</span> /&gt;<br>        &lt;/visual&gt;<br>      &lt;/link&gt;<br><br>      &lt;joint name=<span class="hljs-string">&quot;$&#123;name&#125;_wheel2base_link&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;continuous&quot;</span>&gt;<br>          &lt;parent link=<span class="hljs-string">&quot;base_link&quot;</span> /&gt;<br>          &lt;child link=<span class="hljs-string">&quot;$&#123;name&#125;_wheel&quot;</span> /&gt;<br>          &lt;origin xyz=<span class="hljs-string">&quot;$&#123;flag * (base_link_radius - support_wheel_radius)&#125; 0 $&#123;-(base_link_length / 2 + earth_space / 2)&#125;&quot;</span> /&gt;<br>          &lt;axis xyz=<span class="hljs-string">&quot;1 1 1&quot;</span> /&gt;<br>      &lt;/joint&gt;<br>    &lt;/xacro:macro&gt;<br><br>    &lt;xacro:add_support_wheel name=<span class="hljs-string">&quot;front&quot;</span> flag=<span class="hljs-string">&quot;1&quot;</span> /&gt;<br>    &lt;xacro:add_support_wheel name=<span class="hljs-string">&quot;back&quot;</span> flag=<span class="hljs-string">&quot;-1&quot;</span> /&gt;<br><br>&lt;/robot&gt;<br></code></pre></td></tr></table></figure><p><strong>在launch中集成：</strong></p><p>（1）方式1，先将xacro文件解析成urdf文件，再集成urdf文件；<code>textfile</code></p><p>（2）方式2，直接集成xacro文件<strong>（推荐）</strong><code>command</code></p><p>​                            属性值就是<strong>调用 xacro 功能包</strong>的 xacro 程序直接解析 xacro 文件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robot_description&quot;</span> <span class="hljs-attr">command</span>=<span class="hljs-string">&quot;$(find xacro)/xacro $(find demo01_urdf_helloworld)/urdf/xacro/my_base.urdf.xacro&quot;</span> /&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;rviz&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;rviz&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;rviz&quot;</span> <span class="hljs-attr">args</span>=<span class="hljs-string">&quot;-d $(find demo01_urdf_helloworld)/config/helloworld.rviz&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;joint_state_publisher&quot;</span> <span class="hljs-attr">output</span>=<span class="hljs-string">&quot;screen&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;robot_state_publisher&quot;</span> <span class="hljs-attr">output</span>=<span class="hljs-string">&quot;screen&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;joint_state_publisher_gui&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;joint_state_publisher_gui&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;joint_state_publisher_gui&quot;</span> <span class="hljs-attr">output</span>=<span class="hljs-string">&quot;screen&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><p>一般在项目中，有多个xacro文件分别用于实现多个机器人部件（例如底盘、摄像头、雷达等）</p><p>通常情况下：<strong>先用一个新的xacro文件将这些零散的xacro文件先集成起来</strong>，<strong>然后在launch文件中启动最后这个xacro文件</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">robot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;my_car_camera&quot;</span> <span class="hljs-attr">xmlns:xacro</span>=<span class="hljs-string">&quot;http://wiki.ros.org/xacro&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xacro:include</span> <span class="hljs-attr">filename</span>=<span class="hljs-string">&quot;my_base.urdf.xacro&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xacro:include</span> <span class="hljs-attr">filename</span>=<span class="hljs-string">&quot;my_camera.urdf.xacro&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">xacro:include</span> <span class="hljs-attr">filename</span>=<span class="hljs-string">&quot;my_laser.urdf.xacro&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">robot</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.解析xacro文件（用xacro文件生成urdf文件）</p><p>执行<code>rosrun  xacro  xacro  xxx.xacro &gt; xxx.urdf</code></p><h3 id="在Rviz中控制机器人运动——Arbotix"><a href="#在Rviz中控制机器人运动——Arbotix" class="headerlink" title="在Rviz中控制机器人运动——Arbotix"></a>在Rviz中控制机器人运动——<strong>Arbotix</strong></h3><p>Arbotix 是一款控制电机、舵机的控制板，<strong>并提供相应的 ros 功能包</strong>，这个功能包的功能不仅可以驱动真实的 Arbotix 控制板，它还提供一个差速控制器，通过接受速度控制指令更新机器人的 joint 状态，从而帮助我们实现机器人在 rviz 中的运动。</p><p>1.添加 Arbotix 配置文件</p><p>举例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">controllers:</span> &#123;<br>   <span class="hljs-comment"># 单控制器设置</span><br>   <span class="hljs-attr">base_controller:</span> &#123;<br>          <span class="hljs-comment">#类型: 差速控制器</span><br>       <span class="hljs-attr">type:</span> <span class="hljs-string">diff_controller</span>,<br>       <span class="hljs-comment">#参考坐标</span><br>       <span class="hljs-attr">base_frame_id:</span> <span class="hljs-string">base_footprint</span>, <br>       <span class="hljs-comment">#两个轮子之间的间距</span><br>       <span class="hljs-attr">base_width:</span> <span class="hljs-number">0.2</span>,<br>       <span class="hljs-comment">#控制频率</span><br>       <span class="hljs-attr">ticks_meter:</span> <span class="hljs-number">2000</span>, <br>       <span class="hljs-comment">#PID控制参数，使机器人车轮快速达到预期速度</span><br>       <span class="hljs-attr">Kp:</span> <span class="hljs-number">12</span>, <br>       <span class="hljs-attr">Kd:</span> <span class="hljs-number">12</span>, <br>       <span class="hljs-attr">Ki:</span> <span class="hljs-number">0</span>, <br>       <span class="hljs-attr">Ko:</span> <span class="hljs-number">50</span>, <br>       <span class="hljs-comment">#加速限制</span><br>       <span class="hljs-attr">accel_limit:</span> <span class="hljs-number">1.0</span> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.集成到launch文件中</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;node name=<span class="hljs-string">&quot;arbotix&quot;</span> pkg=<span class="hljs-string">&quot;arbotix_python&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;arbotix_driver&quot;</span> output=<span class="hljs-string">&quot;screen&quot;</span>&gt; <br><span class="hljs-comment">#&lt;node&gt; 调用了 arbotix_python 功能包下的 arbotix_driver 节点</span><br><br>     &lt;rosparam file=<span class="hljs-string">&quot;$(find my_urdf05_rviz)/config/hello.yaml&quot;</span> command=<span class="hljs-string">&quot;load&quot;</span> /&gt;<br>    <span class="hljs-comment">#&lt;rosparam&gt; arbotix 驱动机器人运行时，需要获取机器人信息，可以通过 file 加载配置文件</span><br>    <br>     &lt;param name=<span class="hljs-string">&quot;sim&quot;</span> value=<span class="hljs-string">&quot;true&quot;</span> /&gt;<br>    <span class="hljs-comment">#&lt;param&gt; 在仿真环境下，需要配置 sim 为 true</span><br>&lt;/node&gt;<br></code></pre></td></tr></table></figure><p>3.启动launch文件，在rviz中设置参考坐标系为odom；并发布消息控制机器人运动</p>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>github：开源项目寻找途径</title>
    <link href="/2021/05/11/github%EF%BC%9A%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AF%BB%E6%89%BE%E9%80%94%E5%BE%84/"/>
    <url>/2021/05/11/github%EF%BC%9A%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AF%BB%E6%89%BE%E9%80%94%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p>众所周知，在搭建项目时，人们往往是面向github开发[doge]，然而如何快速找到高质量地项目源码，需要前人的经验传承[doge]，本文简要记载一些开源项目的寻找途径&amp;检索技巧。</p><span id="more"></span><p>内容来自b站up主，视频地址：<a href="https://www.bilibili.com/video/BV1e541137Tc">https://www.bilibili.com/video/BV1e541137Tc</a></p><h1 id="寻找开源项目的途径"><a href="#寻找开源项目的途径" class="headerlink" title="寻找开源项目的途径"></a>寻找开源项目的途径</h1><p>1.掘金社区：<a href="https://juejin.cn/">掘金 - 代码不止，掘金不停 (juejin.cn)</a></p><p>2.Trending：<a href="https://github.com/trending/">https://github.com/trending/</a> </p><p>3.HelloGitHub：<a href="https://github.com/521xueweihan/HelloGitHub">https://github.com/521xueweihan/HelloGitHub</a>  </p><p>推荐github上新颖项目的媒体，可根据不同编程语言检索</p><p>4.阮一峰老师：<a href="https://github.com/ruanyf/weekly">https://github.com/ruanyf/weekly</a></p><p>科技爱好者周刊，科技新闻</p><h2 id="特殊的github官网搜索小技巧-——-前后缀"><a href="#特殊的github官网搜索小技巧-——-前后缀" class="headerlink" title="特殊的github官网搜索小技巧 —— 前后缀"></a>特殊的github官网搜索小技巧 —— 前后缀</h2><ol><li>找百科大全：<code>awesome xxx</code> 非常有用</li><li>找例子：<code>xxx sample</code></li><li>找空项目架子： <code>xxx starter/ xxx boilerplate</code> 一个项目从头开始搭建往往比较困难，直接借用别人的</li><li>找教程：<code>xxx tutorial</code></li></ol>]]></content>
    
    
    <categories>
      
      <category>Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>系统学习ROS：问题篇1</title>
    <link href="/2021/04/17/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ROS%EF%BC%9A%E9%97%AE%E9%A2%98%E7%AF%871/"/>
    <url>/2021/04/17/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ROS%EF%BC%9A%E9%97%AE%E9%A2%98%E7%AF%871/</url>
    
    <content type="html"><![CDATA[<p>跑项目时经常会由于环境、路径等引发一系列问题，问题篇记录我在跑实例过程中遇到的<strong>问题以及解决方法</strong>。</p><span id="more"></span><h4 id="我在第一次跑程序时遇到的问题："><a href="#我在第一次跑程序时遇到的问题：" class="headerlink" title="我在第一次跑程序时遇到的问题："></a>我在第一次跑程序时遇到的问题：</h4><p>（1）我的环境：</p><ul><li><p>ROS melodic桌面完整版</p></li><li><p>根据教程配置好的VS Code</p></li><li><p>Ubuntu内装有anaconda</p></li><li><p>Ubuntu自带python2、python3</p></li></ul><p>（2）问题：</p><p>写好Client节点后，运行launch文件报错，并且只出现一只乌龟。</p><p>（3）解决过程</p><p>首先确定是<strong>python解释器问题</strong>，ROS Melodic的默认环境是python2, 最新发布的ROS noetic才完全支持python3。但是我们编写程序时用的是python3，所以需要使用python3解释器。</p><p>如果使用网上推荐的方法：创建python2到python3的软链接，虽然会将解释器自动链接为python3，但由于某些神秘力量，创建软链接后居然连roscore都打不开了！终端也打不开！（现在也未知原因）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sudo ln -s /usr/<span class="hljs-built_in">bin</span>/python3 /usr/<span class="hljs-built_in">bin</span>/python<br></code></pre></td></tr></table></figure><p>所以我们删除软链接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sudo rm /usr/<span class="hljs-built_in">bin</span>/python<br></code></pre></td></tr></table></figure><p>然后采用另一种方法：</p><p>这种方法直接使用 python3，但存在问题: 不兼容之前的 ROS 相关 python 实现。</p><p>在所有python文件头部，添加：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br></code></pre></td></tr></table></figure><p>之后即可正常运行！</p><p>总结：如果遇到python文件无法运行的情况，在所有在所有python文件头部，添加<code>#!/usr/bin/env python3</code></p>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>系统学习ROS（三）</title>
    <link href="/2021/04/17/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ROS%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2021/04/17/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ROS%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>在实践中学习，本节介绍第一个上手案例：乌龟自动跟随</p><p>IDE：VS Code</p><span id="more"></span><p><strong>学习地址（全文参考）</strong>：<a href="http://www.autolabor.com.cn/book/ROSTutorials/">http://www.autolabor.com.cn/book/ROSTutorials/</a></p><p>实操：乌龟跟随案例**</p><ul><li><strong>流程：</strong></li></ul><p>（1）创建功能包，用Service模式创建一只跟随乌龟；</p><p>（2）编写发布方节点：发布两只乌龟的坐标</p><p>​                  <strong>疑问：</strong>为什么一定要通过发布方先订阅坐标信息再发布，不能由订阅方直接订阅乌龟坐标信息进行处理吗？</p><p>​                  解答：实际Publisher是<strong>将坐标转换消息发布到TF功能包中</strong>，Subscriber也是<strong>直接订阅TF中的坐标转换信息</strong> (tf2_ros.Buffer中已经缓存了发布到TF中的坐标转换消息)。所以我们需要一个Publisher节点来完成发布到TF中的工作！</p><p>（3）编写订阅方节点：解析坐标信息，并生成速度信息（带方向的速度，表示下一时刻要往哪走）</p><p>（4）最后通过<strong>launch文件集成上述节点</strong>。</p><ul><li><strong>实现：</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">1.</span>Client生成新乌龟<br><br><span class="hljs-comment">#1.导包</span><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> turtlesim.srv <span class="hljs-keyword">import</span> Spawn, SpawnRequest, SpawnResponse<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 2.初始化 ros 节点</span><br>    rospy.init_node(<span class="hljs-string">&quot;turtle_spawn_p&quot;</span>)<br>    <span class="hljs-comment"># 3.创建服务客户端</span><br>    client = rospy.ServiceProxy(<span class="hljs-string">&quot;/spawn&quot;</span>,Spawn)    <span class="hljs-comment">#话题名/spawn、消息类型turtlesim/Spawn</span><br>    <span class="hljs-comment"># 4.等待服务启动</span><br>    client.wait_for_service()<br>    <span class="hljs-comment"># 5.创建请求数据</span><br>    req = SpawnRequest()<br>    req.x = <span class="hljs-number">1.0</span>     <span class="hljs-comment">#新乌龟的坐标、名字</span><br>    req.y = <span class="hljs-number">1.0</span><br>    req.theta = <span class="hljs-number">3.14</span><br>    req.name = <span class="hljs-string">&quot;turtle2&quot;</span><br>    <span class="hljs-comment"># 6.发送请求并处理响应</span><br>    <span class="hljs-keyword">try</span>: <br>        response = client.call(req)      <span class="hljs-comment">#返回服务器端相应。根据消息类型，返回的信息是新乌龟的名称</span><br>        rospy.loginfo(<span class="hljs-string">&quot;乌龟创建成功，名字是:%s&quot;</span>,response.name)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        rospy.loginfo(<span class="hljs-string">&quot;服务调用失败....&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>Publisher实现说明：</strong></p><ul><li><p>前面的代码订阅一个乌龟的坐标系，所以话题名是固定的<code>turtle1/pose</code>，但是现在要订阅两个乌龟的坐标，话题分别是<code>turtle1/pose</code>、<code>turtle2/pose</code>，考虑通过传参args来实现<strong>复用</strong>。</p></li><li><p><strong>在launch文件中node下传入args</strong>，然后在节点实现文件中，用<strong>sys.argv调用参数</strong></p></li><li><p>这里是分别订阅两个坐标信息，分别计算它们与<code>world</code>坐标系的转换关系；而后面在Subscriber中才实现两个乌龟节点间的直接转换</p></li></ul><p>Tip：在launch文件中node下传入的args，传入的不仅仅是那一个参数，还有：文件全路径 + 传入的参数 + 节点名称 + 日志文件路径（<strong>4个</strong>）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2.</span>Publisher  先订阅乌龟坐标，再发布转换关系<br><br><span class="hljs-comment"># 1.导包</span><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">from</span> turtlesim.msg <span class="hljs-keyword">import</span> Pose<br><span class="hljs-keyword">from</span> geometry_msgs.msg <span class="hljs-keyword">import</span> TransformStamped<br><span class="hljs-keyword">import</span> tf2_ros<br><span class="hljs-keyword">import</span> tf_conversions<br><br>turtle_name = <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doPose</span>(<span class="hljs-params">pose</span>):</span><br>    <span class="hljs-comment"># rospy.loginfo(&quot;x = %.2f&quot;,pose.x)</span><br>    <span class="hljs-comment">#1.创建坐标系广播器</span><br>    broadcaster = tf2_ros.TransformBroadcaster()<br>    <span class="hljs-comment">#2.将 pose 信息转换成 TransFormStamped</span><br>    tfs = TransformStamped()<br>    tfs.header.frame_id = <span class="hljs-string">&quot;world&quot;</span><br>    tfs.header.stamp = rospy.Time.now()<br><br>    tfs.child_frame_id = turtle_name<br>    tfs.transform.translation.x = pose.x<br>    tfs.transform.translation.y = pose.y<br>    tfs.transform.translation.z = <span class="hljs-number">0.0</span><br><br>    qtn = tf_conversions.transformations.quaternion_from_euler(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, pose.theta)<br>    tfs.transform.rotation.x = qtn[<span class="hljs-number">0</span>]<br>    tfs.transform.rotation.y = qtn[<span class="hljs-number">1</span>]<br>    tfs.transform.rotation.z = qtn[<span class="hljs-number">2</span>]<br>    tfs.transform.rotation.w = qtn[<span class="hljs-number">3</span>]<br><br>    <span class="hljs-comment">#3.广播器发布 tfs</span><br>    broadcaster.sendTransform(tfs)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 2.初始化 ros 节点</span><br>    rospy.init_node(<span class="hljs-string">&quot;sub_tfs_p&quot;</span>)<br>    <br>    <span class="hljs-comment"># 3.解析传入的命名空间</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) != <span class="hljs-number">4</span>:      <span class="hljs-comment">#在launch文件中传入参数，应该解析到4个！！</span><br>        rospy.loginfo(<span class="hljs-string">&quot;参数个数不对！&quot;</span>)<br>        sys.exit(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        turtle_name = sys.argv[<span class="hljs-number">1</span>]   <span class="hljs-comment">#第2个参数就是我们真正传入的参数</span><br>    rospy.loginfo(<span class="hljs-string">&quot;--------乌龟:%s&quot;</span>,turtle_name)<br><br>    rospy.Subscriber(turtle_name + <span class="hljs-string">&quot;/pose&quot;</span>,Pose,doPose, queue_size=<span class="hljs-number">10</span>)    <span class="hljs-comment">#实现复用！！！</span><br>                                                                                                                        <span class="hljs-comment">##话题名称、消息类型、回调函数、队列长度</span><br>    <br>    <span class="hljs-comment">#     4.创建订阅对象</span><br>    <span class="hljs-comment">#     5.回调函数处理订阅的 pose 信息</span><br>    <span class="hljs-comment">#         5-1.创建 TF 广播器</span><br>    <span class="hljs-comment">#         5-2.将 pose 信息转换成 TransFormStamped</span><br>    <span class="hljs-comment">#         5-3.发布</span><br>    <span class="hljs-comment">#     6.spin</span><br>    rospy.spin()<br></code></pre></td></tr></table></figure><p>此时启动launch文件（launch中有乌龟节点、Client节点、Publisher节点），则Publisher就将乌龟坐标信息发布到了TF功能包中。启动rviz，添加TF插件就可看到啦！！</p><p><strong>Subscriber实现说明：</strong></p><ul><li><p>创建订阅对象buffer，它里面缓存有刚刚Publisher发布在TF中的坐标变换</p></li><li><p>现在需要从<code>turtle1</code>到<code>world</code>、<code>turtle2</code>到<code>world</code>的转换关系获得<code>turtle1</code>到<code>turtle2</code>的直接转换关系，使用<strong>buffer.lookup_transform( )函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#buffer.lookup_transform( )函数：</span><br><br> <span class="hljs-comment">#参数1：目标坐标系         </span><br> <span class="hljs-comment">#参数2：源坐标系          </span><br> <span class="hljs-comment">#参数3：rospy.Time(0) ---取时间间隔最近的两个坐标帧</span><br> <span class="hljs-comment">#返回值：turtle1 与 turtle2 的坐标系关系</span><br> <span class="hljs-comment">#两个坐标系的名称 与 Publisher中发布到TF中的child_frame_id一致</span><br> trans = buffer.lookup_transform(<span class="hljs-string">&quot;turtle2&quot;</span>,<span class="hljs-string">&quot;turtle1&quot;</span>,rospy.Time(<span class="hljs-number">0</span>))   <br>  <br> <span class="hljs-comment">#偏移量：</span><br>trans.transform.translation.x、trans.transform.translation.y、trans.transform.translation.z<br><span class="hljs-comment">#</span><br></code></pre></td></tr></table></figure></li><li><p>转换关系获得后，要计算turtle2的速度信息，<strong>最终发布速度信息以控制turtle2</strong>。速度信息使用的消息类型是Twist：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Twist消息类型</span><br>geometry_msgs/Vector3 linear<br>  float64 x<br>  float64 y<br>  float64 z<br>geometry_msgs/Vector3 angular<br>  float64 x<br>  float64 y<br>  float64 z<br></code></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">3.</span>Subscriber  将两个乌龟分别对`world`的转换关系变为两只乌龟之间直接的转换关系<br><br><span class="hljs-comment"># 1.导包</span><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">import</span> tf2_ros<br><span class="hljs-keyword">from</span> geometry_msgs.msg <span class="hljs-keyword">import</span> TransformStamped, Twist<br><span class="hljs-keyword">import</span> math<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 2.初始化 ros 节点</span><br>    rospy.init_node(<span class="hljs-string">&quot;sub_tfs_p&quot;</span>)<br>    <span class="hljs-comment"># 3.创建 TF 订阅对象</span><br>    buffer = tf2_ros.Buffer()<br>    listener = tf2_ros.TransformListener(buffer)<br>    <span class="hljs-comment"># 4.处理订阅到的 TF</span><br>    rate = rospy.Rate(<span class="hljs-number">10</span>)<br>    <span class="hljs-comment"># 创建速度发布对象</span><br>    pub = rospy.Publisher(<span class="hljs-string">&quot;/turtle2/cmd_vel&quot;</span>,Twist,queue_size=<span class="hljs-number">1000</span>)  <span class="hljs-comment">#控制turtle2运动，所以发布的话题是`turtle2/cmd_vel`, 消息类型是Twist</span><br>     <br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> rospy.is_shutdown():<br>        rate.sleep()<br>        <br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 计算两只乌龟之间的直接转换关系：buffer.lookup_transform( )函数</span><br>            trans = buffer.lookup_transform(<span class="hljs-string">&quot;turtle2&quot;</span>,<span class="hljs-string">&quot;turtle1&quot;</span>,rospy.Time(<span class="hljs-number">0</span>))   <br>            <br>            <span class="hljs-comment"># 组织Twist消息（见上方Publisher的创建，Twist消息）（通过得到的转换关系，计算目标速度）</span><br>            twist = Twist()<br>            twist.linear.x = <span class="hljs-number">0.5</span> * math.sqrt(math.<span class="hljs-built_in">pow</span>(trans.transform.translation.x,<span class="hljs-number">2</span>) + math.<span class="hljs-built_in">pow</span>(trans.transform.translation.y,<span class="hljs-number">2</span>))   <span class="hljs-comment">#线速度</span><br>            twist.angular.z = <span class="hljs-number">4</span> * math.atan2(trans.transform.translation.y, trans.transform.translation.x)  <span class="hljs-comment">#角速度</span><br>            <br>            <span class="hljs-comment">#发布Twist消息</span><br>            pub.publish(twist)<br><br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            rospy.logwarn(<span class="hljs-string">&quot;警告:%s&quot;</span>,e)<br></code></pre></td></tr></table></figure><p><strong>launch文件集成上述节点：</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;launch&gt;<br>    &lt;node pkg=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span> name=<span class="hljs-string">&quot;turtle1&quot;</span> output=<span class="hljs-string">&quot;screen&quot;</span> /&gt;<br>    &lt;node pkg=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;turtle_teleop_key&quot;</span> name=<span class="hljs-string">&quot;key_control&quot;</span> output=<span class="hljs-string">&quot;screen&quot;</span>/&gt;<br><br>    &lt;node pkg=<span class="hljs-string">&quot;demo_test_flow_p&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;test01_turtle_spawn_p.py&quot;</span> name=<span class="hljs-string">&quot;turtle_spawn&quot;</span> output=<span class="hljs-string">&quot;screen&quot;</span>/&gt;<br><br>    &lt;node pkg=<span class="hljs-string">&quot;demo_test_flow_p&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;test02_turtle_tf_pub_p.py&quot;</span> name=<span class="hljs-string">&quot;tf_pub1&quot;</span> args=<span class="hljs-string">&quot;turtle1&quot;</span> output=<span class="hljs-string">&quot;screen&quot;</span>/&gt;<br>    &lt;node pkg=<span class="hljs-string">&quot;demo_test_flow_p&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;test02_turtle_tf_pub_p.py&quot;</span> name=<span class="hljs-string">&quot;tf_pub2&quot;</span> args=<span class="hljs-string">&quot;turtle2&quot;</span> output=<span class="hljs-string">&quot;screen&quot;</span>/&gt;<br>    &lt;node pkg=<span class="hljs-string">&quot;demo_test_flow_p&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;test03_turtle_tf_sub_p.py&quot;</span> name=<span class="hljs-string">&quot;tf_sub&quot;</span> output=<span class="hljs-string">&quot;screen&quot;</span>/&gt;<br><br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure><p>总结：</p><p>乌龟跟随案例的实现完全应用TF功能包，实现了坐标转换计算。实现过程比较复杂、集成度较高，所以对于初学者这是很好的第一个上手项目。在敲代码之前，一定要理清楚<strong>每个节点在做什么事情、通过什么方法什么库来做的</strong>，才能算真正掌握这个项目。</p>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>系统学习ROS（二）</title>
    <link href="/2021/04/17/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ROS%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2021/04/17/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ROS%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>ROS运行管理(launch文件等)  &amp;  ROS内置组件之TF功能包</p><span id="more"></span><p><strong>学习地址（全文参考）</strong>：<a href="http://www.autolabor.com.cn/book/ROSTutorials/">http://www.autolabor.com.cn/book/ROSTutorials/</a></p><h4 id="八、ROS运行管理"><a href="#八、ROS运行管理" class="headerlink" title="八、ROS运行管理"></a>八、ROS运行管理</h4><p>1.元功能包</p><p>完成ROS中一个系统性的功能，可能涉及到多个功能包，在ROS中，提供了一种方式可以将不同的功能包打包成一个功能包，当安装某个功能模块时，直接调用打包后的功能包即可，该包又称之为元功能包(metapackage)。</p><p>即：元功能包是<strong>方便安装</strong>的。</p><p>实现：修改<code>package.xml</code> —&gt; 修改<code>CMakeList</code>          需要就查！</p><p><strong>2.launch文件</strong></p><p>launch 文件是一个 <strong>XML 格式</strong>的文件，可以启动本地和远程的多个节点，还可以在参数服务器中设置参数；简化节点的配置与启动，<strong>提高ROS程序的启动效率</strong>。</p><p>实现流程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在功能包下新建launch文件夹</span><br>      <span class="hljs-comment">#梳理一下，此时功能包下有哪些文件夹：include、src(.cpp)、scripts(.py)、launch</span><br>    <br><span class="hljs-comment">#在launch文件夹下新建demo.launch文件</span><br><br><span class="hljs-comment">#调用launch文件</span><br>roslaunch  功能包名  xxx.launch<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;launch&gt;<br>    &lt;node pkg=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span>     name=<span class="hljs-string">&quot;myTurtle&quot;</span> output=<span class="hljs-string">&quot;screen&quot;</span> /&gt;<br>    &lt;node pkg=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;turtle_teleop_key&quot;</span>  name=<span class="hljs-string">&quot;myTurtleContro&quot;</span> output=<span class="hljs-string">&quot;screen&quot;</span> /&gt;<br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure><p>（1）<launch>标签：</launch></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#属性</span><br>&lt;launch deprecated = <span class="hljs-string">&quot;弃用声明&quot;</span>&gt;      <span class="hljs-comment">#表示该节点不用了</span><br><br><span class="hljs-comment">#子集标签</span><br>所有其他标签都是launch的子集<br></code></pre></td></tr></table></figure><p>（2）<node>标签：</node></p><p>用于指定 ROS 节点，是最常见的标签，需要注意的是: roslaunch 命令<strong>不能保证按照 node 的声明顺序</strong>来启动节点(节点的启动是多进程的)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#属性</span><br>   pkg=<span class="hljs-string">&quot;包名&quot;</span>   <span class="hljs-comment">#节点所属的包</span><br>   <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;nodeType&quot;</span>   <span class="hljs-comment">#节点类型(与之相同名称的可执行文件) = 节点名</span><br>   name=<span class="hljs-string">&quot;nodeName&quot;</span>   <span class="hljs-comment">#节点名称(在 ROS 网络拓扑中节点的名称)，  随便设置，相当于给节点重命名</span><br>   args=<span class="hljs-string">&quot;xxx xxx xxx&quot;</span>       <span class="hljs-comment">#(可选)将参数传递给节点</span><br>   machine=<span class="hljs-string">&quot;机器名&quot;</span>      <span class="hljs-comment">#在指定机器上启动节点</span><br>   <br>   respawn=<span class="hljs-string">&quot;true | false&quot;</span>         <span class="hljs-comment">#(可选) 如果节点退出，是否自动重启   ---&gt; 例如激光雷达，不能因为意外关闭而停止，所以可为它设置该属性</span><br>   respawn_delay=<span class="hljs-string">&quot; N&quot;</span>         <span class="hljs-comment">#(可选) 如果 respawn 为 true, 那么延迟 N 秒后启动节点</span><br>   <br>   required=<span class="hljs-string">&quot;true | false&quot;</span>        <span class="hljs-comment">#(可选)该节点是否必须，如果为 true,那么如果该节点退出，将杀死整个 roslaunch</span><br>   ns=<span class="hljs-string">&quot;xxx&quot;</span>         <span class="hljs-comment">#(可选) 在指定命名空间 xxx 中启动节点  ---&gt; 在节点name前面加的前缀，也即命名空间  ---&gt;  避免重名问题</span><br>   clear_params=<span class="hljs-string">&quot;true | false&quot;</span>   <span class="hljs-comment"># (可选)在启动前，删除节点的私有空间的所有参数</span><br>   output=<span class="hljs-string">&quot;log | screen&quot;</span>       <span class="hljs-comment">#(可选)  日志发送目标，可以设置为 log 日志文件，或 screen 屏幕,默认是 log</span><br><br>   <br>   <span class="hljs-comment">#子集标签</span><br>   env  <span class="hljs-comment">#环境变量设置</span><br>   remap  <span class="hljs-comment">#重映射节点名称</span><br>   rosparam  <span class="hljs-comment">#参数设置</span><br>   param  <span class="hljs-comment">#参数设置</span><br></code></pre></td></tr></table></figure><p>（3）<include>标签</include></p><p>用于将另一个 xml 格式的 launch 文件导入到当前文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#属性</span><br>   file=<span class="hljs-string">&quot;$(find 包名)/xxx/xxx.launch&quot;</span>   <span class="hljs-comment">#要包含的文件路径  </span><br>   <span class="hljs-comment"># $&#123;find  包名&#125;是一种固定格式，自动寻找功能包所在路径，所以后面只需要给出launch文件在功能包下的相对路径即可</span><br>  <br>ns=<span class="hljs-string">&quot;xxx&quot;</span>    <span class="hljs-comment">#(可选) 在指定命名空间导入文件</span><br><br>   <br>   <span class="hljs-comment">#子集标签</span><br>   env  <span class="hljs-comment">#环境变量设置</span><br>   arg   <span class="hljs-comment">#将参数传递给被包含的文件</span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;launch&gt;<br>   &lt;include file=<span class="hljs-string">&quot;$&#123;find  功能包名&#125;/launch/demo1_turtle.launch&quot;</span> /&gt; <br>       ...<br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure><p>（4）<remap>标签（非常实用）</remap></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#属性</span><br>   <span class="hljs-keyword">from</span>=<span class="hljs-string">&quot;xxx&quot;</span>   <span class="hljs-comment">#原始话题名称</span><br>   to=<span class="hljs-string">&quot;yyy&quot;</span>   <span class="hljs-comment">#目标名称</span><br><br>   <span class="hljs-comment">#子集标签</span><br>   无<br></code></pre></td></tr></table></figure><ul><li>举例：乌龟键盘控制节点turtle_teleop_key局限性很大，通常使用<strong>ROS系统内置的键盘控制节点</strong>！</li></ul><p>问题：使用其他键盘控制节点，键盘发布速度控制信息，乌龟订阅信息，但是二者的话题不一样！！无法连接</p><p>​                键盘节点的话题名是/cmd_vel，乌龟节点的话题名是/turtle1/cmd_vel</p><ul><li>中一个话题名称，使用remap标签</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;launch&gt;<br>&lt;node pkg=<span class="hljs-string">&quot;turtlesim&quot;</span>  <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span>  name=<span class="hljs-string">&quot;my_turtle&quot;</span>  output=<span class="hljs-string">&quot;screen&quot;</span>&gt;<br>    &lt;remap <span class="hljs-keyword">from</span>=<span class="hljs-string">&quot;/turtle1/cmd_vel&quot;</span>  to=<span class="hljs-string">&quot;/cmd_vel&quot;</span>  /&gt;  <span class="hljs-comment">#重映射话题名</span><br>        &lt;/node&gt;  #使用了node子标签时，后面要用&lt;/node&gt;<br> &lt;/launch&gt;<br></code></pre></td></tr></table></figure><p>（5）<param>标签</p><p>用于在参数服务器上设置参数，参数源可以在标签中通过 <strong>value 指定</strong>，也可以通过<strong>外部文件加载</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#属性</span><br>   name=<span class="hljs-string">&quot;命名空间/参数名&quot;</span>    <span class="hljs-comment">#参数名称</span><br>   value=<span class="hljs-string">&quot;xxx&quot;</span>    <span class="hljs-comment">#(可选)定义参数值，如果此处省略，必须指定外部文件作为参数源</span><br>   <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;str | int | double | bool | yaml&quot;</span>    <span class="hljs-comment">#(可选)  指定参数类型，如果未指定，roslaunch 会尝试确定参数类型，规则如下:</span><br>                                                                                 <span class="hljs-comment">#如果包含 &#x27;.&#x27; 的数字解析未浮点型，否则为整型</span><br>                                                                                 <span class="hljs-comment">#&quot;true&quot; 和 &quot;false&quot; 是 bool 值(不区分大小写)</span><br>                                                                                 <span class="hljs-comment"># 其他是字符串</span><br><br>    <span class="hljs-comment">#子集标签</span><br>   无<br></code></pre></td></tr></table></figure><p>有<strong>两种方式</strong>使用param标签：</p><p>tip: 在node中设置会自动加上<strong>node的名称作为前缀</strong>，该前缀也成为<code>私有命名空间</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#方式1：在launch下，node外</span><br>&lt;launch&gt;<br>&lt;param name=<span class="hljs-string">&quot;param_A&quot;</span>  <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;int&quot;</span>  value=<span class="hljs-string">&quot;100&quot;</span> /&gt;   <span class="hljs-comment">#参数名称为param_A</span><br>    &lt;node....&gt;<br>&lt;/launch&gt;<br><br><span class="hljs-comment">#方式2：node下</span><br>&lt;launch&gt;<br>&lt;node pkg=<span class="hljs-string">&quot;turtlesim&quot;</span>  <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span>  name=<span class="hljs-string">&quot;my_turtle&quot;</span>  output=<span class="hljs-string">&quot;screen&quot;</span>&gt;<br>    &lt;param name=<span class="hljs-string">&quot;param_B&quot;</span>  <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;double&quot;</span>  value=<span class="hljs-string">&quot;3.14&quot;</span>  /&gt;   <span class="hljs-comment">#参数名称为my_turtle/param_B ,  即以node名称作为前缀</span><br>        &lt;/node&gt;<br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure><p>（6）<rosparam>标签</rosparam></p><p>可以从 <strong>YAML 文件导入参数</strong>，或将参数导出到 YAML 文件，也可以用来删除参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#属性</span><br>   command=<span class="hljs-string">&quot;load | dump | delete&quot;</span>  <span class="hljs-comment">#(可选，默认 load)       </span><br>      <span class="hljs-comment">#加载、导出或删除参数</span><br>   file=<span class="hljs-string">&quot;$(find xxxxx)/xxx/yyy....&quot;</span>  <span class="hljs-comment">#加载或导出到的 yaml 文件</span><br>   param=<span class="hljs-string">&quot;参数名称&quot;</span><br>   ns=<span class="hljs-string">&quot;命名空间&quot;</span>   <span class="hljs-comment">#(可选)</span><br></code></pre></td></tr></table></figure><p>rosparam也有两种方式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#方式1：在launch下，node外</span><br>&lt;launch&gt;<br>&lt;rosparam  command=<span class="hljs-string">&quot;load&quot;</span>  file= <span class="hljs-string">&quot;$&#123;find  demo_launch1&#125;/launch/param_test.yaml&quot;</span> /&gt;   <span class="hljs-comment">#从yaml文件加载参数</span><br>    &lt;node....&gt;<br>&lt;/launch&gt;<br><br><span class="hljs-comment">#方式2：node下</span><br>&lt;launch&gt;<br>&lt;node pkg=<span class="hljs-string">&quot;turtlesim&quot;</span>  <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span>  name=<span class="hljs-string">&quot;my_turtle&quot;</span>  output=<span class="hljs-string">&quot;screen&quot;</span>&gt;<br>    &lt;rosparam  command=<span class="hljs-string">&quot;load&quot;</span>  file=<span class="hljs-string">&quot;$&#123;find  demo_launch1&#125;/launch/param_test.yaml&quot;</span>  /&gt;   <br>        &lt;/node&gt;<br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#导出参数dump</span><br>&lt;launch&gt;<br>&lt;rosparam  command=<span class="hljs-string">&quot;dump&quot;</span>  file= <span class="hljs-string">&quot;$&#123;find  demo_launch1&#125;/launch/param_out.yaml&quot;</span> /&gt;   <br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure><p>注：导出文件的rosparam标签不能放在节点启动文件中，因为rosparam启动的优先级最高，所以会在node启动之前就导出参数，使得很多参数无法导出；因此通常做法：将dump<strong>写入一个新的launch文件</strong>。</p><p>（8）<group>标签</group></p><p>对<strong>节点分组</strong>，具有 ns 属性，可以让节点归属某个命名空间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#属性</span><br>   ns=<span class="hljs-string">&quot;名称空间&quot;</span>   <span class="hljs-comment">#(可选)</span><br>   clear_params=<span class="hljs-string">&quot;true | false&quot;</span>   <span class="hljs-comment">#(可选)启动前，是否删除组名称空间的所有参数(慎用....此功能危险)</span><br><br>   <span class="hljs-comment">#子标签</span><br>   除了launch 标签外的其他标签<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#启动两对乌龟、键盘控制节点，使他们不产生命名冲突</span><br>&lt;launch&gt;<br>&lt;group  ns=<span class="hljs-string">&quot;first&quot;</span>&gt;   <span class="hljs-comment">#第一个分组，命名空间是first</span><br>    &lt;node  pkg=<span class="hljs-string">&quot;turtlesim&quot;</span>  <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span>  name=<span class="hljs-string">&quot;my_turtle&quot;</span>  output=<span class="hljs-string">&quot;screen&quot;</span>  /&gt;<br>        &lt;node  pkg=<span class="hljs-string">&quot;turtlesim&quot;</span>  <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;turtle_teleop_key&quot;</span>  name=<span class="hljs-string">&quot;my_key&quot;</span>  output=<span class="hljs-string">&quot;screen&quot;</span>  /&gt;<br>        &lt;/group&gt;<br>        &lt;group  ns=<span class="hljs-string">&quot;second&quot;</span>&gt;   <span class="hljs-comment">#第二个分组，命名空间是second</span><br>        &lt;node  pkg=<span class="hljs-string">&quot;turtlesim&quot;</span>  <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span>  name=<span class="hljs-string">&quot;my_turtle&quot;</span>  output=<span class="hljs-string">&quot;screen&quot;</span>  /&gt;<br>            &lt;node  pkg=<span class="hljs-string">&quot;turtlesim&quot;</span>  <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;turtle_teleop_key&quot;</span>  name=<span class="hljs-string">&quot;my_key&quot;</span>  output=<span class="hljs-string">&quot;screen&quot;</span>  /&gt;<br>        &lt;/group&gt;<br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure><p>（9）<arg>标签</arg></p><p>用于<strong>动态传参</strong>，类似于<strong>函数的参数</strong>，可以增强launch文件的灵活性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#属性</span><br>   name=<span class="hljs-string">&quot;参数名称&quot;</span><br>   default=<span class="hljs-string">&quot;默认值&quot;</span>    <span class="hljs-comment">#(可选)</span><br>   value=<span class="hljs-string">&quot;数值&quot;</span>    <span class="hljs-comment">#(可选) 不可以与 default 并存</span><br>   doc=<span class="hljs-string">&quot;描述&quot;</span>   <span class="hljs-comment">#参数说明</span><br><br><span class="hljs-comment">#子标签</span><br>   无<br></code></pre></td></tr></table></figure><p>arg的作用：可以理解为方便<strong>参数复用</strong>，在小程序中无法体现其优越性，在<strong>复杂的机器人项目中其优势才得以体现</strong></p><p>假如我现在要设置三个参数A、B、C，它们都记录了同一个小车的尺寸：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#不使用arg标签</span><br>&lt;launch&gt;<br>&lt;param  name=<span class="hljs-string">&quot;A&quot;</span>  value=<span class="hljs-string">&quot;0.6&quot;</span>   /&gt;<br>     &lt;param  name=<span class="hljs-string">&quot;B&quot;</span>  value=<span class="hljs-string">&quot;0.6&quot;</span>   /&gt;<br>       &lt;param  name=<span class="hljs-string">&quot;C&quot;</span>  value=<span class="hljs-string">&quot;0.6&quot;</span>   /&gt;<br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用arg标签</span><br>&lt;launch&gt;<br>&lt;arg  name=<span class="hljs-string">&quot;car_length&quot;</span>  default=<span class="hljs-string">&quot;0.5&quot;</span>  /&gt;<br>    <br>        &lt;param  name=<span class="hljs-string">&quot;A&quot;</span>  value=<span class="hljs-string">&quot;$(arg  car_length)&quot;</span>   /&gt;  <span class="hljs-comment">#调用参数car_length</span><br>     &lt;param  name=<span class="hljs-string">&quot;B&quot;</span>  value=<span class="hljs-string">&quot;$(arg  car_length)&quot;</span>   /&gt;<br>       &lt;param  name=<span class="hljs-string">&quot;C&quot;</span>  value=<span class="hljs-string">&quot;$(arg  car_length)&quot;</span>   /&gt;<br> &lt;/launch&gt;<br><br><span class="hljs-comment">#体会arg的好处： 如果要更改小车尺寸，不用到冗长的launch文件里一个一个找、一个一个改，</span><br>                                    <span class="hljs-comment">#只用修改arg一处即可！</span><br></code></pre></td></tr></table></figure><p><strong>3.重名问题</strong></p><p>（1）功能包重名 —— “工作空间覆盖”</p><ul><li><p>说明：</p><p>自定义工作空间的功能包与<strong>内置的功能包</strong>可以重名或者<strong>不同的自定义的工作空间中</strong>也可以出现重名的功能包；</p><p>优先级：ROS 会解析 .bashrc 文件，并生成 ROS_PACKAGE_PATH ROS包路径，该变量中按照 .bashrc  中配置设置工作空间优先级，在设置时需要遵循一定的原则:ROS_PACKAGE_PATH 中的值，和 .bashrc  的配置顺序相反—&gt;后配置的优先级更高</p><p>功能包重名时，会按照 ROS_PACKAGE_PATH 查找，配置在前的会优先执行。</p></li></ul><p>每种问题都有3种途径：<strong>1.rosrun命令  2.launch文件  3.编码实现</strong></p><p><strong>（2）节点重名</strong></p><p>解决方法：1.重映射  2.加前缀(命名空间)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#rosrun命令</span><br><br><span class="hljs-comment">#1.设置命名空间  __ns:=</span><br>rosrun 包名 节点名 __ns:=新名称<br>rosrun  turtlesim  turtlesim_node   __ns:=/xxx<br>    <br><span class="hljs-comment">#2.重映射别名  __name:=</span><br>rosrun 包名 节点名   __name:=新名称<br>rosrun turtlesim  turtlesim_node   __name:=t1<br>rosrun turtlesim  turtlesim_node   __name:=t2 <br>    <br><span class="hljs-comment">#3.同时命名空间+重映射  __ns:=      __name:=</span><br> rosrun 包名 节点名   __ns:=新名称   __name:=新名称<br> rosrun  turtlesim  turtlesim_node   __ns:=/xxx   __name:=tn<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#launch文件</span><br>在 node 标签中有两个属性: name 和 ns，二者分别是用于实现名称重映射与命名空间设置的<br><br>&lt;launch&gt;<br><br>    &lt;node pkg=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span> name=<span class="hljs-string">&quot;t1&quot;</span> /&gt;  <span class="hljs-comment">#重映射</span><br>    &lt;node pkg=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span> name=<span class="hljs-string">&quot;t2&quot;</span> /&gt;<br>    &lt;node pkg=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span> name=<span class="hljs-string">&quot;t1&quot;</span> ns=<span class="hljs-string">&quot;hello&quot;</span>/&gt;   <span class="hljs-comment">#重映射+命名空间</span><br><br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#编码实现</span><br>如果自定义节点，则以更灵活的设置命名空间与重映射实现<br>rospy.init_node(<span class="hljs-string">&quot;lisi&quot;</span>,anonymous=<span class="hljs-literal">True</span>)  <span class="hljs-comment">#会在节点名称后缀时间戳</span><br></code></pre></td></tr></table></figure><p><strong>（3）话题重名</strong></p><p>两个节点是<strong>可以通信</strong>的，两个节点之间使用了相同的消息类型，但是由于，话题名称不同，导致通信失败</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#rosrun命令</span><br> rorun 包名 节点名 话题名:=新话题名称<br> rosrun  turtlesim  turtlesim_node   /turtle1/cmd_vel:=/cmd_vel<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#launch文件</span><br>&lt;launch&gt;<br><br>    &lt;node pkg=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span> name=<span class="hljs-string">&quot;t1&quot;</span> /&gt;<br>    &lt;node pkg=<span class="hljs-string">&quot;teleop_twist_keyboard&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;teleop_twist_keyboard.py&quot;</span> name=<span class="hljs-string">&quot;key&quot;</span>&gt;<br>        &lt;remap <span class="hljs-keyword">from</span>=<span class="hljs-string">&quot;/cmd_vel&quot;</span> to=<span class="hljs-string">&quot;/turtle1/cmd_vel&quot;</span> /&gt;   <span class="hljs-comment">#&lt;remap from=&quot;原话题&quot; to=&quot;新话题&quot; /&gt;</span><br>    &lt;/node&gt;<br><br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure><p><strong>话题名称</strong>的分类：</p><p>补充知识点（重要）：话题的名称与节点的命名空间、节点的名称是有一定关系的，<strong>话题名称</strong>大致可以分为三种类型</p><p>（如果有一个话题叫<code>liaotian</code>）：</p><ul><li>全局：参考ROS系统，<code>/liaotian</code>  /代表的是根目录  </li><li>相对：参考节点的命名空间， <code>/ergouzi/liaotian</code>  ergouzi是节点的命名空间  —&gt; 会以<code>节点的命名空间</code>作为前缀</li><li>私有：参考节点名称， <code>/ergouzi/wangqiang/liaotian</code>  wangqiang是节点名  —&gt; 会以<code>节点的命名空间+节点名</code>作为前缀</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#编码设置</span><br>假设现在初始化节点时，传递一个 __ns:= xxx<br>    <br><span class="hljs-comment">#1.全局</span><br><span class="hljs-comment">#话题命名为：以/开头的名称</span><br>pub = rospy.Publisher(<span class="hljs-string">&quot;/chatter&quot;</span>,String,queue_size=<span class="hljs-number">1000</span>)  <span class="hljs-comment">#/chatter</span><br>pub = rospy.Publisher(<span class="hljs-string">&quot;/chatter/money&quot;</span>,String,queue_size=<span class="hljs-number">1000</span>)  <span class="hljs-comment">#/chatter/money</span><br><br><span class="hljs-comment">#2.相对</span><br><span class="hljs-comment">#话题命名为：非/开头的名称</span><br>pub = rospy.Publisher(<span class="hljs-string">&quot;chatter&quot;</span>,String,queue_size=<span class="hljs-number">1000</span>)   <span class="hljs-comment">#xxx/chatter</span><br>pub = rospy.Publisher(<span class="hljs-string">&quot;chatter/money&quot;</span>,String,queue_size=<span class="hljs-number">1000</span>)   <span class="hljs-comment">#xxx/chatter/money</span><br><br><span class="hljs-comment">#3.私有</span><br><span class="hljs-comment">#话题命名为：以~开头的名称</span><br>pub = rospy.Publisher(<span class="hljs-string">&quot;~chatter&quot;</span>,String,queue_size=<span class="hljs-number">1000</span>)   <span class="hljs-comment">#/xxx/hello/chatter</span><br>pub = rospy.Publisher(<span class="hljs-string">&quot;~chatter/money&quot;</span>,String,queue_size=<span class="hljs-number">1000</span>)   <span class="hljs-comment">#/xxx/hello/chatter/money</span><br></code></pre></td></tr></table></figure><p><strong>（4）参数重名</strong></p><p>没有重映射实现，为了尽量的避免参数重名，都是使用为参数名<strong>添加前缀</strong>的方式，实现类似于话题名称。</p><p><strong>参数名称</strong>：也有<strong>全局、相对</strong>、和<strong>私有</strong>三种类型之分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#rosrun</span><br>rosrun 包名 节点名称 _参数名:=参数值<br>rosrun turtlesim turtlesim_node _A:=<span class="hljs-number">100</span>   <span class="hljs-comment">#/turtlesim/A=100</span><br>    <br><span class="hljs-comment">#说名：执行rosrun时设置参数参数名使用的是私有模式</span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#launch文件</span><br>前面已经介绍过，可以在 node 标签外，或 node 标签中通过 param 或 rosparam 来设置参数。<br>在 node 标签外设置的参数是全局性质的，参考的是 / <br>在 node 标签中设置的参数是私有性质的，参考的是 /命名空间/节点名称<br><br>&lt;launch&gt;<br><br>    &lt;param name=<span class="hljs-string">&quot;p1&quot;</span> value=<span class="hljs-string">&quot;100&quot;</span> /&gt;      <span class="hljs-comment">#/p1=100</span><br>    &lt;node pkg=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span> name=<span class="hljs-string">&quot;ergouzi&quot;</span>&gt;<br>         &lt;param name=<span class="hljs-string">&quot;p2&quot;</span> value=<span class="hljs-string">&quot;100&quot;</span> /&gt;   <span class="hljs-comment">#/erigouzi/p1=100</span><br>    &lt;/node&gt;<br><br>&lt;/launch&gt;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#编码方式</span><br>编码的方式可以更方便的设置:全局、相对与私有参数<br>    <br>rospy.set_param函数中，参数<span class="hljs-number">1</span>传入参数名称，参数<span class="hljs-number">2</span>是传入参数值。参数<span class="hljs-number">1</span>中参数名称设置时：<br>如果以 / 开头，那么就是全局参数<br>如果以 ~ 开头，那么就是私有参数<br>既不以 / 也不以 ~ 开头，那么就是相对参数<br><br>rospy.set_param(<span class="hljs-string">&quot;/py_A&quot;</span>,<span class="hljs-number">100</span>)  <span class="hljs-comment">#全局</span><br>rospy.set_param(<span class="hljs-string">&quot;py_B&quot;</span>,<span class="hljs-number">100</span>)  <span class="hljs-comment">#相对</span><br>rospy.set_param(<span class="hljs-string">&quot;~py_C&quot;</span>,<span class="hljs-number">100</span>)  <span class="hljs-comment">#私有</span><br></code></pre></td></tr></table></figure><p><strong>4.ROS分布式通信</strong></p><p>一个运行中的ROS系统可以包含分布在<strong>多台计算机上多个节点</strong>。根据系统的配置方式，任何节点可能随时需要与任何其他节点进行通信。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#配置ip等等操作，需要就查</span><br></code></pre></td></tr></table></figure><h4 id="九、ROS内置组件"><a href="#九、ROS内置组件" class="headerlink" title="九、ROS内置组件"></a>九、ROS内置组件</h4><p>常用的内置组件：TF坐标变换、rosbag、rqt 工具箱</p><p><strong>1.TF坐标变换</strong></p><p>明确了不同坐标系之间的的相对关系，就可以实现任何坐标点在不同坐标系之间的转换，但是该计算实现是较为常用的，且算法也有点复杂。因此在 **ROS 中直接封装了相关的模块: 坐标变换(TF)**，我们不需要关心坐标变换是如何实现的，直接调用即可。</p><p>（1）坐标message</p><p>TF转换实现中常用的 msg:</p><p>注：<strong>最好记住这两个消息类型</strong>！因为TF中实现坐标转换都是使用这样的message</p><ul><li><code>geometry_msgs/TransformStamped</code>用于传输坐标系<strong>相对位置</strong>信息（涉及<strong>四元数</strong>概念，较难） </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">std_msgs/Header header<br>  uint32 seq<br>  time stamp<br>  string frame_id<br>string child_frame_id<br>geometry_msgs/Transform transform<br>  geometry_msgs/Vector3 translation<br>    float64 x<br>    float64 y<br>    float64 z<br>  geometry_msgs/Quaternion rotation<br>    float64 x<br>    float64 y<br>    float64 z<br>    float64 w<br></code></pre></td></tr></table></figure><ul><li><code>geometry_msgs/PointStamped</code>用于传输某个坐标系内坐标点的信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">std_msgs/Header header<br>  uint32 seq<br>  time stamp<br>  string frame_id<br>geometry_msgs/Point point<br>  float64 x<br>  float64 y<br>  float64 z<br></code></pre></td></tr></table></figure><p>在坐标变换中，频繁的需要使用到坐标系的相对关系以及坐标点信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#查看两种消息类型</span><br>rosmsg info geometry_msgs/TransformStamped<br>rosmsg info geometry_msgs/PointStamped<br></code></pre></td></tr></table></figure><p>（2）静态坐标变换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建功能包</span><br>依赖有： tf2、tf2_ros、tf2_geometry_msgs、roscpp rospy std_msgs geometry_msgs<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Publisher实现</span><br><span class="hljs-comment">#发布两个坐标系关系</span><br><br><span class="hljs-comment"># 1.导包</span><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">import</span> tf2_ros<br><span class="hljs-keyword">import</span> tf     <span class="hljs-comment">#将欧拉角转换为四元数</span><br><span class="hljs-keyword">from</span> geometry_msgs.msg <span class="hljs-keyword">import</span> TransformStamped<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 2.初始化 ROS 节点</span><br>    rospy.init_node(<span class="hljs-string">&quot;static_tf_pub_p&quot;</span>)<br>    <span class="hljs-comment"># 3.创建 静态坐标广播器</span><br>    broadcaster = tf2_ros.StaticTransformBroadcaster()<br>    <span class="hljs-comment"># 4.创建并组织发布的消息</span><br>    tfs = TransformStamped()<br>    <span class="hljs-comment"># --- 头信息Header  （这些都与消息类型有关）</span><br>    tfs.header.frame_id = <span class="hljs-string">&quot;base_link&quot;</span><br>    tfs.header.stamp = rospy.Time.now()<br>    tfs.header.seq = <span class="hljs-number">101</span><br>    <span class="hljs-comment"># --- 子坐标系</span><br>    tfs.child_frame_id = <span class="hljs-string">&quot;radar&quot;</span><br>    <span class="hljs-comment"># --- 坐标系相对信息</span><br>    <span class="hljs-comment"># ------ 偏移量  (平移量)</span><br>    tfs.transform.translation.x = <span class="hljs-number">0.2</span><br>    tfs.transform.translation.y = <span class="hljs-number">0.0</span><br>    tfs.transform.translation.z = <span class="hljs-number">0.5</span><br>    <span class="hljs-comment"># ------ 四元数  (角度偏转量，四元数是一个较难的概念，需要就查)</span><br>    qtn = tf.transformations.quaternion_from_euler(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)   <span class="hljs-comment">#先从欧拉角转换为四元数</span><br>    tfs.transform.rotation.x = qtn[<span class="hljs-number">0</span>]    <span class="hljs-comment">#再设置四元数</span><br>    tfs.transform.rotation.y = qtn[<span class="hljs-number">1</span>]<br>    tfs.transform.rotation.z = qtn[<span class="hljs-number">2</span>]<br>    tfs.transform.rotation.w = qtn[<span class="hljs-number">3</span>]<br><br><br>    <span class="hljs-comment"># 5.广播器发送消息</span><br>    broadcaster.sendTransform(tfs)<br>    <span class="hljs-comment"># 6.spin</span><br>    rospy.spin()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Subcriber实现</span><br><span class="hljs-comment"># 1.导包</span><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">import</span> tf2_ros<br><span class="hljs-comment"># 不要使用 geometry_msgs,需要使用 tf2 内置的消息类型</span><br><span class="hljs-keyword">from</span> tf2_geometry_msgs <span class="hljs-keyword">import</span> PointStamped<br><span class="hljs-comment"># from geometry_msgs.msg import PointStamped</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 2.初始化 ROS 节点</span><br>    rospy.init_node(<span class="hljs-string">&quot;static_sub_tf_p&quot;</span>)<br>    <span class="hljs-comment"># 3.创建 TF 订阅对象</span><br>    buffer = tf2_ros.Buffer()   <span class="hljs-comment">#3.1缓存对象</span><br>    listener = tf2_ros.TransformListener(buffer)  <span class="hljs-comment">#3.2订阅对象</span><br><br>    rate = rospy.Rate(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> rospy.is_shutdown():    <br>    <span class="hljs-comment"># 4.创建一个 radar 坐标系中的坐标点（等待被转换的坐标点）</span><br>        point_source = PointStamped()<br>        point_source.header.frame_id = <span class="hljs-string">&quot;radar&quot;</span><br>        point_source.header.stamp = rospy.Time.now()<br>        point_source.point.x = <span class="hljs-number">10</span>  <span class="hljs-comment">#被转换的坐标点必须已知</span><br>        point_source.point.y = <span class="hljs-number">2</span><br>        point_source.point.z = <span class="hljs-number">3</span><br><br>        <span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment">#     5.用buffer中转换函数，完成坐标转换！</span><br>            point_target = buffer.transform(point_source,<span class="hljs-string">&quot;base_link&quot;</span>)   <span class="hljs-comment">#缓存buffer中有转换的方法</span><br>                                                                                                                                <span class="hljs-comment">#参数：待转换的坐标点、目标坐标系</span><br>            rospy.loginfo(<span class="hljs-string">&quot;转换结果:x = %.2f, y = %.2f, z = %.2f&quot;</span>,<br>                            point_target.point.x,<br>                            point_target.point.y,<br>                            point_target.point.z)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            rospy.logerr(<span class="hljs-string">&quot;异常:%s&quot;</span>,e)<br><br>    <span class="hljs-comment">#     6.spin</span><br>        rate.sleep()<br></code></pre></td></tr></table></figure><ul><li>拓：静态坐标系的实现流程很固定，所以ROS也考虑到这一点，为我们<strong>封装好了专门的节点</strong>——实现静态坐标变换</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#rosrun tf2_ros static_transform_publisher x偏移量 y偏移量 z偏移量 z偏航角度 y俯仰角度 x翻滚角度 父级坐标系 子级坐标系</span><br>rosrun tf2_ros static_transform_publisher <span class="hljs-number">0.2</span> <span class="hljs-number">0</span> <span class="hljs-number">0.5</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> /baselink /laser<br></code></pre></td></tr></table></figure><ul><li>拓：在rviz中显示坐标系关系：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#操作流程：</span><br>   新建窗口输入命令:rviz;<br>   在启动的 rviz 中设置Fixed Frame 为 base_link;<br>   点击左下的 add 按钮，在弹出的窗口中选择 TF 组件，即可显示坐标关系。<br></code></pre></td></tr></table></figure><p>（3）动态坐标变换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#创建功能包</span><br>依赖有： tf2、tf2_ros、tf2_geometry_msgs、roscpp rospy std_msgs geometry_msgs、turtlesim<br></code></pre></td></tr></table></figure><p><strong>解释下面这段代码的思路：</strong></p><p>1.在Publisher节点中创建subscriber订阅话题<code>/turtle1/pose</code>（消息类型为<code>Pose</code>，回调函数为<code>doPose</code>）</p><p>2.在回调函数中处理消息，父系<code>world</code>，子系<code>turtle1</code>；通过**TransformStamped对象 (geometry_msgs.msg库)**的方法得到转换关系：3偏移量+四元数</p><p>3.通过<strong>TransformBroadcaster对象 (tf2_ros库)<strong>将转换关系广播（</strong>发布到TF中</strong>，在rviz中添加TF可以直接看到已经发布的信息）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Publisher：负责订阅乌龟位姿信息，转换成坐标系的相对关系，再发布</span><br><span class="hljs-comment">#（由于乌龟坐标不再是静态的，所以需要发布方节点实时读取，才能找到坐标关系进行发布）</span><br><br><span class="hljs-comment"># 1.导包</span><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">import</span> tf2_ros<br><span class="hljs-keyword">import</span> tf<br><span class="hljs-keyword">from</span> turtlesim.msg <span class="hljs-keyword">import</span> Pose<br><span class="hljs-keyword">from</span> geometry_msgs.msg <span class="hljs-keyword">import</span> TransformStamped<br><br><span class="hljs-comment">#     4.回调函数处理</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doPose</span>(<span class="hljs-params">pose</span>):</span><br>    <span class="hljs-comment">#         4-1.创建 TF 广播器</span><br>    broadcaster = tf2_ros.TransformBroadcaster()<br>    <span class="hljs-comment">#         4-2.创建 广播的数据(通过 pose 设置)，发布坐标系相对关系</span><br>    tfs = TransformStamped()<br>    tfs.header.frame_id = <span class="hljs-string">&quot;world&quot;</span><br>    tfs.header.stamp = rospy.Time.now()<br>    tfs.child_frame_id = <span class="hljs-string">&quot;turtle1&quot;</span><br>    tfs.transform.translation.x = pose.x   <span class="hljs-comment">#偏移量</span><br>    tfs.transform.translation.y = pose.y<br>    tfs.transform.translation.z = <span class="hljs-number">0.0</span><br>    qtn = tf.transformations.quaternion_from_euler(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,pose.theta)   <span class="hljs-comment">#四元数</span><br>                                                                        <span class="hljs-comment">#乌龟是2D运动，不存在X、Y上的偏角，只有Z上的偏航，所以传pose.theta即可</span><br>    tfs.transform.rotation.x = qtn[<span class="hljs-number">0</span>]<br>    tfs.transform.rotation.y = qtn[<span class="hljs-number">1</span>]<br>    tfs.transform.rotation.z = qtn[<span class="hljs-number">2</span>]<br>    tfs.transform.rotation.w = qtn[<span class="hljs-number">3</span>]<br>    <span class="hljs-comment">#         4-3.广播器发布数据</span><br>    broadcaster.sendTransform(tfs)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 2.初始化 ROS 节点</span><br>    rospy.init_node(<span class="hljs-string">&quot;dynamic_tf_pub_p&quot;</span>)<br>    <span class="hljs-comment"># 3.创建订阅对象，订阅 /turtle1/pose 话题消息</span><br>    sub = rospy.Subscriber(<span class="hljs-string">&quot;/turtle1/pose&quot;</span>,Pose,doPose)<br>    <span class="hljs-comment">#     4.回调函数处理</span><br>    <span class="hljs-comment">#         4-1.创建 TF 广播器</span><br>    <span class="hljs-comment">#         4-2.创建 广播的数据(通过 pose 设置)</span><br>    <span class="hljs-comment">#         4-3.广播器发布数据</span><br>    <span class="hljs-comment">#     5.spin</span><br>    rospy.spin()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Subscriber：与静态几乎一致</span><br><br><span class="hljs-comment"># 1.导包</span><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">import</span> tf2_ros<br><span class="hljs-comment"># 不要使用 geometry_msgs,需要使用 tf2 内置的消息类型</span><br><span class="hljs-keyword">from</span> tf2_geometry_msgs <span class="hljs-keyword">import</span> PointStamped<br><span class="hljs-comment"># from geometry_msgs.msg import PointStamped</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 2.初始化 ROS 节点</span><br>    rospy.init_node(<span class="hljs-string">&quot;static_sub_tf_p&quot;</span>)<br>    <span class="hljs-comment"># 3.创建 TF 订阅对象</span><br>    buffer = tf2_ros.Buffer()<br>    listener = tf2_ros.TransformListener(buffer)<br><br>    rate = rospy.Rate(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> rospy.is_shutdown():    <br>    <span class="hljs-comment"># 4.创建一个 radar 坐标系中的坐标点</span><br>        point_source = PointStamped()<br>        point_source.header.frame_id = <span class="hljs-string">&quot;turtle1&quot;</span><br>        point_source.header.stamp = rospy.Time.now()<br>        point_source.point.x = <span class="hljs-number">10</span><br>        point_source.point.y = <span class="hljs-number">2</span><br>        point_source.point.z = <span class="hljs-number">3</span><br><br>        <span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment">#     5.调研订阅对象的 API 将 4 中的点坐标转换成相对于 world 的坐标</span><br>            point_target = buffer.transform(point_source,<span class="hljs-string">&quot;world&quot;</span>,rospy.Duration(<span class="hljs-number">1</span>))  <span class="hljs-comment">#缓存buffer中有转换的方法</span><br>            rospy.loginfo(<span class="hljs-string">&quot;转换结果:x = %.2f, y = %.2f, z = %.2f&quot;</span>,<br>                            point_target.point.x,<br>                            point_target.point.y,<br>                            point_target.point.z)<br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>            rospy.logerr(<span class="hljs-string">&quot;异常:%s&quot;</span>,e)<br><br>    <span class="hljs-comment">#     6.spin</span><br>        rate.sleep()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>系统学习ROS（一）</title>
    <link href="/2021/04/14/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ROS%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/04/14/%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0ROS%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>入门的概念已经了解，本系列是我在系统学习ROS中的笔记。ROS知识点繁多，有些内容用到的时候google或者wiki查询，不做记录。</p><span id="more"></span><p>同时，只记录python实现版本。</p><p><strong>学习地址（全文参考）</strong>：<a href="http://www.autolabor.com.cn/book/ROSTutorials/">http://www.autolabor.com.cn/book/ROSTutorials/</a></p><h3 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h3><h4 id="1-基本开发流程"><a href="#1-基本开发流程" class="headerlink" title="1.基本开发流程"></a>1.基本开发流程</h4><ol><li>创建工作空间；</li><li>创建功能包；</li><li>编辑源文件；（.cpp、.py）</li><li>编辑配置文件；</li><li>编译并执行。</li></ol><h4 id="2-workspace以及功能包的编译与使用"><a href="#2-workspace以及功能包的编译与使用" class="headerlink" title="2.workspace以及功能包的编译与使用"></a>2.workspace以及功能包的编译与使用</h4><p>（1）创建workspace：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">mkdir -p test_ws&#x2F;src<br>cd test_ws<br>catkin_make  #编译工作空间<br></code></pre></td></tr></table></figure><p>（2）创建功能包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">cd src<br>catkin_create_pkg &lt;depend&gt; roscpp rospy std_msgs  # 通常都需要roscpp、rospy<br></code></pre></td></tr></table></figure><p><strong>学习过程中：</strong></p><p>ubuntu工作空间创建好后，可以一直用；例如创建了test_ws工作空间，该空间已经编译完成，有自动生成的devel、build文件夹，则后续可以在该workspace下添加功能包。</p><p>在src文件夹下：有多个功能包，在学习过程中直接将源码功能包放进来;</p><p>编译功能包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">#在根目录下<br>catkin_make<br>source devel&#x2F;setup.bash   #此命令只对当前终端有效，要想一劳永逸，见下面方法<br></code></pre></td></tr></table></figure><p>然后就可以roslaunch执行launch文件啦！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">#方法一<br>直接使用 gedit 或 vi 编辑 .bashrc 文件，最后添加该内容<br><br>#方法二<br>echo &quot;source ~&#x2F;工作空间&#x2F;devel&#x2F;setup.bash&quot; &gt;&gt; ~&#x2F;.bashrc<br><br>最后在终端中执行：<br>source .bashrc  #之后在所有终端中都可以一劳永逸了！<br></code></pre></td></tr></table></figure><h4 id="3-集成开发环境："><a href="#3-集成开发环境：" class="headerlink" title="3.集成开发环境："></a>3.集成开发环境：</h4><p>选择VS Code，有了集成开发环境，可以不用再在记事本当中写代码了！</p><p>（1）集成开发环境提供了图形化界面，可以可视化地创建功能包、程序文件等；</p><p>（2）为VScode安装如下插件：C++、Python、Cmake、ROS</p><p>（3）进行一些配置，将作者的配置文件直接复制，此后可以通过<code>Ctrl+Shift+B</code>直接完成编译（相当与<code>catkin_make</code>）</p><p>（4）无论是C++还是python程序，都需要在CMakeList文件中做配置，再编译；</p><h4 id="4-launch文件"><a href="#4-launch文件" class="headerlink" title="4.launch文件"></a>4.launch文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">&lt;launch&gt;<br>    &lt;node pkg&#x3D;&quot;helloworld&quot; type&#x3D;&quot;demo_hello&quot; name&#x3D;&quot;hello&quot; output&#x3D;&quot;screen&quot; &#x2F;&gt;<br>    &lt;node pkg&#x3D;&quot;turtlesim&quot; type&#x3D;&quot;turtlesim_node&quot; name&#x3D;&quot;t1&quot;&#x2F;&gt;<br>    &lt;node pkg&#x3D;&quot;turtlesim&quot; type&#x3D;&quot;turtle_teleop_key&quot; name&#x3D;&quot;key1&quot; &#x2F;&gt;<br>&lt;&#x2F;launch&gt;<br><br>roslaunch 包名 launch文件名<br><br># node ---&gt; 包含的某个节点<br># pkg -----&gt; 功能包<br># type ----&gt; 被运行的节点文件<br># name --&gt; 为节点命名<br># output-&gt; 设置日志的输出目标<br></code></pre></td></tr></table></figure><h4 id="5-文件系统架构："><a href="#5-文件系统架构：" class="headerlink" title="5.文件系统架构："></a>5.文件系统架构：</h4><img src="/images/image-20210414142652602.png" alt="image-20210414142652602" style="zoom:67%;"><p>经常编辑这些功能包就会熟悉起来</p><h4 id="6-ROS文件系统常用命令"><a href="#6-ROS文件系统常用命令" class="headerlink" title="6.ROS文件系统常用命令"></a>6.ROS文件系统常用命令</h4><p>ROS专门提供了一些类似于Linux的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">sudo apt install xxx   #安装 ROS功能包<br>sudo apt purge xxx    #删除某个功能包<br><br>rospack list   #列出所有功能包<br>rospack find 包名   #查找某个功能包是否存在，如果存在返回安装路径<br>apt search xxx    # 在网上搜索某个功能包<br></code></pre></td></tr></table></figure><h4 id="7-ROS计算图"><a href="#7-ROS计算图" class="headerlink" title="7.ROS计算图"></a>7.ROS计算图</h4><p>rqt_graph能够创建一个显示当前系统运行情况的动态图形</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">rqt_graph<br></code></pre></td></tr></table></figure><h4 id="二、话题通信"><a href="#二、话题通信" class="headerlink" title="二、话题通信"></a>二、话题通信</h4><p>话题通信是基于<strong>发布订阅</strong>模式的，也即:一个节点发布消息，另一个节点订阅该消息。</p><p>例如：机器人在执行导航功能，使用的传感器是激光雷达，机器人会采集激光雷达感知到的信息并计算，然后生成运动控制信息驱动机器人底盘运动。</p><p>上述过程涉及多次话题通信：</p><p>（1）以激光雷达信息的采集处理为例，在 ROS 中有一个节点需要时时的<strong>发布</strong>当前雷达采集到的数据，导航模块中也有节点会<strong>订阅</strong>并解析雷达数据；</p><p>（2）再以运动消息的发布为例，导航模块会根据传感器采集的数据时时的计算出运动控制信息并<strong>发布</strong>给底盘，底盘也可以有一个节点<strong>订阅</strong>运动信息并最终转换成控制电机的脉冲信号；</p><p>以此类推，像雷达、摄像头、GPS…. 等等一些传感器数据的采集，也都是使用了话题通信，换言之，话题通信适用于<strong>不断更新的、少逻辑处理的数据传输相</strong>关的应用场景。</p><p>1.C++</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">#在订阅者实现中：<br>ros : : spin( )     # 回调函数：处理订阅的数据<br><br>#发布者需要等待回调函数：<br>ros : : spinOnce( ) <br></code></pre></td></tr></table></figure><p>2.python实现：（发布最简单的<code>hello</code>信息）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Publisher</span><br><br><span class="hljs-comment">#1.导包 </span><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> std_msgs.msg <span class="hljs-keyword">import</span> String    <span class="hljs-comment">#发布消息的类型</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment">#2.初始化 ROS 节点:命名(唯一)</span><br>    rospy.init_node(<span class="hljs-string">&quot;talker_p&quot;</span>)      <span class="hljs-comment">#直接传入节点名称</span><br>    <br>    <span class="hljs-comment">#3.实例化 发布者 对象</span><br>    pub = rospy.Publisher(<span class="hljs-string">&quot;chatter&quot;</span>,String,queue_size=<span class="hljs-number">10</span>)  <span class="hljs-comment">#话题名称、消息类型、缓存队列长度</span><br>    <br>    <span class="hljs-comment">#4.组织被发布的数据，并编写逻辑发布数据</span><br>    msg = String()  <span class="hljs-comment">#创建 msg 对象</span><br>    <br>    <span class="hljs-comment"># 设置循环频率</span><br>    rate = rospy.Rate(<span class="hljs-number">1</span>)   <span class="hljs-comment"># 1Hz</span><br>    <br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> rospy.is_shutdown():   <span class="hljs-comment">#使用rospy中的函数，判断节点没有关闭</span><br>        msg.data = <span class="hljs-string">&quot;hello&quot;</span>   <span class="hljs-comment">#定义发布的消息</span><br>        pub.publish(msg)<br>        rate.sleep()  <span class="hljs-comment">#每隔rate秒醒过来</span><br>        rospy.loginfo(<span class="hljs-string">&quot;发布的数据是:%s&quot;</span>,msg.data）<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#编译python文件流程：(以配置好的VS Code为例)          以后所有运行的python程序都要经过这一步</span><br><span class="hljs-number">1.</span>终端添加可执行权限：chmod  +x  *.py<br><span class="hljs-number">2.</span>修改CmakeList文件：<br>    catkin_install_python(PROGRAMS<br>        scripts/demo_pubpy.py<br>        DESTINATION $&#123;CATKIN_PACKAGE_BIN_DESTINATION&#125;<br>         )<br><span class="hljs-number">3.</span> Ctrl+Shift+B编译<br><span class="hljs-number">4.</span> roscore+rosrun运行即可<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Subscriber</span><br><br><span class="hljs-comment">#1.导包 </span><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> std_msgs.msg <span class="hljs-keyword">import</span> String<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doMsg</span>(<span class="hljs-params">msg</span>):</span>  <span class="hljs-comment">#定义回调函数</span><br>    rospy.loginfo(<span class="hljs-string">&quot;我订阅的数据：%s&quot;</span>,msg.data)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment">#2.初始化 ROS 节点:命名(唯一)</span><br>    rospy.init_node(<span class="hljs-string">&quot;listener_p&quot;</span>)<br>    <br>    <span class="hljs-comment">#3.实例化 订阅者 对象</span><br>    sub = rospy.Subscriber(<span class="hljs-string">&quot;chatter&quot;</span>,String, doMsg, queue_size=<span class="hljs-number">10</span>)  <span class="hljs-comment">#话题名称、消息类型、回调函数、队列长度</span><br>    <br>    <span class="hljs-comment">#4.处理订阅的消息(回调函数)</span><br>    <span class="hljs-comment">#5.设置循环调用回调函数</span><br>    rospy.spin()<br></code></pre></td></tr></table></figure><p>3.自定义消息</p><p>ROS 中通过 std_msgs 封装了一些原生的数据类型,比如:String、Int32、Int64、Char、Bool、Empty…. 但是，这些数据一般只包含一个 data 字段—&gt;用于接受消息</p><p>应用场景：传递一些复杂数据时</p><ul><li><strong>流程：</strong></li></ul><p>（1）定义msg文件：功能包下新建 msg 目录，添加文件 Person.msg</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">string name<br>uint16 age<br>float64 height<br></code></pre></td></tr></table></figure><p>（2）编辑配置文件package.xml</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&lt;build_depend&gt;message_generation&lt;/build_depend&gt;   #message_generation<br>&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;   #message_runtime<br></code></pre></td></tr></table></figure><p>（3）<strong>CMakeLists.txt</strong>编辑 msg 相关配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">find_package(catkin REQUIRED COMPONENTS<br>  roscpp<br>  rospy<br>  std_msgs<br>  message_generation<br>)<br><span class="hljs-comment"># 需要加入 message_generation,必须有 std_msgs</span><br><br>add_message_files(<br>  FILES<br>  Person.msg<br>)<br><br>generate_messages(<br>  DEPENDENCIES<br>  std_msgs<br>)<br><br><span class="hljs-comment">#执行时依赖</span><br>catkin_package(<br><span class="hljs-comment">#  INCLUDE_DIRS include</span><br><span class="hljs-comment">#  LIBRARIES demo02_talker_listener</span><br>  CATKIN_DEPENDS roscpp rospy std_msgs message_runtime<br><span class="hljs-comment">#  DEPENDS system_lib</span><br>)<br></code></pre></td></tr></table></figure><ul><li><strong>python实现发布、订阅自定义消息</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Publisher发布自定义的Person类型消息</span><br><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> demo02_talker_listener.msg <span class="hljs-keyword">import</span> Person  <span class="hljs-comment">#自定义的消息类型文件</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment">#1.初始化 ROS 节点</span><br>    rospy.init_node(<span class="hljs-string">&quot;talker_person_p&quot;</span>)<br>    <span class="hljs-comment">#2.创建发布者对象</span><br>    pub = rospy.Publisher(<span class="hljs-string">&quot;chatter_person&quot;</span>,Person,queue_size=<span class="hljs-number">10</span>)<br>    <span class="hljs-comment">#3.组织消息  （自定义的Person类型）</span><br>    p = Person()<br>    p.name = <span class="hljs-string">&quot;葫芦瓦&quot;</span><br>    p.age = <span class="hljs-number">18</span><br>    p.height = <span class="hljs-number">0.75</span><br><br>    <span class="hljs-comment">#4.编写消息发布逻辑</span><br>    rate = rospy.Rate(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> rospy.is_shutdown():<br>        pub.publish(p)  <span class="hljs-comment">#发布消息</span><br>        rate.sleep()  <span class="hljs-comment">#休眠</span><br>        rospy.loginfo(<span class="hljs-string">&quot;姓名:%s, 年龄:%d, 身高:%.2f&quot;</span>,p.name, p.age, p.height)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Subscriber订阅自定义的Person类型消息</span><br><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> demo02_talker_listener.msg <span class="hljs-keyword">import</span> Person<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doPerson</span>(<span class="hljs-params">p</span>):</span>  <span class="hljs-comment">#定义回调函数</span><br>    rospy.loginfo(<span class="hljs-string">&quot;接收到的人的信息:%s, %d, %.2f&quot;</span>,p.name, p.age, p.height)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment">#1.初始化节点</span><br>    rospy.init_node(<span class="hljs-string">&quot;listener_person_p&quot;</span>)<br>    <span class="hljs-comment">#2.创建订阅者对象</span><br>    sub = rospy.Subscriber(<span class="hljs-string">&quot;chatter_person&quot;</span>,Person, doPerson, queue_size=<span class="hljs-number">10</span>)<br>    rospy.spin() <span class="hljs-comment">#4.循环</span><br></code></pre></td></tr></table></figure><h4 id="三、服务通信"><a href="#三、服务通信" class="headerlink" title="三、服务通信"></a>三、服务通信</h4><p>无论是话题还是服务通信，都是以来于<strong>话题</strong>的！</p><p>基于<strong>请求响应</strong>模式，适用于<strong>对时时性有要求、具有一定逻辑处理</strong>的应用场景。</p><p>ROS Master 负责保管 Server 和 Client 注册的信息，并匹配<strong>话题相同</strong>的 Server 与 Client ，帮助 Server 与 Client 建立连接，连接建立后，Client 发送请求信息，Server 返回响应信息。</p><p>对<strong>时序</strong>有严格要求：客户端发起请求时，必须保证服务端已经启动。</p><p>1.自定义服务消息类型srv文件：</p><p>功能包下新建 srv 目录，添加 xxx.srv 文件，内容:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 客户端请求时发送的两个数字</span><br>int32 num1<br>int32 num2<br>---                                                       <span class="hljs-comment">#在 srv 文件中请求和响应使用---分割</span><br><span class="hljs-comment"># 服务器响应发送的数据</span><br>int32 <span class="hljs-built_in">sum</span><br><br></code></pre></td></tr></table></figure><p>编辑配置文件</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#package.xml</span><br><br>  &lt;build_depend&gt;message_generation&lt;/build_depend&gt;<br>  &lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;<br>  &lt;!-- <br>  exce_depend 以前对应的是 run_depend 现在非法<br>  --&gt;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#CMakeList</span><br><br>find_package(catkin REQUIRED COMPONENTS<br>  roscpp<br>  rospy<br>  std_msgs<br>  message_generation<br>)<br><span class="hljs-comment"># 需要加入 message_generation,必须有 std_msgs</span><br><br>add_service_files(<br>  FILES<br>  AddInts.srv<br>)<br><br>generate_messages(<br>  DEPENDENCIES<br>  std_msgs<br>)<br></code></pre></td></tr></table></figure><p>2.Server、Client的python实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Server ： 解析客户端请求，产生响应</span><br><br><span class="hljs-comment"># 1.导包</span><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> demo03_server_client.srv <span class="hljs-keyword">import</span> AddInts,AddIntsRequest,AddIntsResponse<br><br><span class="hljs-comment"># 回调函数的参数是请求对象，返回值是响应对象</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doReq</span>(<span class="hljs-params">req</span>):</span><br>    <span class="hljs-comment"># 解析提交的数据</span><br>    <span class="hljs-built_in">sum</span> = req.num1 + req.num2<br>    rospy.loginfo(<span class="hljs-string">&quot;提交的数据:num1 = %d, num2 = %d, sum = %d&quot;</span>,req.num1, req.num2, <span class="hljs-built_in">sum</span>)<br><br>    <span class="hljs-comment">#将结果封装进响应</span><br>    <span class="hljs-comment"># 创建响应对象，赋值并返回</span><br>    <span class="hljs-comment"># resp = AddIntsResponse()</span><br>    <span class="hljs-comment"># resp.sum = sum</span><br>    resp = AddIntsResponse(<span class="hljs-built_in">sum</span>)<br>    <span class="hljs-keyword">return</span> resp <br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 2.初始化 ROS 节点</span><br>    rospy.init_node(<span class="hljs-string">&quot;addints_server_p&quot;</span>)<br>    <span class="hljs-comment"># 3.创建服务对象</span><br>    server = rospy.Service(<span class="hljs-string">&quot;AddInts&quot;</span>,AddInts,doReq)    <span class="hljs-comment">#话题名称，消息类型，回调函数</span><br>    <span class="hljs-comment"># 4.回调函数处理请求并产生响应</span><br>    <span class="hljs-comment"># 5.spin 函数</span><br>    rospy.spin()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#Client：</span><br><br><span class="hljs-comment">#1.导包</span><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> demo03_server_client.srv <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><br>    <span class="hljs-comment">#优化实现</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(sys.argv) != <span class="hljs-number">3</span>:    <span class="hljs-comment">#判断动态传入的参数是否为3个</span><br>        rospy.logerr(<span class="hljs-string">&quot;请正确提交参数&quot;</span>)<br>        sys.exit(<span class="hljs-number">1</span>)<br><br><br>    <span class="hljs-comment"># 2.初始化 ROS 节点</span><br>    rospy.init_node(<span class="hljs-string">&quot;AddInts_Client_p&quot;</span>)<br>    <span class="hljs-comment"># 3.创建Client对象</span><br>    client = rospy.ServiceProxy(<span class="hljs-string">&quot;AddInts&quot;</span>,AddInts)   <span class="hljs-comment">#话题名称、消息类型</span><br>    <br>    <span class="hljs-comment"># 请求前，等待服务已经就绪：防止启动顺序出错（鲁棒性设置）</span><br>    <span class="hljs-comment"># 方式1:</span><br>     rospy.wait_for_service(<span class="hljs-string">&quot;AddInts&quot;</span>)<br>    <span class="hljs-comment"># 方式2</span><br>    client.wait_for_service()<br>    <br>    <span class="hljs-comment"># 4.发送请求,接收并处理响应</span><br>    <span class="hljs-comment"># 方式1</span><br>    resp = client(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)<br>    <span class="hljs-comment"># 方式2</span><br>     resp = client(AddIntsRequest(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>))<br>    <span class="hljs-comment"># 方式3</span><br>    req = AddIntsRequest()<br>     req.num1 = <span class="hljs-number">100</span><br>     req.num2 = <span class="hljs-number">200</span> <br><br>    <span class="hljs-comment">#优化：可以在执行节点时，动态传入参数</span><br>    req.num1 = <span class="hljs-built_in">int</span>(sys.argv[<span class="hljs-number">1</span>])    <span class="hljs-comment"># sys.argv表示：命令行参数列表</span><br>    req.num2 = <span class="hljs-built_in">int</span>(sys.argv[<span class="hljs-number">2</span>]) <br><br>    resp = client.call(req)<br>    rospy.loginfo(<span class="hljs-string">&quot;响应结果:%d&quot;</span>,resp.<span class="hljs-built_in">sum</span>)<br></code></pre></td></tr></table></figure><h4 id="四、参数服务器"><a href="#四、参数服务器" class="headerlink" title="四、参数服务器"></a>四、参数服务器</h4><p>实现不同节点之间的数据共享，参数服务器相当于是独立于所有节点的一个公共容器，可以将数据存储在该容器中，被不同的节点调用，当然不同的节点也可以往其中存储数据。类似于<strong>全局变量</strong>。</p><p>举例：导航实现时，全局、本地路径规划都要考虑小车自身的尺寸，而小车尺寸就存储在参数服务器中。</p><p>注意:参数服务器使用RPC协议，不是为高性能而设计的，因此最好用于存储静态的非二进制的简单数据</p><p>参数以<strong>键值对</strong>的形式存储在参数服务器中。</p><ul><li><p>参数服务器操作的python实现：</p><p>（1）增、改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> rospy<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment">#初始化节点</span><br>    rospy.init_node(<span class="hljs-string">&quot;set_update_paramter_p&quot;</span>)<br><br>    <span class="hljs-comment"># 设置各种类型参数</span><br>    rospy.set_param(<span class="hljs-string">&quot;p_int&quot;</span>,<span class="hljs-number">10</span>)   <span class="hljs-comment">#键、值</span><br>    rospy.set_param(<span class="hljs-string">&quot;p_double&quot;</span>,<span class="hljs-number">3.14</span>)<br>    rospy.set_param(<span class="hljs-string">&quot;p_bool&quot;</span>,<span class="hljs-literal">True</span>)<br>    rospy.set_param(<span class="hljs-string">&quot;p_string&quot;</span>,<span class="hljs-string">&quot;hello python&quot;</span>)<br>    rospy.set_param(<span class="hljs-string">&quot;p_list&quot;</span>,[<span class="hljs-string">&quot;hello&quot;</span>,<span class="hljs-string">&quot;haha&quot;</span>,<span class="hljs-string">&quot;xixi&quot;</span>])<br>    rospy.set_param(<span class="hljs-string">&quot;p_dict&quot;</span>,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;hulu&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">8</span>&#125;)<br><br>    <span class="hljs-comment"># 修改</span><br>    rospy.set_param(<span class="hljs-string">&quot;p_int&quot;</span>,<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>（2）查询参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> rospy<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    rospy.init_node(<span class="hljs-string">&quot;get_param_p&quot;</span>)<br><br>    <span class="hljs-comment">#获取参数: get_param</span><br>    int_value = rospy.get_param(<span class="hljs-string">&quot;p_int&quot;</span>,<span class="hljs-number">10000</span>)<br>    double_value = rospy.get_param(<span class="hljs-string">&quot;p_double&quot;</span>)<br>    bool_value = rospy.get_param(<span class="hljs-string">&quot;p_bool&quot;</span>)<br>    string_value = rospy.get_param(<span class="hljs-string">&quot;p_string&quot;</span>)<br>    p_list = rospy.get_param(<span class="hljs-string">&quot;p_list&quot;</span>)<br>    p_dict = rospy.get_param(<span class="hljs-string">&quot;p_dict&quot;</span>)<br><br>    rospy.loginfo(<span class="hljs-string">&quot;获取的数据:%d,%.2f,%d,%s&quot;</span>,<br>                int_value,<br>                double_value,<br>                bool_value,<br>                string_value)<br>    <span class="hljs-keyword">for</span> ele <span class="hljs-keyword">in</span> p_list:<br>        rospy.loginfo(<span class="hljs-string">&quot;ele = %s&quot;</span>, ele)<br><br>    rospy.loginfo(<span class="hljs-string">&quot;name = %s, age = %d&quot;</span>,p_dict[<span class="hljs-string">&quot;name&quot;</span>],p_dict[<span class="hljs-string">&quot;age&quot;</span>])<br><br>    <span class="hljs-comment"># get_param_cached（效率比get_param高）</span><br>    int_cached = rospy.get_param_cached(<span class="hljs-string">&quot;p_int&quot;</span>)<br>    rospy.loginfo(<span class="hljs-string">&quot;缓存数据:%d&quot;</span>,int_cached)<br><br>    <span class="hljs-comment"># get_param_names</span><br>    names = rospy.get_param_names()<br>    <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names:<br>        rospy.loginfo(<span class="hljs-string">&quot;name = %s&quot;</span>,name)<br><br>    rospy.loginfo(<span class="hljs-string">&quot;-&quot;</span>*<span class="hljs-number">80</span>)<br><br>    <span class="hljs-comment"># 判断某个键是否存在：has_param</span><br>    flag = rospy.has_param(<span class="hljs-string">&quot;p_int&quot;</span>)<br>    rospy.loginfo(<span class="hljs-string">&quot;包含p_int吗？%d&quot;</span>,flag)<br><br>    <span class="hljs-comment"># 判断键是否存在，存在则返回键名：search_param</span><br>    key = rospy.search_param(<span class="hljs-string">&quot;p_int&quot;</span>)<br>    rospy.loginfo(<span class="hljs-string">&quot;搜索的键 = %s&quot;</span>,key)<br></code></pre></td></tr></table></figure><p>（3）删除参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># delete_param</span><br><span class="hljs-keyword">import</span> rospy<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    rospy.init_node(<span class="hljs-string">&quot;delete_param_p&quot;</span>)<br><br>    <span class="hljs-keyword">try</span>:<br>        rospy.delete_param(<span class="hljs-string">&quot;p_int&quot;</span>)<br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>        rospy.loginfo(<span class="hljs-string">&quot;删除失败&quot;</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="五、常用命令"><a href="#五、常用命令" class="headerlink" title="五、常用命令"></a>五、常用命令</h4><p>以下介绍的命令都可以<strong>直接在命令行中实现</strong>，不需要创建节点；但缺点是<strong>不能包含太复杂的逻辑</strong>，只能做一些简单的实现（比如往参数服务器里添加参数、rostopic pub发布简单的话题）</p><p>1.rosnode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">rosnode ping  xxx   <span class="hljs-comment">#测试到节点的连接状态</span><br>rosnode <span class="hljs-built_in">list</span>    <span class="hljs-comment">#列出活动节点</span><br>rosnode info  xxx    <span class="hljs-comment">#打印节点信息</span><br>rosnode machine    <span class="hljs-comment">#列出指定设备上节点</span><br>rosnode kill  xxx    <span class="hljs-comment">#杀死某个节点</span><br>rosnode cleanup     <span class="hljs-comment">#清除不可连接的节点</span><br></code></pre></td></tr></table></figure><p>2.rostopic</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">rostopic <span class="hljs-built_in">list</span>   <span class="hljs-comment">#显示所有活动状态下的主题</span><br>rostopic echo   <span class="hljs-comment">#打印话题消息到屏幕  rostopic  echo  /turtle1/cmd_vel</span><br>rostopic pub    <span class="hljs-comment">#将数据发布到主题</span><br>rostopic bw     <span class="hljs-comment">#显示主题使用的带宽</span><br>rostopic delay  <span class="hljs-comment">#显示带有 header 的主题延迟</span><br>rostopic find   <span class="hljs-comment">#根据类型查找主题</span><br>rostopic hz     <span class="hljs-comment">#显示主题的发布频率</span><br>rostopic info   <span class="hljs-comment">#显示主题相关信息</span><br>rostopic <span class="hljs-built_in">type</span>   <span class="hljs-comment">#打印主题类型</span><br></code></pre></td></tr></table></figure><p>3.rosmsg</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">rosmsg show   <span class="hljs-comment"># 显示消息描述</span><br>rosmsg info    <span class="hljs-comment">#显示消息信息</span><br>rosmsg <span class="hljs-built_in">list</span>    <span class="hljs-comment">#列出所有消息</span><br>rosmsg md5    <span class="hljs-comment">#显示 md5 加密后的消息</span><br>rosmsg package    <span class="hljs-comment">#显示某个功能包下的所有消息</span><br>rosmsg packages    <span class="hljs-comment">#列出包含消息的功能包</span><br></code></pre></td></tr></table></figure><p>4.rosservice</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">rosservice args  <span class="hljs-comment">#打印服务参数</span><br>rosservice call    <span class="hljs-comment">#使用提供的参数调用服务</span><br>rosservice find    <span class="hljs-comment">#按照服务类型查找服务</span><br>rosservice info    <span class="hljs-comment">#打印有关服务的信息</span><br>rosservice <span class="hljs-built_in">list</span>     <span class="hljs-comment">#列出所有活动的服务</span><br>rosservice <span class="hljs-built_in">type</span>    <span class="hljs-comment">#打印服务类型</span><br>rosservice uri     <span class="hljs-comment">#打印服务的 ROSRPC uri</span><br></code></pre></td></tr></table></figure><p>5.rossrv</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">rossrv show    <span class="hljs-comment">#显示服务消息详情</span><br>rossrv info    <span class="hljs-comment">#显示服务消息相关信息</span><br>rossrv <span class="hljs-built_in">list</span>    <span class="hljs-comment">#列出所有服务信息</span><br>rossrv md5    <span class="hljs-comment">#显示 md5 加密后的服务消息</span><br>rossrv package    <span class="hljs-comment">#显示某个包下所有服务消息</span><br>rossrv packages    <span class="hljs-comment">#显示包含服务消息的所有包</span><br></code></pre></td></tr></table></figure><p>6.rosparam</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">rosparam <span class="hljs-built_in">set</span>    <span class="hljs-comment">#设置参数  rosparam set name xiaohuang</span><br>rosparam get    <span class="hljs-comment">#获取参数</span><br>rosparam load    <span class="hljs-comment">#从外部文件加载参数  ---&gt;反序列化</span><br>rosparam dump    <span class="hljs-comment">#将参数写出到外部文件(yaml文件) ---&gt;序列化</span><br>rosparam delete    <span class="hljs-comment">#删除参数</span><br>rosparam <span class="hljs-built_in">list</span>    <span class="hljs-comment">#列出所有参数</span><br></code></pre></td></tr></table></figure><h4 id="六、实操"><a href="#六、实操" class="headerlink" title="六、实操"></a>六、实操</h4><p>1.乌龟<strong>控制节点</strong>实操举例：</p><ul><li>自己编写乌龟控制节点，实现乌龟的圆周运动。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">rqt_graph   <span class="hljs-comment">#通过计算图查看话题名称</span><br>rostopic <span class="hljs-built_in">type</span> /turtle1/cmd_vel  <span class="hljs-comment">#查看话题信息，获知消息类型为geometry_msgs/Twist</span><br>rosmsg info geometry_msgs/Twist  <span class="hljs-comment">#查看消息格式</span><br></code></pre></td></tr></table></figure><p>消息格式：</p><p>geometry_msgs/Vector3 linear<br>  float64 x<br>  float64 y<br>  float64 z<br>geometry_msgs/Vector3 angular<br>  float64 x<br>  float64 y<br>  float64 z</p><p>linear线速度，xyz分别对应在x、y和z方向上的速度(单位是 m/s)；</p><p>angular角速度，xyz分别对应x轴上的<strong>翻滚</strong>、y轴上<strong>俯仰</strong>和z轴上<strong>偏航</strong>的速度(单位是rad/s)</p><p>偏航、翻滚与俯仰（RPY）：</p><img src="/images/image-20210414142557153.png" alt="image-20210414142557153" style="zoom:50%;"><ul><li>实现控制节点（话题发布节点）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python">  <span class="hljs-comment">##将控制乌龟做圆周运动</span><br>    <br>  <span class="hljs-comment">#1.获取topic(已知: /turtle1/cmd_vel)</span><br>  <span class="hljs-comment">#2.获取消息类型(已知: geometry_msgs/Twist)</span><br>  <span class="hljs-comment">#3.运行前，注意先启动 turtlesim_node 节点</span><br><br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> geometry_msgs.msg <span class="hljs-keyword">import</span> Twist<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 2.初始化 ROS 节点</span><br>    rospy.init_node(<span class="hljs-string">&quot;control_circle_p&quot;</span>)<br>    <span class="hljs-comment"># 3.创建发布者对象</span><br>    pub = rospy.Publisher(<span class="hljs-string">&quot;/turtle1/cmd_vel&quot;</span>,Twist,queue_size=<span class="hljs-number">1000</span>)<br>    <span class="hljs-comment"># 4.循环发布运动控制消息</span><br>    rate = rospy.Rate(<span class="hljs-number">10</span>)<br>    msg = Twist()<br>    msg.linear.x = <span class="hljs-number">1.0</span>    <span class="hljs-comment">#不能横着走</span><br>    msg.linear.y = <span class="hljs-number">0.0</span><br>    msg.linear.z = <span class="hljs-number">0.0</span><br>    msg.angular.x = <span class="hljs-number">0.0</span><br>    msg.angular.y = <span class="hljs-number">0.0</span><br>    msg.angular.z = <span class="hljs-number">0.5</span>   <span class="hljs-comment">#只能偏航        </span><br><br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> rospy.is_shutdown():<br>        pub.publish(msg)<br>        rate.sleep()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#自定义的节点编写好之后：</span><br><span class="hljs-comment">#三个终端中：</span><br>roscore<br>rosrun  turtlesim  turtlesim_node  <br>rosrun  &lt;自定义的功能包&gt;  &lt;编写的节点文件名&gt;<br></code></pre></td></tr></table></figure><p>2.乌龟<strong>位姿信息订阅</strong>节点实操</p><p>已知turtlesim_node的位姿消息类型为：turtlesim/Pose</p><p>float32 x<br>float32 y<br>float32 theta<br>float32 linear_velocity<br>float32 angular_velocity</p><p>位姿信息订阅节点的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"> <span class="hljs-comment">#1.获取话题名称 /turtle1/pose</span><br> <span class="hljs-comment">#2.获取消息类型 turtlesim/Pose</span><br> <span class="hljs-comment">#3.运行前启动 turtlesim_node 与 turtle_teleop_key 节点</span><br>    <br><span class="hljs-keyword">import</span> rospy<br><span class="hljs-keyword">from</span> turtlesim.msg <span class="hljs-keyword">import</span> Pose<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doPose</span>(<span class="hljs-params">data</span>):</span><br>    rospy.loginfo(<span class="hljs-string">&quot;乌龟坐标:x=%.2f, y=%.2f,theta=%.2f&quot;</span>,data.x,data.y,data.theta)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br><br>    <span class="hljs-comment"># 2.初始化 ROS 节点</span><br>    rospy.init_node(<span class="hljs-string">&quot;sub_pose_p&quot;</span>)<br><br>    <span class="hljs-comment"># 3.创建订阅者对象</span><br>    sub = rospy.Subscriber(<span class="hljs-string">&quot;/turtle1/pose&quot;</span>,Pose,doPose,queue_size=<span class="hljs-number">1000</span>)<br>    <span class="hljs-comment">#     4.回调函数处理订阅的数据</span><br>    <span class="hljs-comment">#     5.spin</span><br>    rospy.spin()<br></code></pre></td></tr></table></figure><p>3.（服务通信）指定位置添加turtle的<strong>服务端请求</strong>实现：</p><p>服务也是基于话题的，所以首先是查看话题的消息类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 新增乌龟的话题是/spawn</span><br>rosservice <span class="hljs-built_in">type</span> /spawn  <span class="hljs-comment">#获取消息类型为turtlesim/Spawn</span><br>rossrv info turtlesim/Spawn  <span class="hljs-comment">#获取消息格式</span><br></code></pre></td></tr></table></figure><p>节点的实现大同小异，略</p><p>4.（参数服务器）参数设置</p><p>可通过launch文件传参，后面再介绍。</p><h4 id="七、常用API（python实现）"><a href="#七、常用API（python实现）" class="headerlink" title="七、常用API（python实现）"></a>七、常用API（python实现）</h4><p>1.节点初始化</p><p>重点在于anonymous参数的使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">rospy.init_node(<span class="hljs-string">&quot;happy_node&quot;</span>, anonymous=<span class="hljs-literal">True</span>)    <span class="hljs-comment">#anonymous = true 时，为节点名称后缀随机编号</span><br>                                                                                                             <span class="hljs-comment">#这样就可重复启动节点了！</span><br></code></pre></td></tr></table></figure><p>2.话题与服务相关对象</p><p>Publisher、Subscriber、Server、Client的创建，publish操作等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#需要就查</span><br></code></pre></td></tr></table></figure><p>3.回调函数</p><p>相比C++，没有spinOnce( )函数，只有spin( )函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">rospy.spin( )<br></code></pre></td></tr></table></figure><p>4.时间</p><p>（1）获取、设置时刻</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取当前时刻</span><br>right_now = rospy.Time.now()  <span class="hljs-comment">#rospy中有Time库，获取的是相对于1970年1月1日的时间</span><br>rospy.loginfo(<span class="hljs-string">&quot;当前时刻:%.2f&quot;</span>,right_now.to_sec())  <span class="hljs-comment">#设置输出日志log</span><br>rospy.loginfo(<span class="hljs-string">&quot;当前时刻:%.2f&quot;</span>,right_now.to_nsec())<br><br><span class="hljs-comment"># 自定义时刻</span><br>some_time1 = rospy.Time(<span class="hljs-number">1234.567891011</span>)  <span class="hljs-comment">#some_time1是从1970.1.1的0时0分0秒开始往后1234.567891011秒</span><br>some_time2 = rospy.Time(<span class="hljs-number">1234</span>,<span class="hljs-number">567891011</span>)<br>rospy.loginfo(<span class="hljs-string">&quot;设置时刻1:%.2f&quot;</span>,some_time1.to_sec())<br>rospy.loginfo(<span class="hljs-string">&quot;设置时刻2:%.2f&quot;</span>,some_time2.to_sec())<br></code></pre></td></tr></table></figure><p>（2）持续时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">du = rospy.Duration(<span class="hljs-number">3.3</span>)<br><br>rospy.loginfo(<span class="hljs-string">&quot;du1 持续时间:%.2f&quot;</span>,du.to_sec())<br>rospy.sleep(du) <span class="hljs-comment">#休眠函数</span><br>rospy.loginfo(<span class="hljs-string">&quot;持续时间测试结束.....&quot;</span>)<br></code></pre></td></tr></table></figure><p>（3）持续时间与时刻的运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">now = rospy.Time.now()<br>du1 = rospy.Duration(<span class="hljs-number">10</span>)<br>du2 = rospy.Duration(<span class="hljs-number">20</span>)<br><br><span class="hljs-comment">#运算</span><br>before_now = now - du1<br>after_now = now + du1<br>dd = du1 + du2<br><span class="hljs-comment"># now = now + now  #非法</span><br>rospy.loginfo(<span class="hljs-string">&quot;之前时刻:%.2f&quot;</span>,before_now.to_sec())<br>rospy.loginfo(<span class="hljs-string">&quot;之后时刻:%.2f&quot;</span>,after_now.to_sec())<br>rospy.loginfo(<span class="hljs-string">&quot;持续时间相加:%.2f&quot;</span>,dd.to_sec())<br></code></pre></td></tr></table></figure><p><strong>（4）设置运行频率</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#通过rate.sleep( )实现，隔某段时间执行某种操作</span><br><br>rate = rospy.Rate(<span class="hljs-number">0.5</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> rospy.is_shutdown():<br>    rate.sleep() <span class="hljs-comment">#休眠</span><br>    rospy.loginfo(<span class="hljs-string">&quot;+++++++++++++++&quot;</span>)<br></code></pre></td></tr></table></figure><p>（5）定时器，类似于rospy.Rate的功能：<strong>隔某段时间执行某种操作</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">rospy.Timer(rospy.Duration(<span class="hljs-number">1</span>),doMsg)   <span class="hljs-comment">#每隔1s，执行回调函数doMsg</span><br>rospy.spin()<br><br>rospy.Timer(rospy.Duration(<span class="hljs-number">1</span>),doMsg,<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 只执行一次</span><br>rospy.spin()<br></code></pre></td></tr></table></figure><p>（6）节点判断与关闭</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#节点状态判断</span><br>rospy.is_shutdown()<br><br><span class="hljs-comment">#节点关闭函数</span><br>rospy.signal_shutdown(<span class="hljs-string">&quot;不想用了&quot;</span>)  <span class="hljs-comment">#传参是字符串，说明关闭原因</span><br><br><span class="hljs-comment">#关闭节点，同时执行回调函数</span><br>rospy.on_shutdown(doMsg)<br></code></pre></td></tr></table></figure><p><strong>（7）日志函数</strong>：相当于实时打印一些提示信息</p><p>日志相关的函数也是极其常用的，在ROS中日志被划分成如下级别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">rospy.logdebug(<span class="hljs-string">&quot;hello,debug&quot;</span>)  <span class="hljs-comment">#不会输出到控制台，调试时常用</span><br>rospy.loginfo(<span class="hljs-string">&quot;hello,info&quot;</span>)  <span class="hljs-comment">#标准消息，默认白色字体</span><br>rospy.logwarn(<span class="hljs-string">&quot;hello,warn&quot;</span>)  <span class="hljs-comment">#提醒一些异常情况，默认黄色字体</span><br>rospy.logerr(<span class="hljs-string">&quot;hello,error&quot;</span>)  <span class="hljs-comment">#提示错误信息，默认红色字体</span><br>rospy.logfatal(<span class="hljs-string">&quot;hello,fatal&quot;</span>) <span class="hljs-comment">#此类错误将阻止节点继续运行，默认红色字体</span><br></code></pre></td></tr></table></figure><p><strong>5.python模块导入</strong></p><p>先编写自定义模块文件（相当于C++头文件）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># tools.py文件</span><br><br>num=<span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><p>另一个python文件中调用模块A：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tools<br>rospy.loginfo(<span class="hljs-string">&quot;num = %d&quot;</span>,tools.num)<br></code></pre></td></tr></table></figure><p>如果直接import新写的模块，会报错</p><p>原因：rosrun执行时，参考路径是workspace的路径，在workspace下无法查找到依赖的模块</p><p>解决：先声明环境变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment">#为了增加代码的可移植性，用os自动获取当前路径的前一级</span><br>path = os.path.abspath(<span class="hljs-string">&quot;.&quot;</span>)<br>sys.path.insert(<span class="hljs-number">0</span>, path + <span class="hljs-string">&quot;/src/plumbing_pub_sub/scripts&quot;</span>)  <span class="hljs-comment">#将模块文件所在路径添加到sys.path中</span><br><br><span class="hljs-keyword">import</span> tools    <br>rospy.loginfo(<span class="hljs-string">&quot;num = %d&quot;</span>,tools.num)  <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ROS学习笔记：古月居入门21讲</title>
    <link href="/2021/04/12/ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8F%A4%E6%9C%88%E5%B1%85%E5%85%A5%E9%97%A821%E8%AE%B2/"/>
    <url>/2021/04/12/ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%8F%A4%E6%9C%88%E5%B1%85%E5%85%A5%E9%97%A821%E8%AE%B2/</url>
    
    <content type="html"><![CDATA[<p>本文记录<strong>热度最高</strong>的ROS入门教程——古月居入门21讲学习笔记，该教程确实非常基础，学完只能了解ROS的基本概念，要想完成项目开发，还需要很多更深入的学习与实战。</p><span id="more"></span><h3 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h3><p>1.节点Node：如上层的图像处理（python）、底层的设备驱动（C）</p><p>2.节点管理器ROS Master：节点需要找ros master进行注册（registration）</p><img src="/images/image-20210402080956710.png" alt="image-20210402080956710" style="zoom: 67%;"><p>Camera将data传给图像处理节点，处理完后又将data传给远端的图像显示节点（<strong>上位机</strong>），这些传输都由ROS Master协助完成</p><p>3.节点之间的通信方式：</p><p>（1）话题Topic：node分为publisher、subscriber</p><p>​                            消息Message：data的数据结构</p><p>（2）服务Service：node分为server、client</p><p>4.参数：全局共享字典</p><p>5.文件系统:</p><img src="/images/image-20210402081825526.png" alt="image-20210402081825526" style="zoom:50%;"><h3 id="二、ROS命令行基础"><a href="#二、ROS命令行基础" class="headerlink" title="二、ROS命令行基础"></a>二、ROS命令行基础</h3><p>1.常用命令</p><img src="/images/image-20210402162010648.png" alt="image-20210402162010648" style="zoom:50%;"><ol start="2"><li><p>roscore 启动</p><p>rosrun *** 启动节点</p><p>rqt_gragh 基于qt平台的节点关系可视化</p><p>rosnode 显示所有可使用的rosnode命令   如rosnode list显示所有节点信息</p><p>rostopic 显示所有可使用的rostopic命令    如rostopic pub *** ***发布话题内容</p><p>rosmsg show *** 查看消息内容（即话题的数据结构）</p><p>rosservice list 查看所有服务（海龟窗口是服务器，我们的计算机是客户，对其发送请求）</p><p>rosbag record -a *** 保存ros系统的所有数据</p></li><li><p>创建工作空间（<strong>workspace</strong>）与功能包（）</p><p>（1）workspace相当于编程中的一个project，包括四个子空间：</p><img src="/images/image-20210402163435233.png" alt="image-20210402163435233" style="zoom:50%;"><p>（2）workspace创建方法:</p><img src="/images/image-20210402163628877.png" alt="image-20210402163628877" style="zoom: 67%;"><p>其中install空间需要自己添加：catkin_make install</p><p>（3）功能包创建方法:</p><p>​        在workspace中的src文件夹下进行创建</p><img src="/images/image-20210402164016861.png" alt="image-20210402164016861" style="zoom:50%;"><p><strong>catkin_create_pkg</strong>  <name>  依赖包 依赖包 </name></p></li></ol><h3 id="三、基本Topic模型的编程实现"><a href="#三、基本Topic模型的编程实现" class="headerlink" title="三、基本Topic模型的编程实现"></a>三、基本Topic模型的编程实现</h3><p>（以海龟运动为例）</p><ol><li><p>发布者Publisher编程实现：（C++）</p><p>（1）在功能包下的src文件夹下创建cpp文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs linux">touch xxx.cpp<br>sudo gedit xxx.cpp<br></code></pre></td></tr></table></figure><p>（2）文件中内容：</p><img src="/images/image-20210402170454195.png" alt="image-20210402170454195" style="zoom:67%;"><p>（3）流程：</p><img src="/images/image-20210402170612567.png" alt="image-20210402170612567" style="zoom:67%;"><p>创建Publisher，即向ROS Master注册节点信息，需要指定Topic名称和message信息</p><p>while循环内部：创建message数据、按照一定频率循环发布消息</p><p>（4）配置Cmake文件中的代码编译：</p><p>在功能包中CMakeLlist.txt中添加两行内容</p><img src="/images/image-20210402171124849.png" alt="image-20210402171124849" style="zoom:50%;"></li><li><p>Publisher的 Python实现：</p></li></ol><img src="/images/image-20210402171918479.png" alt="image-20210402171918479" style="zoom:67%;"><p>​        python是脚本语言，不需要在CMakeList中进行编译，<strong>直接rosrun运行.py文件即可</strong></p><p>Tips1：</p><p>通常编译后需要添加环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs linux">source devel&#x2F;setup.bash<br></code></pre></td></tr></table></figure><p>为了避免每一次编译后都更新环境变量，可以将上述语句直接添加到系统环境变量中，一劳永逸：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Linux">在&#x2F;home目录下 Ctrl+h 显示隐藏文件<br>打开.barshc文件<br>在文件末尾添加上述语句 ”source xxx(绝对路径)“ <br>保存退出即可<br></code></pre></td></tr></table></figure><p>3.Subscriber的python实现：</p><p><img src="/images/image-20210403091717518.png" alt="image-20210403091717518"></p><p>4.自定义话题消息：</p><p>上述publisher中的Twist消息、subscriber中的Pose消息，都是ROS中已经定义好的message，直接用即可</p><p>如果ROS中现成的消息不满足需求，则需要自己定义话题消息</p><img src="/images/image-20210403092312179.png" alt="image-20210403092312179" style="zoom:50%;"><p>（1）首先写.msg文件，其中语法不是C++或者python，而是在编译时自适应；消息的定义就是在.msg文件中实现</p><p>（2）package.xml中固定添加上述两行</p><p>（3）重点难点是.msg文件的编译</p><p>（4）消息定义好后，看看在此消息基础上的话题模型：</p><img src="/images/image-20210403094303816.png" alt="image-20210403094303816" style="zoom:67%;"><p>​        publisher：之前的.msg文件编译后生成了Person头文件，所以可以import Person；可以看到，消息类型使用了自定义的Person</p><img src="/images/image-20210403094414267.png" alt="image-20210403094414267" style="zoom:67%;"><p>​        subscriber：订阅的topic与上面一致，消息类型也是使用自定义的Person</p><h3 id="四、基本Service模型的编程实现"><a href="#四、基本Service模型的编程实现" class="headerlink" title="四、基本Service模型的编程实现"></a>四、基本Service模型的编程实现</h3><p>1.Client</p><p><img src="/images/image-20210403095623267.png" alt="image-20210403095623267"></p><p>2.Server</p><p><img src="/images/image-20210403100135793.png" alt="image-20210403100135793"></p><p>3.服务数据的定义</p><img src="/images/image-20210403100745236.png" alt="image-20210403100745236" style="zoom:67%;"><p>创建.srv文件，上面是request，下面是response</p><p>Tip2：</p><p>ros master中有参数共享器，所以每次运行新的程序之前最好重启roscore：Ctrl+c退出roscore，再重新roscore</p><p>Tip3：</p><p>话题模型中，publisher和subscriber建立连接后，不再需要roscore；roscore的作用相当于“婚介所”</p><h3 id="五、参数使用与编程"><a href="#五、参数使用与编程" class="headerlink" title="五、参数使用与编程"></a>五、参数使用与编程</h3><p>1.参数模型</p><img src="/images/image-20210403102415841.png" alt="image-20210403102415841" style="zoom:50%;"><p>2.命令行</p><img src="/images/image-20210403102822696.png" alt="image-20210403102822696" style="zoom:67%;"><p>3.参数设置python实现:</p><p><img src="/images/image-20210403103225844.png" alt="image-20210403103225844"></p><p>get获取、set设置，创建client端请求service修改</p><h3 id="六、ROS中的坐标管理系统"><a href="#六、ROS中的坐标管理系统" class="headerlink" title="六、ROS中的坐标管理系统"></a>六、ROS中的坐标管理系统</h3><p>1.初识</p><p>机器人中的坐标变换</p><p>一个机器人身上有多种坐标系，如机器人上<strong>摄像头有坐标系</strong>，机器人<strong>底盘亦有坐标系</strong>；如果用原始办法计算二者之间的坐标关系，可能需要几十次的矩阵运算</p><img src="/images/image-20210403103841705.png" alt="image-20210403103841705" style="zoom:67%;"><p>变换矩阵：平移变换、旋转变换</p><p>2.ROS中的 <strong>tf功能包</strong>（<strong>transform</strong>）</p><p>重要用途：<strong>管理所有坐标系</strong>；通过查询的方式就可以轻松找到两个坐标系之间的关系</p><p>实现方式：广播与监听机制；只要启动ros master和 tf， 就会在后台维护一个<strong>tf tree</strong>，所有坐标系都保存在树的节点上</p><p>3.举例</p><p>激光雷达与机器人</p><img src="/images/image-20210403104844895.png" alt="image-20210403104844895" style="zoom:67%;"><p>移动机器人搭载激光雷达获取物体的“深度”信息，但是我们关心的是小车底盘到物体的举例，所以由激光雷达检测到的距离需要经过一个坐标变换</p><p>4.tf坐标系广播与监听的编程实现</p><p>（1）实现 tf广播器（Broadcaster）：</p><p>（2）实现tf监听器（Listener）：</p><p><img src="/images/image-20210403111805593.png" alt="image-20210403111805593"></p><p>广播器实时subscribe订阅海龟的位置信息，并TF坐标变换信息广播出去</p><h3 id="七、Launch启动文件"><a href="#七、Launch启动文件" class="headerlink" title="七、Launch启动文件"></a>七、Launch启动文件</h3><p>1.初识</p><img src="/images/image-20210403112318960.png" alt="image-20210403112318960" style="zoom:67%;"><p>实现多节点的配置和启动，不需要再使用多个终端进行不同节点的启动；一个复杂机器人系统中的节点非常繁多，所以不可能都用终端来启动</p><p>2.Launch文件常用语法</p><img src="/images/image-20210403112620983.png" alt="image-20210403112620983" style="zoom:67%;"><p>在一个话题中节点名字不能重复，因此采用“重映射”使相同功能包使用不同的节点名字，在Launch中用<strong>name参数</strong>实现</p><p><img src="/images/image-20210403112941517.png" alt="image-20210403112941517"></p><p>param指定存在ros master内部的参数；arg指定仅存在Launch文件中的参数，可以作为函数的参数使用</p><p><img src="/images/image-20210403113151035.png" alt="image-20210403113151035"></p><p>3.后续学习时，尤其是和真实机器人做结合时，Launch文件的使用非常频繁</p><p>在做ROS中已有资源的整合时，尤其是将导航、SLAM的一些功能（ROS中都已有这些功能）与机器人做结合，基本上不用写太多代码，基本上都是在改各种Launch文件；Launch文件相当于是我们搭积木的平台，通过Launch文件中节点的运行、接口的变化和配置，最终可以将功能很快的实现</p><h3 id="八、ROS常用可视化工具"><a href="#八、ROS常用可视化工具" class="headerlink" title="八、ROS常用可视化工具"></a>八、ROS常用可视化工具</h3><p>1.QT工具箱</p><p>综合性工具， 可作为开发机器人的上位机</p><p>2.Rviz</p><p>数据显示平台——必须有实际的数据</p><p><img src="/images/image-20210403144643000.png" alt="image-20210403144643000"></p><p><img src="/images/image-20210403144906971.png" alt="image-20210403144906971"></p><p>在rviz中添加image，可以选择话题，实时显示摄像头拍摄内容</p><p>3.Gazebo</p><p>三维物理仿真平台——不需要真实数据</p><h3 id="九、ROS进阶"><a href="#九、ROS进阶" class="headerlink" title="九、ROS进阶"></a>九、ROS进阶</h3><p>1.ros_control + gazebo 进行机器人控制与仿真，继承了PID等控制算法，可以让小车搭载GPS、雷达、IMU等进行障碍物仿真；没有实物也可进行仿真；也可模拟小车搭载摄像头，将摄像头拍摄的内容在rviz中进行显示（如下图）</p><img src="/images/image-20210403145938507.png" alt="image-20210403145938507" style="zoom:50%;"><p>在仿真环境中学习机器人相关理论、验证相关的算法</p><p>wiki.ros.org/ros_control</p><p>2.移动机器人</p><p>SLAM建图与导航 主流算法：gmapping、hector</p><p><img src="/images/image-20210403150428016.png" alt="image-20210403150428016"></p><p>（1）深度信息：雷达、相机（单目/双目）、RGBD相机</p><p>（2）IMU信息（三轴姿态角及加速度）：陀螺仪、加速计</p><p>（3）里程计信息：编码器上的累计信息</p><p>算法功能集成得很好，只要将ROS提供的功能包与机器人结合，可能不需要自己写一行代码就能让机器人跑起来，但是会遇到很多问题，因为这些算法不一定能完全适配你的硬件平台：如建图精度不够、导航上避障效果不好。</p><p>所以除了会使用ROS外，还要深入了解其功能包内部的实现原理。即用ROS可以很快地实现原型，但是要深入地了解自己研究方向的算法原理，例如研究SLAM，要知道gmapping、hector内部的实现机理，甚至对代码做优化</p><p>3.机械臂</p><p>机械臂运动规划、避障、抓取等</p><p>ROS中moveit框架可以完成</p><p>总结：若未来研究机器人，研究ROS中很多功能包，这些功能包内的具体算法用到了“机器人学”的基本理论</p>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神经网络：Faster R-CNN详解（二）</title>
    <link href="/2021/04/11/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%9AFaster-R-CNN%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2021/04/11/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%9AFaster-R-CNN%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>本节介绍Conv Layers和RPN网络</p><p>在原论文中，作者多次强调了RPN的重要性。R-CNN和Fast R-CNN都是selective search花费大量时间，而RPN实现了由CNN自己做区域建议，效率奇高。</p><span id="more"></span><h3 id="三、Faster-R-CNN"><a href="#三、Faster-R-CNN" class="headerlink" title="三、Faster R-CNN"></a>三、Faster R-CNN</h3><p>相比于Fast R-CNN，它的进步在于区域建议网络：RPN</p><p>1.Faster R-CNN将特征提取、区域建议、bbox回归、分类都整合在一个网络中，也即输入一张图像后所有操作都在CNN中完成，因此它是真正意义上实现了<strong>“end-to-end”</strong>！</p><p>2.整体框架：</p><img src="/images/image-20210411154919630.png" alt="image-20210411154919630" style="zoom:50%;"><p>（1）Conv layers，完成特征提取，后续的操作都在feature map上进行，所以具有“特征共享”的特点；通常使用VGG16、Resnet等；</p><p>（2）Region Proposal Networks (RPN)：生成候选区域，通过FC层 (Softmax)判断anchors属于positive或者negative，再利用bbox regression修正anchors获得精确的proposals；</p><p>（3）Roi Pooling：收集输入的feature maps和proposals，综合这些信息后提取<strong>proposal feature maps</strong>，送入后续全连接层判定目标类别；</p><p>（4）Classification：利用proposal feature maps计算proposal的类别，同时再次bounding box regression获得检测框最终的精确位置。</p><p>3.Conv layers:</p><p>实际代码操作中，采用了一个小<strong>trick</strong>：通过padding使得所有卷积层的结果不改变长度和宽度，而所有pooling层都将长宽减半，因此最终输出的长宽为原始图像的1/16倍。这样，Conv layers生成的feature map中都可以和原图对应起来！</p><p><strong>4.RPN:</strong></p><img src="/images/v2-1908feeaba591d28bee3c4a754cca282_r.jpg" alt="preview" style="zoom:67%;"><ul><li>feature map中每个点上有k个anchor，每个anhcor要分positive和negative；</li><li>如果k=9，则总共有20000+anchors，所以全部anchors拿去训练太多了，训练程序会在合适的anchors中<strong>随机</strong>选取128个postive anchors+128个negative anchors进行训练；</li><li>流程：生成anchors -&gt; softmax分类器提取positvie anchors -&gt; bbox reg回归positive anchors -&gt; Proposal Layer生成proposals</li></ul><p><strong>（1）softmax判定positive与negative：（W×H×2k）</strong></p><p>现讨论如何对每个anchors分positive和negative：</p><p>其实RPN最终就是在原图尺度上，设置了密密麻麻的候选Anchor。然后用cnn去判断哪些Anchor是里面有目标的positive anchor，哪些是没目标的negative anchor。所以，仅仅是个二分类而已！</p><img src="/images/image-20210411163229689.png" alt="image-20210411163229689" style="zoom:67%;"><p>（流程：3×3卷积 → 1×1卷积 →Softmax）</p><p><strong>疑问</strong>：3×3卷积是在feature map上进行的，每个点就一次，得到1×1×256向量，这是<strong>怎么牵扯到9个anchors的？</strong>很多人都会在初次学习时产生这个疑问！ 我在阅读了数十条博文大神的评论之后终于看到一种合理的解释：</p><p>这里的3x3卷积输出256dfeature map, 卷积后(c,w,h)均未改变，这里的3x3卷积只是在进一步提取特征，与后面两路1x1卷积相配合，共同输出对foreground/background和anchor_pred的预测值，真正体现Anchor数量 和其在map中的维度的地方是两路1×1卷积后的输出。</p><p>特征图的每个像素位置都能看成一个向量 [1，channels]（卷积基本原理：这个像素可不简单，它代表的是高级语义，其信息量远不只一个像素那么简单，而是包含有周边好几大圈的信息）。<strong>所以这个向量 [1，channels]是能代表一个位置上的9个anchors的</strong>，理解这一点后就好办了，利用1x1卷积分别将通道数压缩到2x9（代表分类）以及4x9（代表坐标回归值）建立一种抽象的映射（这其实和全连接是一个道理的都是建立映射的过程嘛）。所以就可以通过损失函数来指导RPN的训练啦。</p><p>经过softmax分类后，就可以提取出<strong>positive anchors</strong>了。</p><ul><li>解释一下这里的18维：</li></ul><p>​      前9维对应9个anchor属于foreground的概率，后9维对应9个anchor属于background的概率；这里面最大概率的那个就决定是foreground还是background，也决定了是属于9个anchors里面的哪一个</p><p><strong>（2）对Proposals进行bbox regression：（W×H×4k）</strong></p><img src="/images/image-20210411172715373.png" alt="image-20210411172715373" style="zoom:67%;"><p>（流程：3×3卷积 → 1×1卷积 ）</p><p>feature maps每个点都有9个anchors，每个anchors又都有4个用于回归的</p><p><img src="https://www.zhihu.com/equation?tex=%5Bd_%7Bx%7D(A),d_%7By%7D(A),d_%7Bw%7D(A),d_%7Bh%7D(A)%5D+%5Ctag%7B11%7D" alt="[公式]"></p><p>变换量。</p><ul><li><p>综上，2k和4k可以理解为用来<strong>“占位的”</strong>，因为无论是3×3卷积、1×1卷积都没涉及anchors，要通过1×1卷积为k个anchors预留2k、4k的位置，用于后面的“针对anchors”的操作！</p><img src="/images/image-20210411173320250.png" alt="image-20210411173320250" style="zoom:50%;"></li></ul><p><strong>（3）bbox regerssion回归positive anchors ：（bbox reg原理）</strong></p><p>（注：由于数学原理较复杂，且思路比较绕，所以此处直接参考博文：<a href="https://zhuanlan.zhihu.com/p/31426458%EF%BC%89">https://zhuanlan.zhihu.com/p/31426458）</a></p><img src="/images/v2-ea7e6e48662bfa68ec73bdf32f36bb85_720w.jpg" alt="img" style="zoom:67%;"><p>红色的框A代表原始的positive Anchors，绿色的框G代表目标的GT，我们的目标是寻找一种关系，使得输入原始的anchor A经过映射得到一个跟真实窗口G更接近的回归窗口G’</p><p>那么经过何种变换<strong>F</strong>才能从图10中的anchor A变为G’呢？ 比较简单的思路就是:</p><ul><li>先做平移</li></ul><p><img src="https://www.zhihu.com/equation?tex=G_x%27=A_w%5Ccdot+d_x(A)++A_x%5Ctag%7B2%7D" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=G_y%27=A_h%5Ccdot+d_y(A)++A_y%5Ctag%7B3%7D" alt="[公式]"></p><ul><li>再做缩放</li></ul><p><img src="https://www.zhihu.com/equation?tex=G_w%27=A_w%5Ccdot+%5Cexp(d_w(A))+%5Ctag%7B4%7D" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=G_h%27=A_h%5Ccdot+%5Cexp(d_h(A))%5Ctag%7B5%7D" alt="[公式]"></p><p>观察上面4个公式发现，需要学习的是 <img src="https://www.zhihu.com/equation?tex=d_%7Bx%7D(A),d_%7By%7D(A),d_%7Bw%7D(A),d_%7Bh%7D(A)" alt="[公式]"> 这四个变换。当输入的anchor A与GT相差较小时，可以认为这种变换是一种线性变换， 那么就可以用线性回归来建模对窗口进行微调（注意，只有当anchors A和GT比较接近时，才能使用线性回归模型，否则就是复杂的非线性问题了）。</p><p>接下来的问题就是如何通过线性回归获得 <img src="https://www.zhihu.com/equation?tex=d_%7Bx%7D(A),d_%7By%7D(A),d_%7Bw%7D(A),d_%7Bh%7D(A)" alt="[公式]"> 了。线性回归就是给定输入的特征向量X, 学习一组参数W, 使得经过线性回归后的值跟真实值Y非常接近，即<img src="https://www.zhihu.com/equation?tex=Y=WX" alt="[公式]">。对于该问题，输入X是cnn feature map，定义为Φ；同时还有训练传入A与GT之间的变换量，即<img src="https://www.zhihu.com/equation?tex=(t_%7Bx%7D,+t_%7By%7D,+t_%7Bw%7D,+t_%7Bh%7D)" alt="[公式]">。输出是<img src="https://www.zhihu.com/equation?tex=d_%7Bx%7D(A),d_%7By%7D(A),d_%7Bw%7D(A),d_%7Bh%7D(A)" alt="[公式]">四个变换。那么目标函数可以表示为：</p><p><img src="https://www.zhihu.com/equation?tex=d_*(A)=W_*%5ET%5Ccdot+%5Cphi(A)%5Ctag%7B6%7D" alt="[公式]"></p><p>其中 <img src="https://www.zhihu.com/equation?tex=%5Cphi(A)" alt="[公式]"> 是对应anchor的feature map组成的特征向量， <img src="https://www.zhihu.com/equation?tex=W_*" alt="[公式]"> 是需要学习的参数， <img src="https://www.zhihu.com/equation?tex=d_*(A)" alt="[公式]"> 是得到的预测值（*表示 x，y，w，h，也就是每一个变换对应一个上述目标函数）。为了让预测值 <img src="https://www.zhihu.com/equation?tex=d_*(A)" alt="[公式]"> 与真实值 <img src="https://www.zhihu.com/equation?tex=t_*" alt="[公式]"> 差距最小，设计L1损失函数：</p><p><img src="https://www.zhihu.com/equation?tex=%5Ctext%7BLoss%7D=%5Csum_%7Bi%7D%5E%7BN%7D%7B%7Ct_*%5Ei-W_*%5ET%5Ccdot+%5Cphi(A%5Ei)%7C%7D+%5Ctag%7B7%7D" alt="[公式]"></p><p>函数优化目标为：</p><p><img src="https://www.zhihu.com/equation?tex=%5Chat%7BW%7D_*=%5Ctext%7Bargmin%7D_%7BW_*%7D%5Csum_%7Bi%7D%5E%7Bn%7D%7Ct_*%5Ei-+W_*%5ET%5Ccdot+%5Cphi(A%5Ei)%7C+%5Clambda%7C%7CW_*%7C%7C++%5Ctag%7B8%7D" alt="[公式]"></p><p>为了方便描述，这里以L1损失为例介绍，而真实情况中一般使用soomth-L1损失。</p><p>需要说明，只有在GT与需要回归框位置比较接近时，才可近似认为上述线性变换成立。<br>说完原理，对应于Faster RCNN原文，positive anchor与ground truth之间的平移量 <img src="https://www.zhihu.com/equation?tex=(t_x,+t_y)" alt="[公式]"> 与尺度因子 <img src="https://www.zhihu.com/equation?tex=(t_w,+t_h)" alt="[公式]"> 如下：（<strong>原文给出的映射关系真实值</strong>，目标是训练参数W，使得WX的结果Y更接近与下面给出的值，这个Y就是预测的映射变换值）</p><p><img src="https://www.zhihu.com/equation?tex=t_x=(x-x_a)/w_a%5C+%5C+%5C+%5C++t_y=(y-y_a)/h_a+%5Ctag%7B9%7D" alt="[公式]"></p><p><img src="https://www.zhihu.com/equation?tex=t_w=%5Clog(w/w_a)%5C+%5C+%5C+%5C+t_h=%5Clog(h/h_a)+%5Ctag%7B10%7D" alt="[公式]"></p><p>对于训练bouding box regression网络回归分支，输入是cnn feature Φ，监督信号是Anchor与GT的差距 <img src="https://www.zhihu.com/equation?tex=(t_x,+t_y,+t_w,+t_h)" alt="[公式]">，即训练目标是：输入 Φ的情况下使网络输出与监督信号尽可能接近。那么当bouding box regression工作时，再输入Φ时，回归网络分支的输出就是每个Anchor的平移量和变换尺度 <img src="https://www.zhihu.com/equation?tex=(t_x,+t_y,+t_w,+t_h)" alt="[公式]">，显然即可用来修正Anchor位置了。</p><p>（4）<strong>Proposal Layer整合信息</strong>，生成RPN网络最终的feature proposals：</p><p>流程如下：</p><ol><li>生成anchors，利用<img src="https://www.zhihu.com/equation?tex=%5Bd_%7Bx%7D(A),d_%7By%7D(A),d_%7Bw%7D(A),d_%7Bh%7D(A)%5D" alt="[公式]">对所有的anchors做bbox regression回归（这里的anchors生成和训练时完全一致）</li><li>按照输入的positive softmax scores由大到小排序anchors，提取前pre_nms_topN(e.g. 6000)个anchors，即提取修正位置后的positive anchors</li><li>限定超出图像边界的positive anchors为图像边界，防止后续roi pooling时proposal超出图像边界（见文章底部QA部分图21）</li><li>剔除尺寸非常小的positive anchors</li><li>对剩余的positive anchors进行NMS（nonmaximum suppression）</li><li>Proposal Layer有3个输入：positive和negative anchors分类器结果rpn_cls_prob_reshape，对应的bbox reg的(e.g. 300)结果作为proposal输出</li></ol><p>参考博文：<a href="https://zhuanlan.zhihu.com/p/31426458">https://zhuanlan.zhihu.com/p/31426458</a></p>]]></content>
    
    
    <categories>
      
      <category>Deep Learning-Objects Detection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>神经网络：Faster R-CNN详解（一）</title>
    <link href="/2021/04/11/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%9AFaster-R-CNN%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/04/11/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%9AFaster-R-CNN%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>Faster R-CNN是早期经典的目标检测网络，虽然如今已经有YOLO等更强大的检测网络，但其思想都是基于Faster R-CNN的，本系列记录我在学习Faster R-CNN中的体会。</p><span id="more"></span><p>如果囫囵吞枣式地学习Faster R-CNN，会觉得很顺利。但是当我最近dive into到其中的细节时，着实让我花费了很多功夫。</p><p>在阅读了原始论文后，我产生了很多疑惑，于是在阅读博文的过程中，尝试一点一点解开这些疑惑，现将我阅读完后的综合产出记录于此。由于内容较长，分为多篇文章记录。</p><p>要想彻底理解Faster RCNN的流程与思想，有必要从R-CNN和SPP-net开始解读：</p><h3 id="一、R-CNN"><a href="#一、R-CNN" class="headerlink" title="一、R-CNN"></a>一、R-CNN</h3><img src="/images/webp" alt="img" style="zoom:67%;"><p>流程：</p><p>Input Image → Crop/warp(候选区域的生成并<strong>resize为固定尺寸</strong>) → 将统一尺寸的图片输入到Conv layer提取特征 → 将特征向量输入FC层 → out</p><p>特点：</p><p>（1）直接在原图像上卷积</p><p>（2）必须保证输入Conv layer的图像尺寸大小一致，即必须采用resize操作；但resize操作         会使原图像产生一定的扭曲、拉伸，使结果变差；</p><p>（3）对于2000个候选区域，分别要进行一次卷积，也即要进行2000次卷积的前向传播；</p><h3 id="二、SPP-net"><a href="#二、SPP-net" class="headerlink" title="二、SPP-net"></a>二、SPP-net</h3><p>针对RCNN的缺点进行优化</p><p>1.目标：可以使用不同尺寸的原图输入，经过Conv layer之后输出不同尺寸的feature map</p><p>2.关键做法：在Conv layer提取完特征后（由于输入图像尺寸不一，所以此时的feature map尺寸也不同），<strong>先经过一个spp层</strong>，再输入FC层。</p><p>​    试想，如果没有spp层，直接输入到FC层，由于每张图片的feature map尺寸都不同，那就要针对每张图片都设计FC层的节点个数，这显然是不实际的！所以要想让输入尺寸任意，必须在Conv layer之后经过一个spp层！</p><p>3.流程：</p><p>Input Image → Conv layer(输出不同尺寸的feature map) → <strong>spp</strong> → 统一尺寸的特征向量输入FC → out</p><p>4.<strong>spp层</strong>（Spatial Pyramid Pooling layer, <strong>空间金字塔池化层</strong>）：</p><img src="/images/image-20210411113820201.png" alt="image-20210411113820201" style="zoom:67%;"><ul><li>比例池化</li></ul><p>对于任何尺寸的feature map，我都做同一件事情：将feature map等分成三种比例，分别进行池化(max pooling)。三种比例分别为：4×4、2×2、1×1，这样直接规定分成几份，至于一份的大小就是可变的了！三种比例的池化输出特征个数分别为：16、4、1</p><p>这样，无论来的feature map是多大的，我都能通过上述三种比例使池化后的输出个数为16+4+1=21个，再考虑上feature map的通道数，则为21×256个特征。将这些特征组成向量，就实现了尺寸统一了，然后再输入FC层，就不会存在任何问题了！</p><p>再品，我如何对不同尺寸的输入图像都有较好的效果呢？其实在spp的不同比例中可以实现：如果输入尺寸特别大，则4×4比例的池化可以“站出来”完成任务；如果输入尺寸特别小，则1×1比例可以“站出来”完成任务！对于大图片来说，1×1比例可能没啥用， 但无非就是在特征向量里有一些无用信息而已，可以由网络自己学习去判别这些信息是“无用”的，实现输出维度的统一才是更要紧的事情！</p><ul><li>特征共享 (卷积共享)</li></ul><p>不同于R-CNN中，每一个候选区域分别卷积；SPP-net直接对原图进行一次卷积，后续的操作都在feature map上进行，大大节省了前向传播的时间！</p><p>除此以外，由于SPP-net采用金字塔池化来适应不同尺寸，没有用resize对原图区域进行扭曲、拉伸，所以网络的表现甚至更好！</p><p>5.RCNN与SPP-net的流程比较：</p><p>（上R-CNN，下SPP-net）</p><img src="/images/image-20210411120210657.png" alt="image-20210411120210657" style="zoom:67%;">]]></content>
    
    
    <categories>
      
      <category>Deep Learning-Objects Detection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git学习笔记（二）</title>
    <link href="/2021/04/11/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2021/04/11/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>除了基本的操作外，Git最强大之处在于本地库与远程库的连接管理。我们熟悉的Github其实就是一个开源的远端服务器，本文就介绍Git的进阶知识。</p><span id="more"></span><h4 id="五、远程仓库（Git牛逼之处一）"><a href="#五、远程仓库（Git牛逼之处一）" class="headerlink" title="五、远程仓库（Git牛逼之处一）"></a>五、远程仓库（Git牛逼之处一）</h4><ol><li><strong>由本地库推送至远程库</strong></li></ol><p>远程库搭建方式：</p><p>（a）借助GitHub账户搭建( 可以把Github看成一个“远端服务器”， 这样Github上创建的所有仓库都可以看作<strong>“远程库”</strong>)； </p><p>（b）用自己的电脑搭建一个Git服务器</p><p>借助Github搭建远程Git仓库步骤：</p><p>（1）创建SSH Key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">ssh-keygen -t rsa -C &quot;youremail@example.com&quot;   #一路回车默认<br></code></pre></td></tr></table></figure><p>用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>首次使用，需要在Github账户管理处添加ssh公钥，添加完成后如下：</p><img src="/images/image-20210410150920367.png" alt="image-20210410150920367" style="zoom: 67%;"><p>（2）本地仓库关联Github的远程库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git remote add origin git@github.com:Ericccccc1022&#x2F;learngit.git  #在本地Git仓库目录下运行<br>                                                                 #远程库默认名字是origin<br>                                                               #learngit是刚在github中创建的仓库名<br>                                                               <br>git push -u origin master   #第一次推送master分支的所有内容<br>git push origin master     #此后每次本地提交后，就可以直接推送至远程库，不需要-u参数<br></code></pre></td></tr></table></figure><p>Git在没有网络时，也能完成<strong>本地提交</strong>工作，有网络后只需简单推送至远程库即可，非常方便！</p><p>2.<strong>从远程库克隆</strong></p><p>Github中的仓库都可以看作“远程库”，要克隆到本地，必须先知道仓库的地址，然后使用<code>git clone</code> 命令克隆</p><p>Git支持多种协议，包括<strong>https</strong>和<strong>ssh</strong>，但ssh协议的速度最快。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git clone git@github.com:Ericccccc1022&#x2F;test.git  #使用ssh协议的克隆<br><br>git clone https:&#x2F;&#x2F;github.com&#x2F;Ericccccc1022&#x2F;test.git  #使用https协议的克隆<br><br>#test是我早前在github账户中创建的一个仓库<br></code></pre></td></tr></table></figure><h4 id="六、分支管理（Git牛逼之处二）"><a href="#六、分支管理（Git牛逼之处二）" class="headerlink" title="六、分支管理（Git牛逼之处二）"></a>六、分支管理（Git牛逼之处二）</h4><p>1.</p><p><strong>一开始</strong>，master指向当前分支，HEAD指向master：</p><p><img src="/images/4" alt="git-br-initial"></p><p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p><p><strong>创建新的分支</strong>，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p><p><img src="/images/5" alt="git-br-create"></p><p>从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><p><img src="/images/6" alt="git-br-dev-fd"></p><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p><p><img src="/images/7" alt="git-br-ff-merge"></p><p>综上，Git创建分支、合并分支，仅仅只是指针的变动，因此速度非常快！</p><p>（1）创建分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git branch dev   #创建dev分支<br>git checkout dev  #切换到dev分支上<br><br>git checkout -b dev  #-b参数将上述两步合并，效果相同<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git branch  #查看当前分支<br><br>git checkout master  #回到master分支<br></code></pre></td></tr></table></figure><p>（2）合并分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git merge dev  # 合并指定分支到当前分支<br></code></pre></td></tr></table></figure><p>（3）删除分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git branch -d dev  #删除dev分支<br></code></pre></td></tr></table></figure><p>由于操作非常方便，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全！</p><p>（4）切换分支的新命令</p><p>由于撤销修改是<code>git checkout -- &lt;filename&gt;</code> , 因此checkout容易歧义。对此，可用switch命令完成分支切换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git switch -c dev  #创建并切换到新的分支<br><br>git switch master  #直接切换分支<br></code></pre></td></tr></table></figure><p>2.分支冲突</p><p>如果在不同分支下分别进行了修改，在merge时则会发生冲突；</p><p>解决办法：把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>3.合并分支的方式</p><p>默认采用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git merge --no-ff -m &quot;merge with no-ff&quot; dev  # --no-ff参数表明禁用Fast forward<br>                                    #本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去<br></code></pre></td></tr></table></figure><p>在<strong>实际开发</strong>中，我们应该按照几个基本原则进行分支管理：</p><p>（1）首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>（2）那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>（3）你和你的小伙伴们每个人都从<code>dev</code>分支引出自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p>（4）合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并</p><p><img src="/images/8" alt="git-br-policy"></p><p>4.<strong>Bug分支</strong></p><p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p><p>（1）当手头工作没有完成时，<strong>不能直接提交</strong>，但是又要进入新的分支修复bug，此时需要将<strong>工作现场</strong>保存一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git stash<br></code></pre></td></tr></table></figure><p>（2）然后去新的分支修复bug；假设在master分支上修复了bug，想在dev分支上也修复，Git提供了便捷的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">#切换到dev分支上<br><br>git cherry-pick 4c805e2   # 4c805e2是在master分支上提交时的id<br></code></pre></td></tr></table></figure><p>（3）修复完成，现在需要继续工作，取出缓存的工作空间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git stash list  #查看stash内容<br><br>git stash apply stash@&#123;0&#125;  #取出stash@&#123;0&#125;状态并在stash中删除它<br>git stash drop stash@&#123;0&#125;<br><br>git stash pop  #取出同时删除<br></code></pre></td></tr></table></figure><ol start="5"><li><strong>Feature分支</strong></li></ol><p>在软件开发中，通常需要开发新功能；每开发一个新功能，最好创建一个feature分支</p><p>例如现在要开发代号为scan_radar的新功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git switch -c feature-scan<br><br>#开发完成后<br>git add scan.py<br>git commit -m &quot;add feature scan&quot;<br><br>#切回dev，合并分支<br>git switch dev<br>git merge feature-scan<br></code></pre></td></tr></table></figure><p>若要删除还未合并的分支：用大写参数-D，强制删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git branch -D feature-scan<br></code></pre></td></tr></table></figure><p>6.<strong>多人协作</strong></p><p>多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><p>本地分支与远程库：</p><p>（1）查看远程库信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git remote -v<br></code></pre></td></tr></table></figure><p>（2）本地新建的分支如果不推送到远程，对其他人就是不可见的</p><p>（3）从本地推送分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git push origin &lt;branch-name&gt;<br><br>#若推送失败，则先抓取远程的新提交：<br>git pull<br>#若提示no tracking information,则建立关联：<br>git branch --set-upstream branch-name origin&#x2F;branch-name<br>#若推送有冲突，则要先解决冲突<br></code></pre></td></tr></table></figure><p>（4）若远程有多个分支，在本地创建和远程分支对应的分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git checkout -b branch-name origin&#x2F;branch-name<br></code></pre></td></tr></table></figure><p>7.Rebase操作</p><p>rebase操作可以把本地未push的分叉提交历史整理成直线</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git rebase<br></code></pre></td></tr></table></figure><h4 id="七、标签管理（tag）"><a href="#七、标签管理（tag）" class="headerlink" title="七、标签管理（tag）"></a>七、标签管理（tag）</h4><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>实际上tag是指向某个commit的指针，但该指针不能移动！</p><p>1.创建标签</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">#切换到目标分支上<br><br>git tag v1.0   #默认打在最新提交的commit上<br><br>git tag v0.9 f52c63  #如果要给历史版本打标签，则后面添加commit id<br></code></pre></td></tr></table></figure><p>创建带有说明的tag：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb  # -a标签名，-m说明文字<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git tag  #查看所有标签<br>git show v1.0  #查看标签信息<br></code></pre></td></tr></table></figure><p>2.操作标签</p><p>（1）删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git tag -d v1.0<br><br>#若已经推送到远程：<br>git tag -d v1.0<br>git push origin :refs&#x2F;tags&#x2F;v1.0<br></code></pre></td></tr></table></figure><p>（2）推送tag到远程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git push origin v1.0<br><br>git push origin --tags  #一次性推送全部尚未推送标签<br></code></pre></td></tr></table></figure><h4 id="八、开源社区Github"><a href="#八、开源社区Github" class="headerlink" title="八、开源社区Github"></a>八、开源社区Github</h4><p>参与代码贡献的流程：</p><p>（1）点“Fork”就在自己的账号下克隆了一个bootstrap仓库</p><p>（2）从自己的账号下clone到本地电脑（一定要从自己的账号下clone才能推送修改）</p><p>（3）往自己仓库推送更新，在github上发起一个pull request</p><p>在GitHub上，可以任意Fork开源仓库；自己拥有Fork后的仓库的读写权限；可以推送pull request给官方仓库来贡献代码。</p><p>拓：如果没有梯子，可以使用github“国内版”——Gitee ( gitee.com)</p><h4 id="九、自定义Git配置（简略了解）"><a href="#九、自定义Git配置（简略了解）" class="headerlink" title="九、自定义Git配置（简略了解）"></a>九、自定义Git配置（简略了解）</h4><p>1.忽略某些文件时，需要编写<code>.gitignore</code>文件，放到版本库里</p><p>2.配置别名（为了输入命令时偷懒）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git config --global alias.st status  #status设置别名st<br></code></pre></td></tr></table></figure><p>以下介绍一些常见的别名配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git config --global alias.co checkout<br>git config --global alias.ci commit<br>git config --global alias.br branch<br>git config --global alias.last &#39;log -1&#39;  # 用git last 就可以直接查看最新一次commit信息<br><br>git config --global alias.lg &quot;log --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot; <br># 用git lg可以查看git log信息，且有颜色配置！！<br></code></pre></td></tr></table></figure><p>3.搭建Git服务器</p><p>如果不想被github的开源性影响，则可以搭建自己的Git服务器；</p><p>用ubuntu系统搭建更简单，具体操作请Google。</p><h4 id="十、Git的图形界面工具——Source-Tree"><a href="#十、Git的图形界面工具——Source-Tree" class="headerlink" title="十、Git的图形界面工具——Source Tree"></a>十、Git的图形界面工具——Source Tree</h4><p>使用SourceTree可以以图形界面操作Git，省去了敲命令的过程，对于常用的提交、分支、推送等操作来说非常方便；</p><p>SourceTree使用Git命令执行操作，出错时，仍然需要阅读Git命令返回的错误信息。</p><h4 id="十一、最后"><a href="#十一、最后" class="headerlink" title="十一、最后"></a>十一、最后</h4><p>以上课程只是Git入门级别的知识，只涉及十余个常用命令，但是掌握这些命令已足够让我们得心应手地使用Git了！</p><p>附资料：</p><p>（1）常用的Git命令表：<a href="https://liaoxuefeng.gitee.io/resource.liaoxuefeng.com/git/git-cheat-sheet.pdf">https://liaoxuefeng.gitee.io/resource.liaoxuefeng.com/git/git-cheat-sheet.pdf</a></p><p>（2）Git官网：<a href="http://git-scm.com/">http://git-scm.com/</a></p><p><strong>全文参考</strong>：廖雪峰Git教程 <a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Git学习笔记（一）</title>
    <link href="/2021/04/11/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2021/04/11/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>众所周知，Git 是一个强大的开源分布式版本控制系统，在团队协作中发挥着尤其重要的作用。本博客就是将本地仓库部署到Github远程库，并通过Git工具进行管理的。</p><span id="more"></span><p>今天就简单介绍一下Git的基本概念和常用语法，掌握这些语法已经足够让我们得心应手地使用Git了！</p><h4 id="一、Git简介"><a href="#一、Git简介" class="headerlink" title="一、Git简介"></a>一、Git简介</h4><p>1.Git是目前世界上最先进的分布式版本控制系统</p><p>2.集中式vs分布式</p><p>（1）CVS、SVN，版本库是集中存放在中央服务器的，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。</p><p>（2）分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><h4 id="二、安装Git"><a href="#二、安装Git" class="headerlink" title="二、安装Git"></a>二、安装Git</h4><p>Git可以在Linux、Unix、Mac和Windows这几大平台上使用</p><p>1.Ubuntu安装Git：只需要一条命令，非常简单</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">sudo apt-get install git<br></code></pre></td></tr></table></figure><p>2.Windows安装Git：</p><p>从Git官网直接<a href="https://git-scm.com/downloads">下载安装程序</a>，然后按默认选项安装即可，</p><p>安装完成后，还需要最后一步设置，在命令行输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Windows">git config --global user.name &quot;Your Name&quot;<br>git config --global user.email &quot;Your_email@example.com&quot;<br></code></pre></td></tr></table></figure><p>–global参数表示你这台机器上所有的Git仓库都会使用这个配置了。</p><h4 id="三、创建版本库（Repository）"><a href="#三、创建版本库（Repository）" class="headerlink" title="三、创建版本库（Repository）"></a>三、创建版本库（Repository）</h4><p>简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪。</p><p>1.创建方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">mkdir git_learning  #创建一个空目录<br>cd git_learning<br><br>git init  #把该目录变成Git可以管理的仓库<br></code></pre></td></tr></table></figure><p>2.版本库的管理范围</p><p>所有的版本控制系统，其实只能跟踪<strong>文本文件</strong>的改动，因为文本是有编码的，强烈建议使用标准的<strong>UTF-8编码</strong>，统一方便管理。</p><p>而<strong>二进制文件</strong>，如图片、视频、Word文档等，版本控制系统是没法跟踪的。</p><p>3.将文件添加到仓库中</p><p>注意编写文本文件，使用UTF-8编码；Windows下，不要使用记事本，推荐使用Notepad++（由于某些特殊原因）</p><p>注：以下命令都必须再<strong>Git仓库目录</strong>下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">#Step1<br>编写一个test.txt文件，放到git_learning目录下<br><br>#Step2<br>git add test.txt    #用git add命令告诉Git，将文件添加到仓库<br><br>#Step3<br>git commit -m &quot;wrote a test file&quot;   #用git commit命令告诉Git，将文件提交到仓库<br>                                    #参数-m后面是对本次提交的说明，<br>                                    <br>                                    <br>#可以一次添加多个文件后再统一提交<br>git add file1.txt<br>git add file2.txt file3.txt<br>git commit -m &quot;add 3 files.&quot;<br></code></pre></td></tr></table></figure><h4 id="四、修改与管理"><a href="#四、修改与管理" class="headerlink" title="四、修改与管理"></a>四、修改与管理</h4><p>1.<strong>修改文件</strong></p><p>（1）时刻掌握仓库当前的状态：有无文件被修改、有无文件需要提交等等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git status<br></code></pre></td></tr></table></figure><p>（2）查看具体修改了什么内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git diff test.txt<br></code></pre></td></tr></table></figure><p>（3）得知具体修改的内容后，可以放心地提交到仓库上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git add test.txt<br>git commit -m &quot;add some words&quot;   #提交修改的文件同样需要两步：add、commit<br></code></pre></td></tr></table></figure><p>2.<strong>版本回退</strong></p><p>（1）查看历史版本记录——回到过去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git log   #查看历史版本<br><br>git reset --hard HEAD^   #回退到上一个版本<br></code></pre></td></tr></table></figure><p>​    显示从最近到最远的提交日志，第一行显示的是版本的commit id。</p><p>​    HEAD表示当前版本，HEAD ^表示上一个版本，HEAD^^表示上上一个版本，HEAD~100表示往前100个版本</p><p>（2）查看命令历史——回到未来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git reflog   #查看历史命令，可以看到未来版本的commit id<br><br>git reset --hard &lt;commit id&gt;   #id输入前几位即可，让Git自动查寻版本号<br></code></pre></td></tr></table></figure><p>3.<strong>Git的工作区与暂存区</strong></p><p>工作区（Working Directory）：电脑里能看到的目录就是</p><p>版本库（Repository）：<strong>stage暂存区</strong> + <strong>master分支</strong>（创建Git仓库时自动创建）</p><p><img src="/images/1" alt="git-repo"></p><p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区</p><p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支</p><p><img src="/images/2" alt="git-stage"></p><p><img src="/images/3" alt="git-stage-after-commit"></p><p>4.<strong>撤销修改</strong></p><p>（1）还未add到暂存区，仅撤销工作区的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git checkout -- &lt;filename&gt;<br></code></pre></td></tr></table></figure><p>（2）已经add到暂存区，要撤销暂存区的修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git reset HEAD &lt;filename&gt;   #丢弃暂存区修改<br><br>git checkout -- &lt;filename&gt;   #再丢弃工作区修改<br></code></pre></td></tr></table></figure><p>（3）已经commit到版本库，要撤销本次提交：</p><p>​        用前述的版本回退方法；</p><p>​        ps：如果已经推送到远程库，则没有办法撤销了！</p><p>5.<strong>删除文件 &amp; 恢复删除</strong></p><p>假设你在工作区中删除了某文件（例如ubuntu中用<code>sudo rm</code> 命令删除了某文件）</p><p>（1）从版本库中删除该文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git rm &lt;filename&gt;<br></code></pre></td></tr></table></figure><p>（2）从版本库中恢复该文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ubuntu">git checkout -- &lt;filename&gt;   #只能恢复文件到最新版本<br></code></pre></td></tr></table></figure><p><strong>全文参考</strong>：廖雪峰Git教程 <a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客+Typora文件部署</title>
    <link href="/2021/04/10/Hexo%E5%8D%9A%E5%AE%A2-Typora%E6%96%87%E4%BB%B6%E9%83%A8%E7%BD%B2/"/>
    <url>/2021/04/10/Hexo%E5%8D%9A%E5%AE%A2-Typora%E6%96%87%E4%BB%B6%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>博客的第一篇正式文章，简介用Typora编写文件并且部署到Hexo博客的方法：</p><span id="more"></span><h4 id="1-创建文章"><a href="#1-创建文章" class="headerlink" title="1.创建文章"></a>1.创建文章</h4><p>在站点文件夹下右键打开git bash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs git">hexo new &quot;title&quot;<br></code></pre></td></tr></table></figure><h4 id="2-编辑文章（使用Typora）"><a href="#2-编辑文章（使用Typora）" class="headerlink" title="2.编辑文章（使用Typora）"></a>2.编辑文章（使用Typora）</h4><p>在Typora中打开站点文件夹，即可编辑刚创建好的新文件，编辑好后保存</p><h4 id="3-部署与发布"><a href="#3-部署与发布" class="headerlink" title="3.部署与发布"></a>3.部署与发布</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs git">#方法一<br>hexo g  #生成部署文件<br>hexo s  #运行本站点<br>        #然后打开localhost:4000进行预览<br>hexo d  #确认无误后发布到github远端，登录Ericccccc1022.github.io可查看<br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs git">#方法二<br>hexo g -d #部署+发布一并完成<br></code></pre></td></tr></table></figure><p>如果在<code>hexo g -d</code>过程中遇到<code>error：spawn failed</code>的问题，解决办法：</p><p>（1）删除<code>.deploy_git</code>文件夹</p><p>（2）输入<code>git config --global core.autocrlf false</code></p><p>（3）依次执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs git">hexo clean<br>hexo g<br>hexo d<br></code></pre></td></tr></table></figure><p>直接暴力解决！</p><p>暂时简单介绍这么多，今天用了2个小时左右搭建起Hexo博客+理清楚如何攥写与部署文章。当然，能先写文章是最重要的，博客美化都是后话。</p><p>这里应该相当长一段时间都会是一个比较静谧的空间，可以寄存一下最近的学习笔记，或者随便写写最近的心得与迷茫。</p>]]></content>
    
    
    <categories>
      
      <category>Others</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Test message</title>
    <link href="/2021/04/10/Test-message/"/>
    <url>/2021/04/10/Test-message/</url>
    
    <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><p>This is a test file.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pytorch<br><span class="hljs-keyword">import</span> cv2<br></code></pre></td></tr></table></figure><p>测试<strong>加粗</strong>功能</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/04/10/hello-world/"/>
    <url>/2021/04/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
